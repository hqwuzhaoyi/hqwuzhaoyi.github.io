<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>webpack 笔记 | Prajna's blog</title><meta name="keywords" content="源码,webpack"><meta name="author" content="Wu Zhaoyi,hqwuzhaoyi@foxmail.com"><meta name="copyright" content="Wu Zhaoyi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Webpack 核心原理一文吃透 Webpack 核心原理 主体框架 核心流程解析 初始化阶段 初始化参数：从配置文件、 配置对象、Shell 参数中读取，与默认配置结合得出最终的参数 创建编译器对象：用上一步得到的参数创建 Compiler 对象 初始化编译环境：包括注入内置插件、注册各种模块工厂、初始化 RuleSet 集合、加载配置的插件等 开始编译：执行 Compiler 对象的 run">
<meta property="og:type" content="article">
<meta property="og:title" content="webpack 笔记">
<meta property="og:url" content="https://hqwuzhaoyi.github.io/2021/07/20/webpack/webpack%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Prajna&#39;s blog">
<meta property="og:description" content="Webpack 核心原理一文吃透 Webpack 核心原理 主体框架 核心流程解析 初始化阶段 初始化参数：从配置文件、 配置对象、Shell 参数中读取，与默认配置结合得出最终的参数 创建编译器对象：用上一步得到的参数创建 Compiler 对象 初始化编译环境：包括注入内置插件、注册各种模块工厂、初始化 RuleSet 集合、加载配置的插件等 开始编译：执行 Compiler 对象的 run">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210720223312.jpg">
<meta property="article:published_time" content="2021-07-20T00:00:00.000Z">
<meta property="article:modified_time" content="2022-08-29T03:13:16.656Z">
<meta property="article:author" content="Wu Zhaoyi">
<meta property="article:tag" content="源码">
<meta property="article:tag" content="webpack">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210720223312.jpg"><link rel="shortcut icon" href="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/favicon.ico?versionId=CAEQIBiBgICUj6fpxhciIGVlZDJjMTcyMGRkMjQ0MGViNDIyOWEyNDdkOGI5YjQ5"><link rel="canonical" href="https://hqwuzhaoyi.github.io/2021/07/20/webpack/webpack%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js" defer></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?4af216cebbf1ef8bfe277df5447157c1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"LPQ2BDF707","apiKey":"b955341b8b62ac31533e2e1ff3aa5fd0","indexName":"wzy","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-08-29 03:13:16'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Prajna's blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210416184339.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">123</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">48</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210720223312.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Prajna's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">webpack 笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-20T00:00:00.000Z" title="发表于 2021-07-20 00:00:00">2021-07-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-08-29T03:13:16.656Z" title="更新于 2022-08-29 03:13:16">2022-08-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/webpack/">webpack</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">15.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>57分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="webpack 笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="Webpack-核心原理"><a href="#Webpack-核心原理" class="headerlink" title="Webpack 核心原理"></a>Webpack 核心原理</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/363928061">一文吃透 Webpack 核心原理</a></p>
<h3 id="主体框架"><a href="#主体框架" class="headerlink" title="主体框架"></a>主体框架</h3><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210720223438.jpg" alt="主体框架"></p>
<h3 id="核心流程解析"><a href="#核心流程解析" class="headerlink" title="核心流程解析"></a>核心流程解析</h3><ol>
<li>初始化阶段<ol>
<li>初始化参数：从配置文件、 配置对象、Shell 参数中读取，与默认配置结合得出最终的参数</li>
<li>创建编译器对象：用上一步得到的参数创建 <code>Compiler</code> 对象</li>
<li>初始化编译环境：包括注入内置插件、注册各种模块工厂、初始化 RuleSet 集合、加载配置的插件等</li>
<li>开始编译：执行 <code>Compiler</code> 对象的 <code>run</code> 方法</li>
<li>确定入口：根据配置中的 entry 找出所有的入口文件，调用 <code>compilation.addEntry</code> 将入口文件转换为 <code>dependence</code> 对象</li>
</ol>
</li>
<li>构建阶段<ol>
<li>编译模块(make)：根据 entry 对应的 <code>dependence</code> 创建 <code>module</code> 对象，调用 <code>loader</code> 将模块转译为标准 JS 内容，调用 JS 解释器将内容转换为 AST 对象，从中找出该模块依赖的模块，再 递归 本步骤直到所有入口依赖的文件都经过了本步骤的处理</li>
<li>完成模块编译：上一步递归处理所有能触达到的模块后，得到了每个模块被翻译后的内容以及它们之间的 依赖关系图</li>
</ol>
</li>
<li>生成阶段<ol>
<li>输出资源(seal)：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 <code>Chunk</code>，再把每个 <code>Chunk</code> 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会</li>
<li>写入文件系统(emitAssets)：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统</li>
</ol>
</li>
</ol>
<p>技术名词介绍</p>
<ul>
<li>Entry：编译入口，webpack 编译的起点</li>
<li>Compiler：编译管理器，webpack 启动后会创建 <code>compiler</code> 对象，该对象一直存活知道结束退出</li>
<li>Compilation：单次编辑过程的管理器，比如 watch = true 时，运行过程中只有一个 <code>compiler</code> 但每次文件变更触发重新编译时，都会创建一个新的 <code>compilation</code> 对象</li>
<li>Dependence：依赖对象，webpack 基于该类型记录模块间依赖关系</li>
<li>Module：webpack 内部所有资源都会以<code>module</code>对象形式存在，所有关于资源的操作、转译、合并都是以 <code>module</code> 为基本单位进行的</li>
<li>Chunk：编译完成准备输出时，webpack 会将 <code>module</code> 按特定的规则组织成一个一个的 <code>chunk</code>，这些 <code>chunk</code> 某种程度上跟最终输出一一对应</li>
<li>Loader：资源内容转换器，其实就是实现从内容 A 转换 B 的转换器</li>
<li>Plugin：webpack 构建过程中，会在特定的时机广播对应的事件，插件监听这些事件，在特定时间点介入编译过程</li>
</ul>
<h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210720225459.jpg" alt="初始化阶段"></p>
<h3 id="构建阶段"><a href="#构建阶段" class="headerlink" title="构建阶段"></a>构建阶段</h3><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210720230409.jpg" alt="构建阶段"></p>
<h3 id="生成阶段"><a href="#生成阶段" class="headerlink" title="生成阶段"></a>生成阶段</h3><p><code>seal</code> 原意密封、上锁，我个人理解在 webpack 语境下接近于 “将模块装进蜜罐” 。seal 函数主要完成从 <code>module</code> 到 <code>chunks</code> 的转化，核心流程：</p>
<p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210720230659.jpg" alt="生成阶段"></p>
<h3 id="资源形态流转"><a href="#资源形态流转" class="headerlink" title="资源形态流转"></a>资源形态流转</h3><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210720231219.jpg" alt="资源形态流转"></p>
<ul>
<li><code>compiler.make</code> phase：<ul>
<li>entry 文件以 <code>dependence</code> 对象形式加入 <code>compilation</code> 的依赖列表，<code>dependence</code> 对象记录有 <code>entry</code> 的类型、路径等信息</li>
<li>根据 <code>dependence</code> 调用对应的工厂函数创建 <code>module</code> 对象，之后读入 <code>module</code> 对应的文件内容，调用 <code>loader-runner</code> 对内容做转化，转化结果若有其它依赖则继续读入依赖资源，重复此过程直到所有依赖均被转化为 <code>module</code></li>
</ul>
</li>
<li><code>compilation.seal</code> phase：<ul>
<li>遍历 <code>module</code> 集合，根据 <code>entry</code> 配置及引入资源的方式，将 <code>module</code> 分配到不同的 <code>chunk</code></li>
<li>遍历 <code>chunk</code> 集合，调用 <code>compilation.emitAsset</code> 方法标记 <code>chunk</code> 的输出规则，即转化为 <code>assets</code> 集合</li>
</ul>
</li>
<li><code>compiler.emitAssets</code> phase：<ul>
<li>将 <code>assets</code> 写入文件系统</li>
</ul>
</li>
</ul>
<h2 id="Webpack-插件架构深度讲解"><a href="#Webpack-插件架构深度讲解" class="headerlink" title="Webpack 插件架构深度讲解"></a>Webpack 插件架构深度讲解</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/367931462">[源码解读] Webpack 插件架构深度讲解</a></p>
<h3 id="Tapable-全解析"><a href="#Tapable-全解析" class="headerlink" title="Tapable 全解析"></a>Tapable 全解析</h3><p>Tapable 是 Webpack 插件架构的核心支架，但它的源码量其实很少，本质上就是围绕着 订阅/发布 模式叠加各种特化逻辑，适配 webpack 体系下复杂的事件源-处理器之间交互需求，比有些场景需要支持将前一个处理器的结果传入下一个回调处理器；有些场景需要支持异步并行调用这些回调处理器。</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>Tapable 使用时通常需要经历如下步骤：</p>
<ul>
<li>创建钩子实例</li>
<li>调用订阅接口注册回调，包括：<code>tap</code>、<code>tapAsync</code>、<code>tapPromise</code></li>
<li>调用发布接口触发回调，包括：<code>call</code>、<code>callAsync</code>、<code>promise</code></li>
</ul>
<p>example</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; SyncHook &#125; = <span class="built_in">require</span>(<span class="string">&quot;tapable&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 创建钩子实例</span></span><br><span class="line"><span class="keyword">const</span> sleep = <span class="keyword">new</span> SyncHook();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 调用订阅接口注册回调</span></span><br><span class="line">sleep.tap(<span class="string">&quot;test&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;callback A&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 调用发布接口触发回调</span></span><br><span class="line">sleep.call();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="comment">// callback A</span></span><br></pre></td></tr></table></figure>

<p>示例中使用 <code>tap</code> 注册回调，使用 <code>call</code> 触发回调，在某些钩子中还可以使用异步风格的 <code>tapAsync/callAsync</code>、promise 风格 <code>tapPromise/promise</code>，具体使用哪一类函数与钩子类型有关。</p>
<h3 id="Tapable-钩子类型"><a href="#Tapable-钩子类型" class="headerlink" title="Tapable 钩子类型"></a>Tapable 钩子类型</h3><table>
<thead>
<tr>
<th>名称</th>
<th>简介</th>
<th>统计</th>
</tr>
</thead>
<tbody><tr>
<td>SyncHook</td>
<td>同步钩子</td>
<td>Webpack 共出现 86 次，如 Compiler.hooks.compilation</td>
</tr>
<tr>
<td>SyncBailHook</td>
<td>同步熔断钩子</td>
<td>Webpack 共出现 90 次，如 Compiler.hooks.shouldEmit</td>
</tr>
<tr>
<td>SyncWaterfallHook</td>
<td>同步瀑布流钩子</td>
<td>Webpack 共出现 26 次，如 Compilation.hooks.assetPath</td>
</tr>
<tr>
<td>SyncLoopHook</td>
<td>同步循环钩子</td>
<td>Webpack 中未使用</td>
</tr>
<tr>
<td>AsyncParallelHook</td>
<td>异步并行钩子</td>
<td>Webpack 仅出现 6 次：Compiler.hooks.make</td>
</tr>
<tr>
<td>AsyncParallelBailHook</td>
<td>异步并行熔断钩子</td>
<td>Webpack 中未使用</td>
</tr>
<tr>
<td>AsyncSeriesHook</td>
<td>异步串行钩子</td>
<td>Webpack 共出现 32 次，如 Compiler.hooks.done</td>
</tr>
<tr>
<td>AsyncSeriesBailHook</td>
<td>异步串行熔断钩子</td>
<td>Webpack 共出现 9 次，如 Compilation.hooks.optimizeChunkModules</td>
</tr>
<tr>
<td>AsyncSeriesLoopHook</td>
<td>异步串行循环钩子</td>
<td>Webpack 中未使用</td>
</tr>
<tr>
<td>AsyncSeriesWaterfallHook</td>
<td>异步串行瀑布流钩子</td>
<td>Webpack 共出现 3 次，如 ContextModuleFactory.hooks.beforeResolve</td>
</tr>
</tbody></table>
<p>按回调逻辑，分为：</p>
<ul>
<li>基本类型，名称不带 <code>Waterfall</code>/<code>Bail</code>/<code>Loop</code> 关键字，与通常 「订阅/回调」 模式相似，按钩子注册顺序，逐次调用回调<ol>
<li><code>waterfall</code> 类型：前一个回调的返回值会被带入下一个回调</li>
<li><code>bail</code> 类型：逐次调用回调，若有任何一个回调返回非 undefined 值，则终止后续调用</li>
<li><code>loop</code> 类型：逐次、循环调用，直到所有回调函数都返回 undefined</li>
</ol>
</li>
<li>第二个维度，按执行回调的并行方式，分为：<ol>
<li><code>sync</code> ：同步执行，启动后会按次序逐个执行回调，支持 <code>call</code>/<code>tap</code> 调用语句</li>
<li><code>async</code> ：异步执行，支持传入 callback 或 promise 风格的异步回调函数，支持 <code>callAsync/tapAsync</code> 、<code>promise/tapPromise</code> 两种调用语句</li>
</ol>
</li>
</ul>
<h2 id="Dependency-Graph-深度解析"><a href="#Dependency-Graph-深度解析" class="headerlink" title="Dependency Graph 深度解析"></a>Dependency Graph 深度解析</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/369953304">有点难的 Webpack 知识点：Dependency Graph 深度解析</a></p>
<p>webpack 处理应用代码时，会从开发者提供的 <code>entry</code> 开始递归地组建起包含所有模块的 <code>Dependency Graph</code> ，之后再将这些 <code>module</code> 打包为 <code>bundles</code> 。</p>
<h3 id="Dependency-Graph"><a href="#Dependency-Graph" class="headerlink" title="Dependency Graph"></a>Dependency Graph</h3><p>本节将深入 webpack 源码，解读 Dependency Graph 的内在数据结构及依赖关系收集过程。在正式展开之前，有必要回顾几个 webpack 重要的概念：</p>
<ul>
<li><code>Module</code> ：资源在 webpack 内部的映射对象，包含了资源的路径、上下文、依赖、内容等信息</li>
<li><code>Dependency</code> ：在模块中引用其它模块，例如 <code>import &quot;a.js&quot;</code> 语句，webpack 会先将引用关系表述为 <code>Dependency</code> 子类并关联 <code>module</code> 对象，等到当前 <code>module</code> 内容都解析完毕之后，启动下次循环开始将 <code>Dependency</code> 对象转换为适当的 <code>Module</code> 子类。</li>
<li><code>Chunk</code> ：用于组织输出结构的对象，webpack 分析完所有模块资源的内容，构建出完整的 <code>Dependency Graph</code> 之后，会根据用户配置及 <code>Dependency Graph</code> 内容构建出一个或多个 <code>chunk</code> 实例，每个 <code>chunk</code> 与最终输出的文件大致上是一一对应的。</li>
</ul>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>Webpack 4.x 的 <code>Dependency Graph</code> 实现较简单，主要由 Dependence/Module 内置的系列属性记录引用、被引用关系。</p>
<p>而 Webpack 5.0 之后则实现了一套相对复杂的类结构记录模块间依赖关系，将模块依赖相关的逻辑从 Dependence/Module 解耦为一套独立的类型结构，主要类型有：</p>
<ul>
<li><code>ModuleGraph</code> ：记录 <code>Dependency Graph</code> 信息的容器，一方面保存了构建过程中涉及到的所有 <code>module</code> <code>、dependency</code> 对象，以及这些对象互相之间的引用；另一方面提供了各种工具方法，方便使用者迅速读取出 <code>module</code> 或 <code>dependency</code> 附加的信息</li>
<li><code>ModuleGraphConnection</code> ：记录模块间引用关系的数据结构，内部通过 <code>originModule</code> 属性记录引用关系中的父模块，通过 <code>module</code> 属性记录子模块。此外还提供了一系列函数工具用于判断对应的引用关系的有效性</li>
<li><code>ModuleGraphModule</code> ：Module 对象在 <code>Dependency Graph</code> 体系下的补充信息，包含模块对象的 <code>incomingConnections</code> —— 指向模块本身的 <code>ModuleGraphConnection</code> 集合，即谁引用了模块自己；<code>outgoingConnections</code> —— 该模块对外的依赖，即该模块引用了其他那些模块。</li>
</ul>
<p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210720232835.jpg" alt="Dependency Graph"></p>
<ul>
<li><code>ModuleGraph</code> 对象通过 <code>_dependencyMap</code> 属性记录 <code>Dependency</code> 对象与 <code>ModuleGraphConnection</code> 连接对象之间的映射关系，后续的处理中可以基于这层映射迅速找到 <code>Dependency</code> 实例对应的引用与被引用者</li>
<li><code>ModuleGraph</code> 对象通过 <code>_moduleMap</code> 在 <code>module</code> 基础上附加 <code>ModuleGraphModule</code> 信息，而 <code>ModuleGraphModule</code> 最大的作用就是记录了模块的引用与被引用关系，后续的处理可以基于该属性找到 <code>module</code> 实例的所有依赖与被依赖关系</li>
</ul>
<p><code>ModuleGraph</code>、<code>ModuleGraphConnection</code>、<code>ModuleGraphModule</code> 三者协作，在 webpack 构建过程(<code>make</code> 阶段)中逐步收集模块间的依赖关系</p>
<p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210720232959.jpg" alt="依赖收集过程"></p>
<ul>
<li><code>addDependency</code> ：webpack 从模块内容中解析出引用关系后，创建适当的 <code>Dependency</code> 子类并调用该方法记录到 <code>module</code> 实例</li>
<li><code>handleModuleCreation</code> ：模块解析完毕后，webpack 遍历父模块的依赖集合，调用该方法创建 <code>Dependency</code> 对应的子模块对象，之后调用 <code>compilation.moduleGraph.setResolvedModule</code> 方法将父子引用信息记录到 <code>ModuleGraph</code> 对象上</li>
</ul>
<h3 id="实例解析"><a href="#实例解析" class="headerlink" title="实例解析"></a>实例解析</h3><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210720233135.jpg" alt="实例解析"></p>
<p>Webpack 启动后，在构建阶段递归调用 <code>compilation.handleModuleCreation</code> 函数，逐步补齐 <code>Dependency Graph</code> 结构，最终可能生成如下数据结果：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">ModuleGraph: &#123;</span><br><span class="line">    _dependencyMap: Map(3)&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            EntryDependency&#123;request: &quot;./src/index.js&quot;&#125; =&gt; ModuleGraphConnection&#123;</span><br><span class="line">                module: NormalModule&#123;request: &quot;./src/index.js&quot;&#125;,</span><br><span class="line">                // 入口模块没有引用者，故设置为 null</span><br><span class="line">                originModule: null</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            HarmonyImportSideEffectDependency&#123;request: &quot;./src/a.js&quot;&#125; =&gt; ModuleGraphConnection&#123;</span><br><span class="line">                module: NormalModule&#123;request: &quot;./src/a.js&quot;&#125;,</span><br><span class="line">                originModule: NormalModule&#123;request: &quot;./src/index.js&quot;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            HarmonyImportSideEffectDependency&#123;request: &quot;./src/a.js&quot;&#125; =&gt; ModuleGraphConnection&#123;</span><br><span class="line">                module: NormalModule&#123;request: &quot;./src/b.js&quot;&#125;,</span><br><span class="line">                originModule: NormalModule&#123;request: &quot;./src/index.js&quot;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    _moduleMap: Map(3)&#123;</span><br><span class="line">        NormalModule&#123;request: &quot;./src/index.js&quot;&#125; =&gt; ModuleGraphModule&#123;</span><br><span class="line">            incomingConnections: Set(1) [</span><br><span class="line">                // entry 模块，对应 originModule 为null</span><br><span class="line">                ModuleGraphConnection&#123; module: NormalModule&#123;request: &quot;./src/index.js&quot;&#125;, originModule:null &#125;</span><br><span class="line">            ],</span><br><span class="line">            outgoingConnections: Set(2) [</span><br><span class="line">                // 从 index 指向 a 模块</span><br><span class="line">                ModuleGraphConnection&#123; module: NormalModule&#123;request: &quot;./src/a.js&quot;&#125;, originModule: NormalModule&#123;request: &quot;./src/index.js&quot;&#125; &#125;,</span><br><span class="line">                // 从 index 指向 b 模块</span><br><span class="line">                ModuleGraphConnection&#123; module: NormalModule&#123;request: &quot;./src/b.js&quot;&#125;, originModule: NormalModule&#123;request: &quot;./src/index.js&quot;&#125; &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        NormalModule&#123;request: &quot;./src/a.js&quot;&#125; =&gt; ModuleGraphModule&#123;</span><br><span class="line">            incomingConnections: Set(1) [</span><br><span class="line">                ModuleGraphConnection&#123; module: NormalModule&#123;request: &quot;./src/a.js&quot;&#125;, originModule: NormalModule&#123;request: &quot;./src/index.js&quot;&#125; &#125;</span><br><span class="line">            ],</span><br><span class="line">            // a 模块没有其他依赖，故 outgoingConnections 属性值为 undefined</span><br><span class="line">            outgoingConnections: undefined</span><br><span class="line">        &#125;,</span><br><span class="line">        NormalModule&#123;request: &quot;./src/b.js&quot;&#125; =&gt; ModuleGraphModule&#123;</span><br><span class="line">            incomingConnections: Set(1) [</span><br><span class="line">                ModuleGraphConnection&#123; module: NormalModule&#123;request: &quot;./src/b.js&quot;&#125;, originModule: NormalModule&#123;request: &quot;./src/index.js&quot;&#125; &#125;</span><br><span class="line">            ],</span><br><span class="line">            // b 模块没有其他依赖，故 outgoingConnections 属性值为 undefined</span><br><span class="line">            outgoingConnections: undefined</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="module-issuer"><a href="#module-issuer" class="headerlink" title="module.issuer"></a>module.issuer</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/368391369">十分钟精进 Webpack：module.issuer 属性详解</a></p>
<p>在 webpack 实现上，文件资源使用 <code>Module</code> 类管理，所有关于资源的操作、转译、合并、关系都在 <code>module</code> 实现。而 <code>module.issuer</code> 属性用于记录资源的引用者，例如对于下面的资源依赖：</p>
<p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210726160052.jpg" alt="modole issuer 资源依赖"></p>
<p><code>index</code> 引用了 <code>a/b</code> 两个文件，webpack 构建时会用三个 <code>module</code> 对象分别对应三个文件，同时在 <code>a/b</code> 模块中通过 <code>issuer</code> 属性指向 <code>index</code> 模块：</p>
<ul>
<li><code>module[&#39;a.js&#39;].issuer = module[&#39;index.js&#39;]</code></li>
<li><code>module[&#39;b.js&#39;].issuer = module[&#39;index.js&#39;]</code><br>通过 <code>issuer</code> 属性，模块可以反向查找到引用者。</li>
</ul>
<h3 id="实例：-Stats-类"><a href="#实例：-Stats-类" class="headerlink" title="实例： Stats 类"></a>实例： Stats 类</h3><p><code>Stats</code> 是 webpack 内置的对象，用于收集构建过程信息，比如耗时、模块依赖关系、错误信息、报警信息等，我们运行 webpack 命令输出的命令行信息就是由 <code>Stats</code> 类提供的</p>
<p>如果编译过程发生错误，<code>Stats</code> 会通过 <code>module.issuer</code> 属性逐级往上查找出完整调用堆栈</p>
<p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210726160742.jpg" alt="Stats"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stats</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">compilation</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">toJson</span>(<span class="params">options, forToString</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> formatError = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">if</span> (showModuleTrace &amp;&amp; e.origin) &#123;</span><br><span class="line">        text += <span class="string">`\n @ <span class="subst">$&#123;<span class="built_in">this</span>.formatFilePath(</span></span></span><br><span class="line"><span class="string"><span class="subst">          e.origin.readableIdentifier(requestShortener)</span></span></span><br><span class="line"><span class="string"><span class="subst">        )&#125;</span>`</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">while</span> (current.issuer) &#123;</span><br><span class="line">          current = current.issuer;</span><br><span class="line">          text += <span class="string">`\n @ <span class="subst">$&#123;current.readableIdentifier(requestShortener)&#125;</span>`</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> text;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210726160604.jpg" alt="Stats 错误堆栈"></p>
<h3 id="何时修改-issuer"><a href="#何时修改-issuer" class="headerlink" title="何时修改 issuer"></a>何时修改 issuer</h3><p>在 <code>compilation</code> 解析出 <code>index.js</code> 内容的 <code>AST</code> 后，遍历 <code>require/import</code> 语句解读当前模块引用了那些资源，解析到任意依赖后就会调用 <code>addModuleDependencies</code> 记录依赖关系，从 <code>addModuleDependencies</code> 源码看在依赖被创建为 <code>module</code> 时，会同步修改新模块的 <code>issuer</code> ，记录引用者的信息。</p>
<h2 id="Webpack-Chunk-分包规则详解"><a href="#Webpack-Chunk-分包规则详解" class="headerlink" title="Webpack Chunk 分包规则详解"></a>Webpack Chunk 分包规则详解</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/371999555">Webpack Chunk 分包规则详解</a></p>
<p>webpack 实现中，原始的资源模块以 <code>Module</code> 对象形式存在、流转、解析处理。</p>
<p>而 <code>Chunk</code> 则是输出产物的基本组织单位，在生成阶段 webpack 按规则将 <code>entry</code> 及其它 <code>Module</code> 插入 <code>Chunk</code> 中，之后再由 <code>SplitChunksPlugin</code> 插件根据优化规则与 <code>ChunkGraph</code> 对 <code>Chunk</code> 做一系列的变化、拆解、合并操作，重新组织成一批性能(可能)更高的 <code>Chunks</code> 。运行完毕之后 webpack 继续将 <code>chunk</code> 一一写入物理文件中，完成编译工作。</p>
<p>综上，<code>Module</code> 主要作用在 webpack 编译过程的前半段，解决原始资源“<strong>「如何读」</strong>”的问题；而 <code>Chunk</code> 对象则主要作用在编译的后半段，解决编译产物“<strong>「如何写」</strong>”的问题，两者合作搭建起 webpack 搭建主流程。</p>
<h3 id="默认分包规则"><a href="#默认分包规则" class="headerlink" title="默认分包规则"></a>默认分包规则</h3><p>Webpack 4 之后编译过程大致上可以拆解为四个阶段</p>
<p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210726163443.jpg" alt="四个阶段"></p>
<p>在构建(<code>make</code>) 阶段，webpack 从 <code>entry</code> 出发根据模块间的引用关系(<code>require/import</code>) 逐步构建出模块依赖关系图(<a href="#Dependency-Graph-%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90">ModuleDependencyGraph</a>)，依赖关系图表达了模块与模块之间互相引用的先后次序，基于这种次序 webpack 就可以推断出模块运行之前需要先执行那些依赖模块，也就可以进一步推断出那些模块应该打包在一起，那些模块可以延后加载(异步执行)，关于模块依赖图的更多信息，可以参考我另一篇文章 《有点难的 webpack 知识点：Dependency Graph 深度解析》。</p>
<p>到了生成(<code>seal</code>) 阶段，webpack 会根据模块依赖图的内容组织分包 —— <code>Chunk</code> 对象，默认的分包规则有：</p>
<ul>
<li>同一个 <code>entry</code> 下触达到的模块组织成一个 <code>chunk</code></li>
<li>异步模块单独组织为一个 <code>chunk</code></li>
<li><code>entry.runtime</code> 单独组织成一个 <code>chunk</code></li>
</ul>
<p>默认规则集中在 <code>compilation.seal</code> 函数实现，<code>seal</code> 核心逻辑运行结束后会生成一系列的 <code>Chunk</code>、<code>ChunkGroup</code>、<code>ChunkGraph</code> 对象，后续如 <code>SplitChunksPlugin</code> 插件会在 <code>Chunk</code> 系列对象上做进一步的拆解、优化，最终反映到输出上才会表现出复杂的分包结果。</p>
<h3 id="Entry-分包处理"><a href="#Entry-分包处理" class="headerlink" title="Entry 分包处理"></a>Entry 分包处理</h3><pre><code>重点：seal 阶段遍历 entry 对象，为每一个 entry 单独生成 chunk，之后再根据模块依赖图将 entry 触达到的所有模块打包进 chunk 中。
</code></pre>
<p>在生成阶段，Webpack 首先根据遍历用户提供的 entry 属性值，为每一个 entry 创建 Chunk 对象，比如对于如下配置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">&quot;./src/main&quot;</span>,</span><br><span class="line">    home: <span class="string">&quot;./src/home&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Webpack 遍历 entry 对象属性并创建出 <code>chunk[main]</code> <code>、chunk[home]</code> 两个对象，此时两个 chunk 分别包含 <code>main</code> <code>、home</code> 模块：</p>
<p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210726164728.jpg" alt="chunk[main] 、chunk[home]"></p>
<p>初始化完毕后，Webpack 会读取 <code>ModuleDependencyGraph</code> 的内容，将 <code>entry</code> 所对应的内容塞入对应的 <code>chunk</code> (发生在 <code>webpack/lib/buildChunkGrap.js</code> 文件)。比如对于如下文件依赖：</p>
<p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210726164819.jpg" alt="entry 所对应的内容塞入对应的 chunk"></p>
<p><code>main.js</code> 以同步方式直接或间接引用了 <code>a/b/c/d</code> 四个文件，分析 <code>ModuleDependencyGraph</code> 过程会逐步将 <code>a/b/c/d</code> 模块逐步添加到 <code>chunk[main]</code> 中，最终形成：</p>
<p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210726164928.jpg" alt="Initial chunk"></p>
<h3 id="异步模块分包处理"><a href="#异步模块分包处理" class="headerlink" title="异步模块分包处理"></a>异步模块分包处理</h3><pre><code>重点：分析 ModuleDependencyGraph 时，每次遇到异步模块都会为之创建单独的 Chunk 对象，单独打包异步模块。
</code></pre>
<p>Webpack 4 之后，只需要用异步语句 <code>require.ensure(&quot;./xx.js&quot;)</code> 或 <code>import(&quot;./xx.js&quot;)</code> 方式引入模块，就可以实现模块的动态加载，这种能力本质也是基于 <code>Chunk</code> 实现的。</p>
<p>Webpack 生成阶段中，遇到异步引入语句时会为该模块单独生成一个 <code>chunk</code> 对象，并将其子模块都加入这个 <code>chunk</code> 中。例如对于下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js, entry 文件</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync-a&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync-b&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(<span class="string">&quot;async-c&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>在 <code>index.js</code> 中，以同步方式引入 <code>sync-a</code>、<code>sync-b</code>；以异步方式引入 <code>async-a</code> 模块；同时，在 <code>async-c</code> 中以同步方式引入 <code>sync-c</code> 模块。对应的模块依赖如：</p>
<p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210726165241.jpg" alt="async-c"></p>
<p>此时，webpack 会为入口 <code>index.js</code>、异步模块 <code>async-a.js</code> 分别创建分包，形成如下数据：</p>
<p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210726165315.jpg" alt="创建分包"></p>
<p>里需要引入一个新的概念 —— <code>Chunk</code> 间的父子关系。由 <code>entry</code> 生成的 <code>Chunk</code> 之间相互孤立，没有必然的前后依赖关系，但异步生成的 <code>Chunk</code> 则不同，引用者(上例 <code>index.js</code> 块)需要在特定场景下使用被引用者(上例 <code>async-a</code> 块)，两者间存在单向依赖关系，在 webpack 中称引用者为 <code>parent</code>、被引用者为 <code>child</code>，分别存放在 <code>ChunkGroup._parents</code> <code>、ChunkGroup._children</code> 属性中。</p>
<p>上述分包方案默认情况下会生成两个文件：</p>
<ul>
<li>入口 <code>index</code> 对应的 <code>index.js</code></li>
<li>异步模块 <code>async-a</code> 对应的 <code>src_async-a_js.js</code></li>
</ul>
<p>运行时，webpack 在 index.js 中使用 promise 及 <code>__webpack_require__.e</code> 方法异步载入并运行文件 <code>src_async-a_js.js</code> ，从而实现动态加载。</p>
<p><em>PS</em>: 基于异步模块的 <code>chunk</code> 在 webpack 官方文档中，通常称之为 <strong>「Async chunk」</strong></p>
<h3 id="Runtime-分包"><a href="#Runtime-分包" class="headerlink" title="Runtime 分包"></a>Runtime 分包</h3><pre><code>重点： Webpack 5 之后还能根据 `entry.runtime` 配置单独打包运行时代码。
</code></pre>
<p>除了 entry、异步模块外，webpack 5 之后还支持基于 <code>runtime</code> 的分包规则。除业务代码外，Webpack 编译产物中还需要包含一些用于支持 webpack 模块化、异步加载等特性的支撑性代码，这类代码在 webpack 中被统称为 <code>runtime</code>。举个例子，产物中通常会包含如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******/</span> (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// webpackBootstrap</span></span><br><span class="line">  <span class="comment">/******/</span> <span class="keyword">var</span> __webpack_modules__ = &#123;&#125;; <span class="comment">// The module cache</span></span><br><span class="line">  <span class="comment">/************************************************************************/</span></span><br><span class="line">  <span class="comment">/******/</span> <span class="comment">/******/</span> <span class="keyword">var</span> __webpack_module_cache__ = &#123;&#125;; <span class="comment">// The require function</span></span><br><span class="line">  <span class="comment">/******/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/******/</span> <span class="comment">/******/</span> <span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/******/</span> <span class="comment">/******/</span> __webpack_modules__[moduleId](</span><br><span class="line">      <span class="built_in">module</span>,</span><br><span class="line">      <span class="built_in">module</span>.exports,</span><br><span class="line">      __webpack_require__</span><br><span class="line">    ); <span class="comment">// Return the exports of the module</span></span><br><span class="line">    <span class="comment">/******/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/******/</span> <span class="comment">/******/</span> <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">    <span class="comment">/******/</span></span><br><span class="line">  &#125; <span class="comment">// expose the modules object (__webpack_modules__)</span></span><br><span class="line">  <span class="comment">/******/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/******/</span> <span class="comment">/******/</span> __webpack_require__.m =</span><br><span class="line">    __webpack_modules__; <span class="comment">/* webpack/runtime/compat get default export */</span></span><br><span class="line">  <span class="comment">/******/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>编译时，Webpack 会根据业务代码决定输出那些支撑特性的运行时代码(基于 <code>Dependency</code> 子类)，例如：</p>
<ul>
<li>需要 <code>__webpack_require__.f</code>、<code>__webpack_require__.r</code> 等功能实现最起码的模块化支持</li>
<li>如果用到动态加载特性，则需要写入 <code>__webpack_require__.e</code> 函数</li>
<li>如果用到 <code>Module Federation</code> 特性，则需要写入 <code>__webpack_require__.o</code> 函数</li>
<li>等等</li>
</ul>
<p>虽然每段运行时代码可能都很小，但随着特性的增加，最终结果会越来越大，特别对于多 <code>entry</code> 应用，在每个入口都重复打包一份相似的运行时代码显得有点浪费，为此 webpack 5 专门提供了 <code>entry.runtime</code> 配置项用于声明如何打包运行时代码。用法上只需在 <code>entry</code> 项中增加字符串形式的 <code>runtime</code> 值，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: &#123; <span class="attr">import</span>: <span class="string">&quot;./src/index&quot;</span>, <span class="attr">runtime</span>: <span class="string">&quot;solid-runtime&quot;</span> &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Webpack 执行完 <code>entry</code>、异步模块分包后，开始遍历 <code>entry</code> 配置判断是否带有 <code>runtime</code> 属性，如果有则创建以 <code>runtime</code> 值为名的 <code>Chunk</code>，因此，上例配置将生成两个<code>chunk</code>：<code>chunk[index.js]</code> 、<code>chunk[solid-runtime]</code>，并据此最终产出两个文件：</p>
<ul>
<li>入口 index 对应的 <code>index.js</code> 文件</li>
<li>运行时配置对应的 <code>solid-runtime.js</code> 文件</li>
</ul>
<p>在多 <code>entry</code> 场景中，只要为每个 <code>entry</code> 都设定相同的 <code>runtime</code> 值，webpack 运行时代码最终就会集中写入到同一个 <code>chunk</code>，例如对于如下配置：</p>
<p>入口 <code>index</code>、<code>home</code> 共享相同的 <code>runtime</code> ，最终生成三个 <code>chunk</code>，分别为：</p>
<p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210726170017.jpg" alt="Runtime 分包"></p>
<p>同时生成三个文件：</p>
<ul>
<li>入口 index 对应的 <code>index.js</code></li>
<li>入口 index 对应的 <code>home.js</code></li>
<li>运行时代码对应的 <code>solid-runtime.js</code></li>
</ul>
<h3 id="分包规则的问题"><a href="#分包规则的问题" class="headerlink" title="分包规则的问题"></a>分包规则的问题</h3><p>至此，webpack 分包规则的基本逻辑就介绍完毕了，实现上，大部分功能代码都集中在：</p>
<ul>
<li>webpack/lib/compilation.js 文件的 seal 函数</li>
<li>webpack/lib/buildChunkGraph.js 的 buildChunkGraph 函数</li>
</ul>
<p>默认分包规则最大的问题是无法解决模块重复，如果多个 <code>chunk</code> 同时包含同一个 <code>module</code>，那么这个 <code>module</code> 会被不受限制地重复打包进这些 <code>chunk</code>。比如假设我们有两个入口 <code>main/index</code> 同时依赖了同一个模块：</p>
<p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210726170227.jpg" alt="main/index"></p>
<p>默认情况下，webpack 不会对此做额外处理，只是单纯地将 c 模块同时打包进 <code>main/index</code> 两个 <code>chunk</code>，最终形成：</p>
<p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210726170259.jpg" alt=" c 被重复打包"></p>
<p>可以看到 <code>chunk</code> 间互相孤立，模块 c 被重复打包，对最终产物可能造成不必要的性能损耗！</p>
<p>为了解决这个问题，webpack 3 引入 <code>CommonChunkPlugin</code> 插件试图将 <code>entry</code> 之间的公共依赖提取成单独的 <code>chunk</code>，但 <code>CommonChunkPlugin</code> 本质上是基于 <code>Chunk</code> 之间简单的父子关系链实现的，很难推断出提取出的第三个包应该作为 <code>entry</code> 的父 <code>chunk</code> 还是子 <code>chunk</code>，<code>CommonChunkPlugin</code> 统一处理为父 <code>chunk</code>，某些情况下反而对性能造成了不小的负面影响。</p>
<p>在 webpack 4 之后则引入了更负责的设计 —— <code>ChunkGroup</code> 专门实现关系链管理，配合 <code>SplitChunksPlugin</code> 能够更高效、智能地实现 <strong>「启发式分包」</strong></p>
<h2 id="彻底理解-Webpack-运行时"><a href="#彻底理解-Webpack-运行时" class="headerlink" title="彻底理解 Webpack 运行时"></a>彻底理解 Webpack 运行时</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/373946949">彻底理解 Webpack 运行时</a></p>
<h3 id="编译产物分析"><a href="#编译产物分析" class="headerlink" title="编译产物分析"></a>编译产物分析</h3><p>为了正常、正确运行业务项目，Webpack 需要将开发者编写的业务代码以及支撑、调配这些业务代码的「运行时」一并打包到产物(<code>bundle</code>)中，以建筑作类比的话，业务代码相当于砖瓦水泥，是看得见摸得着能直接感知的逻辑；运行时相当于掩埋在砖瓦之下的钢筋地基，通常不会关注但决定了整座建筑的功能、质量。</p>
<p>大多数 <code>Webpack</code> 特性都需要特定钢筋地基才能跑起来，比如说：</p>
<p>异步按需加载</p>
<ul>
<li><code>HMR</code></li>
<li><code>WASM</code></li>
<li><code>Module Federation</code></li>
</ul>
<h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="string">&quot;a module&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> name <span class="keyword">from</span> <span class="string">&quot;./a&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br></pre></td></tr></table></figure>

<p>使用如下配置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&quot;./src/index&quot;</span>,</span><br><span class="line">  mode: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">  devtool: <span class="literal">false</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">&quot;[name].js&quot;</span>,</span><br><span class="line">    path: path.join(__dirname, <span class="string">&quot;./dist&quot;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>直接看编译生成的结果</p>
<p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hqwuzhaoyi.github.io/v2-f74527dbd49eab6874a81f65ab5598f3_1440w.jpg" alt="编译生成的结果"></p>
<p>虽然看起来很非主流，但细心分析还是能拆解出代码脉络的，bundle 整体由一个 IIFE 包裹，里面的内容从上到下依次为：</p>
<ul>
<li><code>__webpack_modules__</code> 对象，包含了除入口外的所有模块，示例中即 a.js 模块</li>
<li><code>__webpack_module_cache__</code> 对象，用于存储被引用过的模块</li>
<li><code>__webpack_require__</code> 函数，实现模块引用(require) 逻辑</li>
<li><code>__webpack_require__.d</code> ，工具函数，实现将模块导出的内容附加的模块对象上</li>
<li><code>__webpack_require__.o</code> ，工具函数，判断对象属性用</li>
<li><code>__webpack_require__.r</code> ，工具函数，在 ESM 模式下声明 ESM 模块标识</li>
<li>最后的 <code>IIFE</code> ，对应 <code>entry</code> 模块即上述示例的 index.js ，用于启动整个应用</li>
</ul>
<p>这几个 <code>__webpack_</code> 开头奇奇怪怪的函数可以统称为 <code>Webpack</code> 运行时代码，作用如前面所说的是搭起整个业务项目的骨架，就上述简单示例所罗列出来的几个函数、对象而言，它们协作构建起一个简单的模块化体系从而实现 <code>ES Module</code> 规范所声明的模块化特性。</p>
<p>上述示例中最终的函数是 <code>__webpack_require__</code>，它实现了模块间引用功能，核心代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/******/</span> <span class="comment">// 如果模块被引用过</span></span><br><span class="line">  <span class="comment">/******/</span> <span class="keyword">var</span> cachedModule = __webpack_module_cache__[moduleId];</span><br><span class="line">  <span class="comment">/******/</span> <span class="keyword">if</span> (cachedModule !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="comment">/******/</span> <span class="keyword">return</span> cachedModule.exports;</span><br><span class="line">    <span class="comment">/******/</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/******/</span> <span class="comment">// Create a new module (and put it into the cache)</span></span><br><span class="line">  <span class="comment">/******/</span> <span class="keyword">var</span> <span class="built_in">module</span> = (__webpack_module_cache__[moduleId] = &#123;</span><br><span class="line">    <span class="comment">/******/</span> <span class="comment">// no module.id needed</span></span><br><span class="line">    <span class="comment">/******/</span> <span class="comment">// no module.loaded needed</span></span><br><span class="line">    <span class="comment">/******/</span> <span class="built_in">exports</span>: &#123;&#125;,</span><br><span class="line">    <span class="comment">/******/</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">/******/</span></span><br><span class="line">  <span class="comment">/******/</span> <span class="comment">// Execute the module function</span></span><br><span class="line">  <span class="comment">/******/</span> __webpack_modules__[moduleId](</span><br><span class="line">    <span class="built_in">module</span>,</span><br><span class="line">    <span class="built_in">module</span>.exports,</span><br><span class="line">    __webpack_require__</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">/******/</span></span><br><span class="line">  <span class="comment">/******/</span> <span class="comment">// Return the exports of the module</span></span><br><span class="line">  <span class="comment">/******/</span> <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">  <span class="comment">/******/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码可以推测出，它的功能：</p>
<p>根据 <code>moduleId</code> 参数找到对应的模块代码，执行并返回结果<br>如果 <code>moduleId</code> 对应的模块被引用过，则直接返回存储在 <code>__webpack_module_cache__</code> 缓存对象中的导出内容，避免重复执行</p>
<p>其中，业务模块代码被存储在 bundle 最开始的 <code>__webpack_modules__</code> 变量中，内容如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> __webpack_modules__ = &#123;</span><br><span class="line">  <span class="string">&quot;./src/a.js&quot;</span>: (</span><br><span class="line">    __unused_webpack_module,</span><br><span class="line">    __webpack_exports__,</span><br><span class="line">    __webpack_require__</span><br><span class="line">  ) =&gt; &#123;</span><br><span class="line">    <span class="comment">// ...​</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结合 <code>__webpack_require__</code> 函数与 <code>__webpack_modules__</code> 变量就可以正确地引用到代码模块，例如上例生成代码最后面的<code>IIFE</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/*!**********************!*\</span></span><br><span class="line"><span class="comment">  !*** ./src/index.js ***!</span></span><br><span class="line"><span class="comment">  \**********************/</span></span><br><span class="line">  <span class="comment">/* harmony import */</span> <span class="keyword">var</span> _a__WEBPACK_IMPORTED_MODULE_0__ =</span><br><span class="line">    __webpack_require__(<span class="comment">/*! ./a */</span> <span class="string">&quot;./src/a.js&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(_a__WEBPACK_IMPORTED_MODULE_0__.name);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>这几个函数、对象构成了 Webpack 运行时最基本的能力 —— 模块化，它们的生成规则与原理我们放到文章第二节《实现原理》再讲，下面我们继续看看异步模块加载、模块热更新场景下对应的运行时内容。</p>
<p>异步模块加载<br>我们来看个简单的异步模块加载示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./src/a.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="string">&quot;module-a&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ./src/index.js</span></span><br><span class="line"><span class="keyword">import</span>(<span class="string">&quot;./a&quot;</span>).then(<span class="built_in">console</span>.log);</span><br></pre></td></tr></table></figure>

<p>使用异步模块加载特性时，会额外增加如下运行时：</p>
<p><code>__webpack_require__.e</code> ：逻辑上包裹了一层中间件模式与 <code>promise.all</code> ，用于异步加载多个模块<br><code>__webpack_require__.f</code> ：供 <code>__webpack_require__.e</code> 使用的中间件对象，例如使用 <code>Module Federation</code> 特性时就需要在这里注册中间件以修改 <code>e</code> 函数的执行逻辑<br><code>__webpack_require__.u</code> ：用于拼接异步模块名称的函数<br><code>__webpack_require__.l</code> ：基于 <code>JSONP</code> 实现的异步模块加载函数<br><code>__webpack_require__.p</code> ：当前文件的完整 <code>URL</code>，可用于计算异步模块的实际 <code>URL</code></p>
<p>建议读者运行示例对比实际生成代码，感受它们的具体功能。这几个运行时模块构建起 Webpack 异步加载能力，其中最核心的是 <code>__webpack_require__.e</code> 函数，它的代码很简单：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">__webpack_require__.f = &#123;&#125;;</span><br><span class="line"><span class="comment">/******/</span> <span class="comment">// This file contains only the entry chunk.</span></span><br><span class="line"><span class="comment">/******/</span> <span class="comment">// The chunk loading function for additional chunks</span></span><br><span class="line"><span class="comment">/******/</span> __webpack_require__.e = <span class="function">(<span class="params">chunkId</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/******/</span> <span class="keyword">return</span> <span class="built_in">Promise</span>.all(</span><br><span class="line">    <span class="built_in">Object</span>.keys(__webpack_require__.f).reduce(<span class="function">(<span class="params">promises, key</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">/******/</span> __webpack_require__.f[key](chunkId, promises);</span><br><span class="line">      <span class="comment">/******/</span> <span class="keyword">return</span> promises;</span><br><span class="line">      <span class="comment">/******/</span></span><br><span class="line">    &#125;, [])</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">/******/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从代码看，只是实现了一套基于 <code>__webpack_require__.f</code> 的中间件模式，以及用 <code>Promise.all</code> 实现并行处理，实际加载工作由 <code>__webpack_require__.f.j</code> 与 <code>__webpack_require__.l</code>实现，分开来看两个函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******/</span>  __webpack_require__.f.j = <span class="function">(<span class="params">chunkId, promises</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">/******/</span>        <span class="comment">// JSONP chunk loading for javascript</span></span><br><span class="line"><span class="comment">/******/</span>        <span class="keyword">var</span> installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : <span class="literal">undefined</span>;</span><br><span class="line"><span class="comment">/******/</span>        <span class="keyword">if</span>(installedChunkData !== <span class="number">0</span>) &#123; <span class="comment">// 0 means &quot;already installed&quot;.</span></span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span>          <span class="comment">// a Promise means &quot;currently loading&quot;.</span></span><br><span class="line"><span class="comment">/******/</span>          <span class="keyword">if</span>(installedChunkData) &#123;</span><br><span class="line"><span class="comment">/******/</span>            promises.push(installedChunkData[<span class="number">2</span>]);</span><br><span class="line"><span class="comment">/******/</span>          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/******/</span>            <span class="keyword">if</span>(<span class="literal">true</span>) &#123; <span class="comment">// all chunks have JS</span></span><br><span class="line"><span class="comment">/******/</span>              <span class="comment">// ...</span></span><br><span class="line"><span class="comment">/******/</span>              <span class="comment">// start chunk loading</span></span><br><span class="line"><span class="comment">/******/</span>              <span class="keyword">var</span> url = __webpack_require__.p + __webpack_require__.u(chunkId);</span><br><span class="line"><span class="comment">/******/</span>              <span class="comment">// create error before stack unwound to get useful stacktrace later</span></span><br><span class="line"><span class="comment">/******/</span>              <span class="keyword">var</span> error = <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line"><span class="comment">/******/</span>              <span class="keyword">var</span> loadingEnded = ...;</span><br><span class="line"><span class="comment">/******/</span>              __webpack_require__.l(url, loadingEnded, <span class="string">&quot;chunk-&quot;</span> + chunkId, chunkId);</span><br><span class="line"><span class="comment">/******/</span>            &#125; <span class="keyword">else</span> installedChunks[chunkId] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/******/</span>          &#125;</span><br><span class="line"><span class="comment">/******/</span>        &#125;</span><br><span class="line"><span class="comment">/******/</span>    &#125;;</span><br></pre></td></tr></table></figure>

<p><code>__webpack_require__.f.j</code> 实现了异步 <code>chunk</code> 路径的拼接、缓存、异常处理三个方面的逻辑，而 <code>__webpack_require__.l</code> 函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******/</span>    <span class="keyword">var</span> inProgress = &#123;&#125;;</span><br><span class="line"><span class="comment">/******/</span>    <span class="comment">// data-webpack is not used as build has no uniqueName</span></span><br><span class="line"><span class="comment">/******/</span>    <span class="comment">// loadScript function to load a script via script tag</span></span><br><span class="line"><span class="comment">/******/</span>    __webpack_require__.l = <span class="function">(<span class="params">url, done, key, chunkId</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">/******/</span>      <span class="keyword">if</span>(inProgress[url]) &#123; inProgress[url].push(done); <span class="keyword">return</span>; &#125;</span><br><span class="line"><span class="comment">/******/</span>      <span class="keyword">var</span> script, needAttach;</span><br><span class="line"><span class="comment">/******/</span>      <span class="keyword">if</span>(key !== <span class="literal">undefined</span>) &#123;</span><br><span class="line"><span class="comment">/******/</span>        <span class="keyword">var</span> scripts = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;script&quot;</span>);</span><br><span class="line"><span class="comment">/******/</span>        /​/ ...</span><br><span class="line"><span class="comment">/******/</span>      &#125;</span><br><span class="line"><span class="comment">/******/</span>      <span class="comment">//​ ...</span></span><br><span class="line"><span class="comment">/******/</span>      inProgress[url] = [done];</span><br><span class="line"><span class="comment">/******/</span>      <span class="keyword">var</span> onScriptComplete = <span class="function">(<span class="params">prev, event</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">/******/</span>        <span class="comment">//​ ...</span></span><br><span class="line"><span class="comment">/******/</span>      &#125;</span><br><span class="line"><span class="comment">/******/</span>      ;</span><br><span class="line"><span class="comment">/******/</span>      <span class="keyword">var</span> timeout = <span class="built_in">setTimeout</span>(onScriptComplete.bind(<span class="literal">null</span>, <span class="literal">undefined</span>, &#123; <span class="attr">type</span>: <span class="string">&#x27;timeout&#x27;</span>, <span class="attr">target</span>: script &#125;), <span class="number">120000</span>);</span><br><span class="line"><span class="comment">/******/</span>      script.onerror = onScriptComplete.bind(<span class="literal">null</span>, script.onerror);</span><br><span class="line"><span class="comment">/******/</span>      script.onload = onScriptComplete.bind(<span class="literal">null</span>, script.onload);</span><br><span class="line"><span class="comment">/******/</span>      needAttach &amp;&amp; <span class="built_in">document</span>.head.appendChild(script);</span><br><span class="line"><span class="comment">/******/</span>    &#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******/</span>    <span class="keyword">var</span> inProgress = &#123;&#125;;</span><br><span class="line"><span class="comment">/******/</span>    <span class="comment">// data-webpack is not used as build has no uniqueName</span></span><br><span class="line"><span class="comment">/******/</span>    <span class="comment">// loadScript function to load a script via script tag</span></span><br><span class="line"><span class="comment">/******/</span>    __webpack_require__.l = <span class="function">(<span class="params">url, done, key, chunkId</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">/******/</span>      <span class="keyword">if</span>(inProgress[url]) &#123; inProgress[url].push(done); <span class="keyword">return</span>; &#125;</span><br><span class="line"><span class="comment">/******/</span>      <span class="keyword">var</span> script, needAttach;</span><br><span class="line"><span class="comment">/******/</span>      <span class="keyword">if</span>(key !== <span class="literal">undefined</span>) &#123;</span><br><span class="line"><span class="comment">/******/</span>        <span class="keyword">var</span> scripts = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;script&quot;</span>);</span><br><span class="line"><span class="comment">/******/</span>        /​/ ...</span><br><span class="line"><span class="comment">/******/</span>      &#125;</span><br><span class="line"><span class="comment">/******/</span>      <span class="comment">//​ ...</span></span><br><span class="line"><span class="comment">/******/</span>      inProgress[url] = [done];</span><br><span class="line"><span class="comment">/******/</span>      <span class="keyword">var</span> onScriptComplete = <span class="function">(<span class="params">prev, event</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">/******/</span>        <span class="comment">//​ ...</span></span><br><span class="line"><span class="comment">/******/</span>      &#125;</span><br><span class="line"><span class="comment">/******/</span>      ;</span><br><span class="line"><span class="comment">/******/</span>      <span class="keyword">var</span> timeout = <span class="built_in">setTimeout</span>(onScriptComplete.bind(<span class="literal">null</span>, <span class="literal">undefined</span>, &#123; <span class="attr">type</span>: <span class="string">&#x27;timeout&#x27;</span>, <span class="attr">target</span>: script &#125;), <span class="number">120000</span>);</span><br><span class="line"><span class="comment">/******/</span>      script.onerror = onScriptComplete.bind(<span class="literal">null</span>, script.onerror);</span><br><span class="line"><span class="comment">/******/</span>      script.onload = onScriptComplete.bind(<span class="literal">null</span>, script.onload);</span><br><span class="line"><span class="comment">/******/</span>      needAttach &amp;&amp; <span class="built_in">document</span>.head.appendChild(script);</span><br><span class="line"><span class="comment">/******/</span>    &#125;;</span><br></pre></td></tr></table></figure>

<p><code>__webpack_require__.l</code>中通过 <code>script</code> 实现异步 <code>chunk</code> 内容的加载与执行。</p>
<p><code>e + l + f.j</code> 三个运行时函数支撑起 Webpack 异步模块运行的能力，落到实际用法上只需要调用 <code>e</code> 函数即可完成异步模块加载、运行，例如上例对应生成的 <code>entry</code> 内容：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!**********************!*\</span></span><br><span class="line"><span class="comment">  !*** ./src/index.js ***!</span></span><br><span class="line"><span class="comment">  \**********************/</span></span><br><span class="line">__webpack_require__</span><br><span class="line">  .e(<span class="comment">/*! import() */</span> <span class="string">&quot;src_a_js&quot;</span>)</span><br><span class="line">  .then(__webpack_require__.bind(__webpack_require__, <span class="comment">/*! ./a */</span> <span class="string">&quot;./src/a.js&quot;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="模块热更新"><a href="#模块热更新" class="headerlink" title="模块热更新"></a>模块热更新</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&quot;./src/index&quot;</span>,</span><br><span class="line">  mode: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">  devtool: <span class="literal">false</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">&quot;[name].js&quot;</span>,</span><br><span class="line">    path: path.join(__dirname, <span class="string">&quot;./dist&quot;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 简单起见，这里使用 HtmlWebpackPlugin 插件自动生成作为 host 的 html 文件</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      title: <span class="string">&quot;Hot Module Replacement&quot;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// 配置 devServer 属性，启动 HMR</span></span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">&quot;./dist&quot;</span>,</span><br><span class="line">    hot: <span class="literal">true</span>,</span><br><span class="line">    writeToDisk: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p>按照上述配置，使用命令 <code>webpack serve --hot-only</code> 启动 Webpack，就可以在 dist 文件夹找到产物：</p>
<p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hqwuzhaoyi.github.io/v2-e80ec089dc856473ed26a2855f68e291_1440w.jpg" alt="HMR产物"></p>
<ul>
<li>支持 HMR 所需要用到的 webpack-dev-server 、webpack/hot/xxx 、querystring 等框架，这一部分占了大部分代码</li>
<li><code>__webpack_require__.l</code> ：与异步模块加载一样，基于 JSONP 实现的异步模块加载函数</li>
<li><code>__webpack_require__.e</code> ：与异步模块加载一样</li>
<li><code>__webpack_require__.f</code> ：与异步模块加载一样</li>
<li><code>__webpack_require__.hmrF</code>： 用于拼接热更新模块 url 的函数</li>
<li><code>webpack/runtime/hot</code> ：这不是单个对象或函数，而是包含了一堆实现模块替换的方法</li>
</ul>
<p>可以看到， HMR 运行时是上面异步模块加载运行时的超集，而异步模块加载的运行时又是第一个基本示例运行时的超集，层层叠加。在 HMR 中包含了：</p>
<ul>
<li>模块化能力</li>
<li>异步模块加载能力 —— 实现变更模块的异步加载</li>
<li>热替换能力 —— 用拉取到的新模块替换掉旧的模块，并触发热更新事件</li>
</ul>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><ul>
<li>除了业务代码外，<code>bundle</code> 中还必须包含「运行时」代码才能正常运行</li>
<li>「运行时的具体内容由业务代码，确切地说由业务代码所使用到的特性决定」，例如使用到异步加载时需要打包 <code>__webpack_require__.e</code> 函数，那么这里面必然有一个运行时依赖收集的过程</li>
<li>开发者编写的业务代码会被包裹进恰当的运行时函数中，实现整体协调</li>
</ul>
<p>落到 Webpack 源码实现上，运行时的生成逻辑可以划分为两个步骤：</p>
<ol>
<li><strong>「依赖收集」</strong>：遍历业务代码模块收集模块的特性依赖，从而确定整个项目对 <code>Webpack runtime</code> 的依赖列表</li>
<li><strong>「生成」</strong>：合并 <code>runtime</code> 的依赖列表，打包到最终输出的 <code>bundle</code></li>
</ol>
<p>两个步骤都发生在打包阶段，即 Webpack(v5) 源码的 <code>compilation.seal</code> 函数中：</p>
<p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hqwuzhaoyi.github.io/v2-18896cb76bb6f4f886ebf10b1f5f5016_1440w.jpg" alt="compilation.seal"></p>
<p>进入 <code>runtime</code> 处理环节时 Webpack 已经解析得出 <code>ModuleDependencyGraph</code> 及 <code>ChunkGraph</code> 关系，也就意味着此时已经可以计算出：</p>
<ul>
<li>需要输出那些 <code>chunk</code></li>
<li>每个 <code>chunk</code> 包含那些 <code>module</code>，以及每个 <code>module</code> 的内容</li>
<li><code>chunk</code> 与 <code>chunk</code> 之间的父子依赖关系</li>
</ul>
<p><a href="#Webpack-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86">bundle</a>、<a href="#Dependency-Graph-%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90">module</a>、<a href="#Webpack-Chunk-%E5%88%86%E5%8C%85%E8%A7%84%E5%88%99%E8%AF%A6%E8%A7%A3">chunk</a></p>
<p>基于这些信息，接下来首先需要收集运行时依赖。</p>
<h3 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h3><p>Webpack runtime 的依赖概念上很像 Vue 的依赖，都是用来表达模块对其它模块存在依附关系，只是实现方法上 Vue 基于动态、在运行过程中收集，而 Webpack 则基于静态代码分析的方式收集依赖。实现逻辑大致为：</p>
<p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hqwuzhaoyi.github.io/v2-5e92ef4d53c2d6a8f1d77c050ce5deb2_1440w.jpg" alt="依赖收集"></p>
<p>运行时依赖的计算逻辑集中在 <code>compilation.processRuntimeRequirements</code> 函数，代码上包含三次循环：</p>
<p>第一次循环遍历所有 <code>module</code>，收集所有 <code>module</code> 的 <code>runtime</code> 依赖<br>第二次循环遍历所有 <code>chunk</code>，将 <code>chunk</code> 下所有 <code>module</code> 的 <code>runtime</code> 统一收录到 <code>chunk</code> 中<br>第三次循环遍历所有 <code>runtime chunk</code>，收集其对应的子 <code>chunk</code> 下所有 <code>runtime</code> 依赖，之后遍历所有依赖并发布 <code>runtimeRequirementInTree</code> 钩子，(主要是) <code>RuntimePlugin</code> 插件订阅该钩子并根据依赖类型创建对应的 <code>RuntimeModule</code> 子类实例</p>
<h4 id="第一次循环：收集模块依赖"><a href="#第一次循环：收集模块依赖" class="headerlink" title="第一次循环：收集模块依赖"></a>第一次循环：收集模块依赖</h4><p>在打包(seal)阶段，完成 <code>ChunkGraph</code> 的构建之后，Webpack 会紧接着调用 <code>codeGeneration</code> 函数遍历 <code>module</code> 数组，调用它们的 <code>module.codeGeneration</code> 函数执行模块转译，模块转译结果如：</p>
<p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hqwuzhaoyi.github.io/v2-cdea70759f6d5006a5ca858c1ce28a4a_1440w.jpg" alt="模块转译结果"></p>
<p>其中，<code>sources</code> 属性为模块经过转译后的结果；而 <code>runtimeRequirements</code> 则是基于 AST 计算出来的，为运行该模块时所需要用到的运行时，计算过程与本文主题无关，挖个坑下一回我们再继续讲。</p>
<p>所有模块转译完毕后，开始调用 <code>compilation.processRuntimeRequirements</code> 进入第一重循环，将上述转译结果的 <code>runtimeRequirements</code> 记录到 <code>ChunkGraph</code> 对象中。</p>
<h4 id="第二次循环：整合-chunk-依赖"><a href="#第二次循环：整合-chunk-依赖" class="headerlink" title="第二次循环：整合 chunk 依赖"></a>第二次循环：整合 chunk 依赖</h4><p>第一次循环针对 <code>module</code> 收集依赖，第二次循环则遍历 <code>chunk</code> 数组，收集将其对应所有 <code>module</code> 的 <code>runtime</code> 依赖，例如：</p>
<p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hqwuzhaoyi.github.io/v2-d64a076c37cce5ede403ab245f7728cf_1440w.jpg" alt="收集将其对应所有 module 的 runtime 依赖"></p>
<p>示例图中，<code>module a</code> 包含两个运行时依赖；<code>module b</code> 包含一个运行时依赖，则经过第二次循环整合后，对应的 <code>chunk</code> 会包含两个模块对应的三个运行时依赖。</p>
<h4 id="第三次循环：依赖标识转-RuntimeModule-对象"><a href="#第三次循环：依赖标识转-RuntimeModule-对象" class="headerlink" title="第三次循环：依赖标识转 RuntimeModule 对象"></a>第三次循环：依赖标识转 RuntimeModule 对象</h4><p>源码中，第三次循环的代码最少但逻辑最复杂，大致上执行三个操作：</p>
<ul>
<li>遍历所有 <code>runtime chunk</code>，收集其所有子 <code>chunk</code> 的 <code>runtime</code> 依赖</li>
<li>为该 <code>runtime chunk</code> 下的所有依赖发布 <code>runtimeRequirementInTree</code> 钩子</li>
<li><code>RuntimePlugin</code> 监听钩子，并根据 <code>runtime</code> 依赖的标识信息创建对应的 <code>RuntimeModule</code> 子类对象，并将对象加入到 <code>ModuleDependencyGraph</code> 和 <code>ChunkGraph</code> 体系中管理</li>
</ul>
<p>至此，<code>runtime</code> 依赖完成了从 <code>module</code> 内容解析，到收集，到创建依赖对应的 <code>Module</code> 子类，再将 <code>Module</code> 加入到 <code>ModuleDependencyGraph /ChunkGraph</code> 体系的全流程，业务代码及运行时代码对应的模块依赖关系图完全 ready，可以准备进入下一阶段 —— 生成最终产物。</p>
<p>但在继续讲解产物逻辑之前，我们有必要先解决两个问题：</p>
<ul>
<li>何谓 <code>runtime chunk</code>？与普通 <code>chunk</code> 是什么关系</li>
<li>何谓 <code>RuntimeModule</code>？与普通 <code>Module</code> 有什么区别</li>
</ul>
<p>回顾一下在三种特定的情况下，Webpack 会创建新的 chunk：</p>
<ul>
<li>每个 <code>entry</code> 项都会对应生成一个 <code>chunk</code> 对象，称之为 <code>initial chunk</code></li>
<li>每个异步模块都会对应生成一个 <code>chunk</code> 对象，称之为 <code>async chunk</code></li>
<li>Webpack 5 之后，如果 <code>entry</code> 配置中包含 runtime 值，则在 <code>entry</code> 之外再增加一个专门容纳 <code>runtime</code> 的 <code>chunk</code> 对象，此时可以称之为 <code>runtime chunk</code></li>
</ul>
<p>默认情况下 <code>initial chunk</code> 通常包含运行该 <code>entry</code> 所需要的所有 <code>runtime</code> 代码，但 webpack 5 之后出现的第三条规则打破了这一限制，允许开发者将 <code>runtime</code> 从 <code>initial chunk</code> 中剥离出来独立为一个多 entry 间可共享的 <code>runtime chunk</code>。</p>
<p>类似的，异步模块对应 <code>runtime</code> 代码大部分都被包含在对应的引用者身上，比如说：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="string">&quot;a-module&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="comment">// 异步引入 a 模块</span></span><br><span class="line"><span class="keyword">import</span>(<span class="string">&quot;./a&quot;</span>).then(<span class="built_in">console</span>.log);</span><br></pre></td></tr></table></figure>

<p>在这个示例中，index 异步引入 a 模块，那么按默认分配规则会产生两个 <code>chunk</code>：入口文件 index 对应的 <code>initial chunk</code>、异步模块 a 对应的 <code>async chunk</code>。此时从 <code>ChunkGraph</code> 的角度看 <code>chunk[index]</code>为 <code>chunk[a]</code> 的父级，运行时代码会被打入 <code>chunk[index]</code>，站在浏览器的角度，运行 <code>chunk[a]</code> 之前必须先运行 <code>chunk[index]</code> ，两者形成明显的父子关系。</p>
<p>在最开始阅读 Webpack 源码的时候，我就觉得很奇怪，<code>Module</code> 是 Webpack 资源管理的基本单位，但 <code>Module</code> 底下总共衍生出了 54 个子类，且大部分为 <code>Module =&gt; RuntimeModule =&gt; xxxRuntimeModule</code> 的继承关系：</p>
<p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hqwuzhaoyi.github.io/v2-9287287b08a48f29c6d4cd55178adaa2_1440w.jpg" alt="Module =&gt; RuntimeModule =&gt; xxxRuntimeModule"></p>
<p>在 <a href="https://link.zhihu.com/?target=https://mp.weixin.qq.com/s/kr73Epnn6wAx9DH7KRVUaA">有点难的 webpack 知识点：Dependency Graph 深度解析</a> 一文中我们聊到模块依赖关系图的生成过程及作用，但篇文章的内容是围绕业务代码展开的，用到的大多是 <code>NormalModule</code> 。到 <code>seal</code> 函数收集运行时的过程中，<code>RuntimePlugin</code> 还会为运行时依赖一一创建对应的 <code>RuntimeModule</code> 子类，例如：</p>
<ul>
<li>模块化实现中依赖 <code>__webpack_require__.r</code> ，则对应创建 <code>MakeNamespaceObjectRuntimeModule</code> 对象</li>
<li>ESM 依赖 <code>__webpack_require__.o</code> ，则对应创建 <code>HasOwnPropertyRuntimeModule</code> 对象</li>
<li>异步模块加载依赖 <code>__webpack_require__.e</code>，则对应创建 <code>EnsureChunkRuntimeModule</code> 对象</li>
<li>等等</li>
</ul>
<p>所以可以推导出所有 <code>RuntimeModule</code> 结尾的类型与特定的运行时功能一一对应，收集依赖的结果就是在业务代码之外创建出一堆支撑性质的 <code>RuntimeModule</code> 子类，这些子类对象随后被加入 <code>ModuleDependencyGraph</code> ，并入整个模块依赖体系中。</p>
<h3 id="资源合并生成"><a href="#资源合并生成" class="headerlink" title="资源合并生成"></a>资源合并生成</h3><p>经过上面的运行时依赖收集过程后，<code>bundles</code> 所需要的所有内容都就绪了，接着就可以准备写出到文件中，即下图核心流程中的生成(<code>emit</code>)阶段：</p>
<p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hqwuzhaoyi.github.io/v2-e80ec089dc856473ed26a2855f68e291_1440w.jpg" alt="核心流程中的生成(`emit`)阶段"></p>
<p><a href="#Webpack-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86">Webpack-核心原理</a>对这一块有比较细致的讲解，这里从运行时的视角再简单聊一下代码流程：</p>
<p>调用 <code>compilation.createChunkAssets</code> ，遍历 <code>chunks</code> 将 <code>chunk</code> 对应的所有 <code>module</code>，包括业务模块、运行时模块全部合并成一个资源(<code>Source</code> 子类)对象<br>调用 <code>compilation.emitAsset</code> 将资源对象挂载到 <code>compilation.assets</code> 属性中<br>调用 <code>compiler.emitAssets</code> 将 <code>assets</code> 全部写到 <code>FileSystem</code><br>发布 <code>compiler.hooks.done</code> 钩子<br>运行结束</p>
<h2 id="如何编写-loader"><a href="#如何编写-loader" class="headerlink" title="如何编写 loader"></a>如何编写 loader</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/375626250">如何编写 loader</a></p>
<h3 id="Loader-基础"><a href="#Loader-基础" class="headerlink" title="Loader 基础"></a>Loader 基础</h3><p>代码层面，Loader 通常是一个函数，结构如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">source, sourceMap?, data?</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// source 为 loader 的输入，可能是文件内容，也可能是上一个 loader 处理结果</span></span><br><span class="line">  <span class="keyword">return</span> source;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Loader 函数接收三个参数，分别为：</p>
<ul>
<li><code>source</code>：资源输入，对于第一个执行的 loader 为资源文件的内容；后续执行的 loader 则为前一个 loader 的执行结果</li>
<li><code>sourceMap</code>: 可选参数，代码的 sourcemap 结构</li>
<li><code>data</code>: 可选参数，其它需要在 Loader 链中传递的信息，比如 posthtml/posthtml-loader 就会通过这个参数传递参数的 AST 对象</li>
</ul>
<p>其中 source 是最重要的参数，大多数 Loader 要做的事情就是将 source 转译为另一种形式的 output</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">rawLoader</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> json = <span class="built_in">JSON</span>.stringify(source)</span><br><span class="line">    .replace(<span class="regexp">/\u2028/g</span>, <span class="string">&quot;\\u2028&quot;</span>)</span><br><span class="line">    .replace(<span class="regexp">/\u2029/g</span>, <span class="string">&quot;\\u2029&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> esModule =</span><br><span class="line">    <span class="keyword">typeof</span> options.esModule !== <span class="string">&quot;undefined&quot;</span> ? options.esModule : <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;esModule ? <span class="string">&quot;export default&quot;</span> : <span class="string">&quot;module.exports =&quot;</span>&#125;</span> <span class="subst">$&#123;json&#125;</span>;`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的作用是将文本内容包裹成 JavaScript 模块</p>
<h3 id="返回多个结果"><a href="#返回多个结果" class="headerlink" title="返回多个结果"></a>返回多个结果</h3><p>上例通过 return 语句返回处理结果，除此之外 Loader 还可以以 callback 方式返回更多信息，供下游 Loader 或者 Webpack 本身使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">loader</span>(<span class="params">content, map</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  linter.printOutput(linter.lint(content));</span><br><span class="line">  <span class="built_in">this</span>.callback(<span class="literal">null</span>, content, map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>this.callback(null, content, map)</code> 语句同时返回转译后的内容与 sourcemap 内容。callback 的完整签名如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.callback(</span><br><span class="line">    <span class="comment">// 异常信息，Loader 正常运行时传递 null 值即可</span></span><br><span class="line">    err: <span class="built_in">Error</span> | <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 转译结果</span></span><br><span class="line">    content: string | Buffer,</span><br><span class="line">    <span class="comment">// 源码的 sourcemap 信息</span></span><br><span class="line">    sourceMap?: SourceMap,</span><br><span class="line">    <span class="comment">// 任意需要在 Loader 间传递的值</span></span><br><span class="line">    <span class="comment">// 经常用来传递 ast 对象，避免重复解析</span></span><br><span class="line">    data?: any</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h3><p>涉及到异步或 CPU 密集操作时，Loader 中还可以以异步形式返回处理结果</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> less <span class="keyword">from</span> <span class="string">&quot;less&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">lessLoader</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 获取异步回调函数</span></span><br><span class="line">  <span class="keyword">const</span> callback = <span class="built_in">this</span>.async();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> result;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 2. 调用less 将模块内容转译为 css</span></span><br><span class="line">    result = <span class="keyword">await</span> (options.implementation || less).render(data, lessOptions);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; css, imports &#125; = result;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 转译结束，返回结果</span></span><br><span class="line">  callback(<span class="literal">null</span>, css, map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> lessLoader;</span><br></pre></td></tr></table></figure>

<p>在 less-loader 中，逻辑分三步：</p>
<ul>
<li>调用 <code>this.async</code> 获取异步回调函数，此时 Webpack 会将该 Loader 标记为异步加载器，会挂起当前执行队列直到 <code>callback</code> 被触发</li>
<li>调用 less 库将 less 资源转译为标准 css</li>
<li>调用异步回调 <code>callback</code> 返回处理结果</li>
</ul>
<p><code>this.async</code> 返回的异步回调函数签名与上一节介绍的 <code>this.callback</code> 相同，此处不再赘述。</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>Loader 为开发者提供了一种便捷的扩展方法，但在 Loader 中执行的各种资源内容转译操作通常都是 CPU 密集型 —— 这放在单线程的 Node 场景下可能导致性能问题；又或者异步 Loader 会挂起后续的加载器队列直到异步 Loader 触发回调，稍微不注意就可能导致整个加载器链条的执行时间过长。</p>
<p>为此，默认情况下 Webpack 会缓存 Loader 的执行结果直到资源或资源依赖发生变化，开发者需要对此有个基本的理解，必要时可以通过 this.cachable 显式声明不作缓存，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.cacheable(<span class="literal">false</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> output;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="上下文与-Side-Effect"><a href="#上下文与-Side-Effect" class="headerlink" title="上下文与 Side Effect"></a>上下文与 Side Effect</h3><p>除了作为内容转换器外，Loader 运行过程还可以通过一些上下文接口，有限制地影响 Webpack 编译过程，从而产生内容转换之外的副作用。</p>
<p>上下文信息可通过 this 获取，<code>this</code> 对象由 <code>NormolModule.createLoaderContext</code> 函数在调用 Loader 前创建，常用的接口包括：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loaderContext = &#123;</span><br><span class="line">  <span class="comment">// 获取当前 Loader 的配置信息</span></span><br><span class="line">  getOptions: <span class="function">(<span class="params">schema</span>) =&gt;</span> &#123;&#125;,</span><br><span class="line">  <span class="comment">// 添加警告</span></span><br><span class="line">  emitWarning: <span class="function">(<span class="params">warning</span>) =&gt;</span> &#123;&#125;,</span><br><span class="line">  <span class="comment">// 添加错误信息，注意这不会中断 Webpack 运行</span></span><br><span class="line">  emitError: <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;&#125;,</span><br><span class="line">  <span class="comment">// 解析资源文件的具体路径</span></span><br><span class="line">  <span class="function"><span class="title">resolve</span>(<span class="params">context, request, callback</span>)</span> &#123;&#125;,</span><br><span class="line">  <span class="comment">// 直接提交文件，提交的文件不会经过后续的chunk、module处理，直接输出到 fs</span></span><br><span class="line">  emitFile: <span class="function">(<span class="params">name, content, sourceMap, assetInfo</span>) =&gt;</span> &#123;&#125;,</span><br><span class="line">  <span class="comment">// 添加额外的依赖文件</span></span><br><span class="line">  <span class="comment">// watch 模式下，依赖文件发生变化时会触发资源重新编译</span></span><br><span class="line">  <span class="function"><span class="title">addDependency</span>(<span class="params">dep</span>)</span> &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中，<code>addDependency</code>、<code>emitFile</code> 、<code>emitError</code>、<code>emitWarning</code> 都会对后续编译流程产生副作用，例如 <code>less-loader</code> 中包含这样一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  result = <span class="keyword">await</span> (options.implementation || less).render(data, lessOptions);</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> &#123; css, imports &#125; = result;</span><br><span class="line">imports.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">this</span>.addDependency(path.normalize(item));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>解释一下，代码中首先调用 <code>less</code> 编译文件内容，之后遍历所有 <code>import</code> 语句，也就是上例 <code>result.imports</code> 数组，一一调用 <code>this.addDependency</code> 函数将 <code>import</code> 到的其它资源都注册为依赖，之后这些其它资源文件发生变化时都会触发重新编译。</p>
<h3 id="Loader-链式调用"><a href="#Loader-链式调用" class="headerlink" title="Loader 链式调用"></a>Loader 链式调用</h3><p>使用上，可以为某种资源文件配置多个 Loader，Loader 之间按照配置的顺序从前到后(pitch)，再从后到前依次执行，从而形成一套内容转译工作流，例如对于下面的配置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/i</span>,</span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;less-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这是一个典型的 less 处理场景，针对 <code>.less</code> 后缀的文件设定了：less、css、style 三个 loader 协作处理资源文件，按照定义的顺序，Webpack 解析 less 文件内容后先传入 less-loader；less-loader 返回的结果再传入 css-loader 处理；css-loader 的结果再传入 style-loader；最终以 style-loader 的处理结果为准，流程简化后如：</p>
<p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hqwuzhaoyi.github.io/v2-0bf3696db90bb7629ce498883ded693d_r.jpg" alt="三个 loader 协作处理资源文件"></p>
<p>上述示例中，三个 Loader 分别起如下作用：</p>
<ul>
<li><code>less-loader</code>：实现 <code>less =&gt; css</code> 的转换，输出 css 内容，无法被直接应用在 Webpack 体系下</li>
<li><code>css-loader</code>：将 css 内容包装成类似 <code>module.exports = &quot;$&#123;css&#125;&quot;</code> 的内容，包装后的内容符合 JavaScript 语法</li>
<li><code>style-loade</code>r： 做的事情非常简单，就是将 css 模块包进 require 语句，并在运行时调用 <code>injectStyle</code> 等函数将内容注入到页面的 <code>style</code> 标签</li>
</ul>
<p>三个 Loader 分别完成内容转化工作的一部分，形成从右到左的调用链条。链式调用这种设计有两个好处，一是保持单个 Loader 的单一职责，一定程度上降低代码的复杂度；二是细粒度的功能能够被组装成复杂而灵活的处理链条，提升单个 Loader 的可复用性。</p>
<p>不过，这只是链式调用的一部分，这里面有两个问题：</p>
<ul>
<li>oader 链条一旦启动之后，需要所有 Loader 都执行完毕才会结束，没有中断的机会 —— 除非显式抛出异常</li>
<li>某些场景下并不需要关心资源的具体内容，但 Loader 需要在 source 内容被读取出来之后才会执行</li>
</ul>
<p>为了解决这两个问题，Webpack 在 loader 基础上叠加了 <code>pitch</code> 的概念。</p>
<h3 id="Loader-Pitch"><a href="#Loader-Pitch" class="headerlink" title="Loader Pitch"></a>Loader Pitch</h3><p>Webpack 允许在这个函数上挂载名为 <code>pitch</code> 的函数，运行时 <code>pitch</code> 会比 <code>Loader</code> 本身更早执行，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loader = <span class="function"><span class="keyword">function</span> (<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;后执行&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> source;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">loader.pitch = <span class="function"><span class="keyword">function</span> (<span class="params">requestString</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;先执行&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = loader;</span><br></pre></td></tr></table></figure>

<p>Pitch 函数的完整签名：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pitch</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  remainingRequest: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  previousRequest: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  data = &#123;&#125;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>remainingRequest</code> : 当前 loader 之后的资源请求字符串</li>
<li><code>previousRequest</code> : 在执行当前 loader 之前经历过的 loader 列表</li>
<li><code>data</code> : 与 Loader 函数的 data 相同，用于传递需要在 Loader 传播的信息</li>
</ul>
<p>这些参数不复杂，但与 requestString 紧密相关，我们看个例子加深了解：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.less$/i</span>,</span><br><span class="line">  use: [</span><br><span class="line">    <span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;less-loader&quot;</span></span><br><span class="line">  ],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p><code>css-loader.pitch</code> 中拿到的参数依次为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// css-loader 之后的 loader 列表及资源路径</span></span><br><span class="line">remainingRequest = less-loader!./xxx.less</span><br><span class="line"><span class="comment">// css-loader 之前的 loader 列表</span></span><br><span class="line">previousRequest = style-loader</span><br><span class="line"><span class="comment">// 默认值</span></span><br><span class="line">data = &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="调度逻辑"><a href="#调度逻辑" class="headerlink" title="调度逻辑"></a>调度逻辑</h3><p><code>Pitch</code> 翻译成中文是抛、球场、力度、事物最高点等，我觉得 <code>pitch</code> 特性之所以被忽略完全是这个名字的锅，它背后折射的是一整套 <code>Loader</code> 被执行的生命周期概念。</p>
<p>实现上，<code>Loader</code> 链条执行过程分三个阶段：<code>pitch</code>、解析资源、执行，设计上与 <code>DOM</code> 的事件模型非常相似，<code>pitch</code> 对应到捕获阶段；执行对应到冒泡阶段；而两个阶段之间 Webpack 会执行资源内容的读取、解析操作，对应 <code>DOM</code> 事件模型的 <code>AT_TARGET</code> 阶段：</p>
<p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hqwuzhaoyi.github.io/v2-834d7775c9bac4eabc9b568f61617b64_r.jpg" alt="Loader 被执行的生命周期"></p>
<p><code>pitch</code> 阶段按配置顺序从左到右逐个执行 <code>loader.pitch</code> 函数(如果有的话)，开发者可以在 <code>pitch</code> 返回任意值中断后续的链路的执行：</p>
<p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hqwuzhaoyi.github.io/v2-74f05b7f818236d2a07c870a7af5436a_r.jpg" alt="中断 Loader 被执行的生命周期"></p>
<p>那么为什么要设计 pitch 这一特性呢？<strong>「阻断」</strong>！</p>
<h4 id="示例：style-loader"><a href="#示例：style-loader" class="headerlink" title="示例：style-loader"></a>示例：style-loader</h4><p>实际上， <code>style-loader</code> 只是负责让 <code>css</code> 能够在浏览器环境下跑起来，本质上并不需要关心具体内容，很适合用 <code>pitch</code> 来处理，核心代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// Loader 本身不作任何处理</span></span><br><span class="line"><span class="keyword">const</span> loaderApi = <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pitch 中根据参数拼接模块代码</span></span><br><span class="line">loaderApi.pitch = <span class="function"><span class="keyword">function</span> <span class="title">loader</span>(<span class="params">remainingRequest</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (injectType) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;linkTag&quot;</span>: &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">        esModule</span></span></span><br><span class="line"><span class="string"><span class="subst">          ? <span class="string">`...`</span></span></span></span><br><span class="line"><span class="string"><span class="subst">          : <span class="regexp">//</span> 引入 runtime 模块</span></span></span><br><span class="line"><span class="string"><span class="subst">            <span class="string">`var api = require(<span class="subst">$&#123;loaderUtils.stringifyRequest(</span></span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string"><span class="subst">              <span class="built_in">this</span>,</span></span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string"><span class="subst">              <span class="string">`!<span class="subst">$&#123;path.join(__dirname, <span class="string">&quot;runtime/injectStylesIntoLinkTag.js&quot;</span>)&#125;</span>`</span></span></span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string"><span class="subst">            )&#125;</span>);</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">            // 引入 css 模块</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">            var content = require(<span class="subst">$&#123;loaderUtils.stringifyRequest(</span></span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string"><span class="subst">              <span class="built_in">this</span>,</span></span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string"><span class="subst">              <span class="string">`!!<span class="subst">$&#123;remainingRequest&#125;</span>`</span></span></span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string"><span class="subst">            )&#125;</span>);</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string"></span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">            content = content.__esModule ? content.default : content;`</span></span></span></span><br><span class="line"><span class="string"><span class="subst">      &#125;</span> // ...`</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;lazyStyleTag&quot;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;lazySingletonStyleTag&quot;</span>: &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;styleTag&quot;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;singletonStyleTag&quot;</span>:</span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> loaderApi;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>loaderApi</code> 为空函数，不做任何处理</li>
<li><code>loaderApi.pitch</code> 中拼接结果，导出的代码包含：<ul>
<li>引入运行时模块 <code>runtime/injectStylesIntoLinkTag.js</code></li>
</ul>
</li>
<li>复用 <code>remainingRequest</code> 参数，重新引入 css 文件</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 运行结果大致如</span></span><br><span class="line"><span class="keyword">var</span> api = <span class="built_in">require</span>(<span class="string">&quot;xxx/style-loader/lib/runtime/injectStylesIntoLinkTag.js&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> content = <span class="built_in">require</span>(<span class="string">&quot;!!css-loader!less-loader!./xxx.less&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>注意了，到这里 <code>style-loader</code> 的 <code>pitch</code> 函数返回这一段内容，后续的 <code>Loader</code> 就不会继续执行，当前调用链条中断了：</p>
<p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hqwuzhaoyi.github.io/v2-8eb7bcca57abde019b260464345abd34_r.jpg" alt="`style-loader`当前调用链条中断"></p>
<p>之后，Webpack 继续解析、构建 <code>style-loader</code> 返回的结果，遇到 <code>inline loader</code> 语句：</p>
<p><code>var content = require(&#39;!!css-loader!less-loader!./xxx.less&#39;);</code></p>
<p>所以从 Webpack 的角度看，实际上对同一个文件调用了两次 <code>loader</code> 链，第一次在 <code>style-loader</code> 的 <code>pitch</code> 中断，第二次根据 <code>inline loader</code> 的内容跳过了 <code>style-loader</code>。</p>
<h2 id="产物转译打包逻辑"><a href="#产物转译打包逻辑" class="headerlink" title="产物转译打包逻辑"></a>产物转译打包逻辑</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/384602429">Webpack 原理系列八：产物转译打包逻辑</a></p>
<p><a href="#Dependency-Graph-%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90">Dependency-Graph-深度解析</a><br>经过 <strong>「构建(<code>make</code>)阶段」</strong> 后，Webpack 解析出：</p>
<ul>
<li><code>module</code> 内容</li>
<li><code>module</code> 与 <code>module</code> 之间的依赖关系图</li>
</ul>
<p>而进入 <strong>「生成(「「<code>seal</code>」」)阶段」</strong> 后，Webpack 首先根据模块的依赖关系、模块特性、<code>entry</code>配置等计算出 <code>Chunk Graph</code>，确定最终产物的数量和内容</p>
<p>本文继续聊聊 <code>Chunk Graph</code> 后面之后，模块开始转译到模块合并打包的过程，大体流程如下：</p>
<p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hqwuzhaoyi.github.io/v2-5e9c0844ec1d40b9664e0745bbb07c7a_r.jpg" alt="模块开始转译到模块合并打包的过程"></p>
<p>为了方便理解，我将打包过程横向切分为三个阶段：</p>
<ul>
<li><strong>「入口」</strong>：指代从 Webpack 启动到调用 <code>compilation.codeGeneration</code> 之前的所有前置操作</li>
<li><strong>「模块转译」</strong>：遍历 <code>modules</code> 数组，完成所有模块的转译操作，并将结果存储到 <code>compilation.codeGenerationResults</code> 对象</li>
<li><strong>「模块合并打包」</strong>：在特定上下文框架下，组合业务模块、<code>runtime</code> 模块，合并打包成 <code>bundle</code> ，并调用 <code>compilation.emitAsset</code> 输出产物</li>
</ul>
<p>这里说的 <strong>「业务模块」</strong> 是指开发者所编写的项目代码；<strong>「<code>runtime</code> 模块」</strong> 是指 Webpack 分析业务模块后，动态注入的用于支撑各项特性的运行时代码. <a href="#%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3-Webpack-%E8%BF%90%E8%A1%8C%E6%97%B6">彻底理解-Webpack-运行时</a></p>
<h3 id="模块转译原理"><a href="#模块转译原理" class="headerlink" title="模块转译原理"></a>模块转译原理</h3><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hqwuzhaoyi.github.io/v2-05007e54fce5e2e5e17706edbd3cb0d6_r.jpg" alt="Webpack 产物"></p>
<p>上述示例由 <code>index.js</code> / <code>name.js</code> 两个业务文件组成，对应的 Webpack 配置如上图左下角所示；Webpack 构建产物如右边 <code>main.js</code> 文件所示，包含三块内容，从上到下分别为：</p>
<ul>
<li><code>name.js</code> 模块对应的转译产物，函数形态</li>
<li>Webpack 按需注入的运行时代码</li>
<li><code>index.js</code> 模块对应的转译产物，IIFE(立即执行函数) 形态</li>
</ul>
<p>以看到产物与源码语义、功能均相同，但表现形式发生了较大变化，例如 index.js 编译前后的内容：</p>
<p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hqwuzhaoyi.github.io/v2-b45326712da78769b9dd45317507f118_r.jpg" alt="运行时代码的作用与生成逻辑"></p>
<p>上图右边是 Webpack 编译产物中对应的代码，相对于左边的源码有如下变化：</p>
<ul>
<li>整个模块被包裹进 IIFE (立即执行函数)中</li>
<li>添加 <code>__webpack_require__.r(__webpack_exports__);</code> 语句，用于适配 ESM 规范</li>
<li>源码中的 <code>import</code> 语句被转译为 <code>__webpack_require__</code> 函数调用</li>
<li>源码 <code>console</code> 语句所使用的 <code>name</code> 变量被转译为 <code>_name__WEBPACK_IMPORTED_MODULE_0__.default</code></li>
<li>添加注释</li>
</ul>
<h4 id="核心流程"><a href="#核心流程" class="headerlink" title="核心流程"></a>核心流程</h4><p><strong>「模块转译」</strong> 操作从 <code>module.codeGeneration</code> 调用开始，对应到上述流程图的：</p>
<p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hqwuzhaoyi.github.io/v2-9694aa2a7519c7480188f0688c550a4f_r.jpg" alt="「模块转译」"></p>
<ul>
<li>调用 <code>JavascriptGenerator</code> 的对象的 <code>generate</code> 方法，方法内部：<ol>
<li>遍历模块的 <code>dependencies</code> 与 <code>presentationalDependencies</code> 数组</li>
<li>执行每个数组项 <code>dependency</code> 对象的对应的 <code>Template.apply</code> 方法，在 <code>apply</code> 内修改模块代码，或更新 <code>initFragments</code> 数组</li>
</ol>
</li>
<li>遍历完毕后，调用 <code>InitFragment.addToSource</code> 静态方法，将上一步操作产生的 <code>source</code> 对象与 <code>initFragments</code> 数组合并为模块产物</li>
</ul>
<p>简单说就是<strong>遍历依赖</strong>，在<strong>依赖对象</strong>中修改 <code>module</code> 代码，最后再将所有变更<strong>合并为最终产物</strong>。这里面关键点：</p>
<ol>
<li>在 <code>Template.apply</code> 函数中，如何更新模块代码</li>
<li>在 <code>InitFragment.addToSource</code> 静态方法中，如何将 <code>Template.apply</code> 所产生的 <code>side effect</code> 合并为最终产物</li>
</ol>
<h4 id="Template-apply-函数"><a href="#Template-apply-函数" class="headerlink" title="Template.apply 函数"></a>Template.apply 函数</h4><p>上述流程中，<code>JavascriptGenerator</code> 类是毋庸置疑的 C 位角色，但它并不直接修改 <code>module</code> 的内容，而是绕了几层后委托交由 <code>Template</code> 类型实现。</p>
<p>Webpack 5 源码中，<code>JavascriptGenerator.generate</code> 函数会遍历模块的 <code>dependencies</code> 数组，调用依赖对象对应的 <code>Template</code> 子类 <code>apply</code> 方法更新模块内容，说起来有点绕，原始代码更饶，所以我将重要步骤抽取为如下伪代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JavascriptGenerator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">generate</span>(<span class="params"><span class="built_in">module</span>, generateContext</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 先取出 module 的原始代码内容</span></span><br><span class="line">        <span class="keyword">const</span> source = <span class="keyword">new</span> ReplaceSource(<span class="built_in">module</span>.originalSource());</span><br><span class="line">        <span class="keyword">const</span> &#123; dependencies, presentationalDependencies &#125; = <span class="built_in">module</span>;</span><br><span class="line">        <span class="keyword">const</span> initFragments = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> dependency <span class="keyword">of</span> [...dependencies, ...presentationalDependencies]) &#123;</span><br><span class="line">            <span class="comment">// 找到 dependency 对应的 template</span></span><br><span class="line">            <span class="keyword">const</span> template = generateContext.dependencyTemplates.get(dependency.constructor);</span><br><span class="line">            <span class="comment">// 调用 template.apply，传入 source、initFragments</span></span><br><span class="line">            <span class="comment">// 在 apply 函数可以直接修改 source 内容，或者更改 initFragments 数组，影响后续转译逻辑</span></span><br><span class="line">            template.apply(dependency, source, &#123;initFragments&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历完毕后，调用 InitFragment.addToSource 合并 source 与 initFragments</span></span><br><span class="line">        <span class="keyword">return</span> InitFragment.addToSource(source, initFragments, generateContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dependency 子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">xxxDependency</span> <span class="keyword">extends</span> <span class="title">Dependency</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dependency 子类对应的 Template 定义</span></span><br><span class="line"><span class="keyword">const</span> xxxDependency.Template = <span class="class"><span class="keyword">class</span> <span class="title">xxxDependencyTemplate</span> <span class="keyword">extends</span> <span class="title">Template</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">apply</span>(<span class="params">dep, source, &#123;initFragments&#125;</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 直接操作 source，更改模块代码</span></span><br><span class="line">        source.replace(dep.range[<span class="number">0</span>], dep.range[<span class="number">1</span>] - <span class="number">1</span>, <span class="string">&#x27;some thing&#x27;</span>)</span><br><span class="line">        <span class="comment">// 2. 通过添加 InitFragment 实例，补充代码</span></span><br><span class="line">        initFragments.push(<span class="keyword">new</span> xxxInitFragment())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上述伪代码可以看出，<code>JavascriptGenerator.generate</code> 函数的逻辑相对比较固化：</p>
<ol>
<li>初始化一系列变量</li>
<li>遍历 <code>module</code> 对象的依赖数组，找到每个 <code>dependency</code> 对应的 <code>template</code> 对象，调用 <code>template.apply</code> 函数修改模块内容</li>
<li>调用 <code>InitFragment.addToSource</code> 方法，合并 <code>source</code> 与 <code>initFragments</code> 数组，生成最终结果</li>
</ol>
<p>这里的重点是 <code>JavascriptGenerator.generate</code> 函数并不操作 <code>module</code> 源码，它仅仅提供一个执行框架，真正处理模块内容转译的逻辑都在 <code>xxxDependencyTemplate</code> 对象的 <code>apply</code> 函数实现，如上例伪代码中 <strong><em>24-28</em></strong> 行。</p>
<p>每个 <code>Dependency</code> 子类都会映射到一个唯一的 <code>Template</code> 子类，且通常这两个类都会写在同一个文件中，例如 <code>ConstDependency</code> 与 <code>ConstDependencyTemplate``；NullDependency</code> 与 <code>NullDependencyTemplate</code>。Webpack 构建(<code>make</code>)阶段，会通过 <code>Dependency</code> 子类记录不同情况下模块之间的依赖关系；到生成(<code>seal</code>)阶段再通过 <code>Template</code> 子类修改 <code>module</code> 代码。</p>
<p>综上 <code>Module</code>、<code>JavascriptGenerator</code>、<code>Dependency</code>、<code>Template</code> 四个类形成如下交互关系：</p>
<p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hqwuzhaoyi.github.io/v2-42ade2e92de558e40ab78811e966661e_r.jpg" alt="四个类形成如下交互关系"></p>
<p><code>Template</code> 对象可以通过两种方法更新 <code>module</code> 的代码：</p>
<p>直接操作 <code>source</code> 对象，直接修改模块代码，该对象最初的内容等于模块的源码，经过多个 <code>Template.apply</code> 函数流转后逐渐被替换成新的代码形式<br>操作 <code>initFragments</code> 数组，在模块源码之外插入补充代码片段<br>这两种操作所产生的 <code>side effect</code>，最终都会被传入 <code>InitFragment.addToSource</code> 函数，合成最终结果，下面简单补充一些细节。</p>
<h5 id="使用-Source-更改代码"><a href="#使用-Source-更改代码" class="headerlink" title="使用 Source 更改代码"></a>使用 Source 更改代码</h5><p><code>Source</code> 是 Webpack 中编辑字符串的一套工具体系，提供了一系列字符串操作方法，包括：</p>
<ul>
<li>字符串合并、替换、插入等</li>
<li>模块代码缓存、sourcemap 映射、hash 计算等</li>
</ul>
<p>Webpack 内部以及社区的很多插件、loader 都会使用 <code>Source</code> 库编辑代码内容，包括上文介绍的 <code>Template.apply</code> 体系中，逻辑上，在启动模块代码生成流程时，Webpack 会先用模块原本的内容初始化 <code>Source</code> 对象，即：</p>
<p><code>const source = new ReplaceSource(module.originalSource());</code></p>
<p>之后，不同 <code>Dependency</code> 子类按序、按需更改 <code>source</code> 内容，例如 <code>ConstDependencyTemplate</code> 中的核心代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ConstDependency.Template = <span class="class"><span class="keyword">class</span> <span class="title">ConstDependencyTemplate</span> <span class="keyword">extends</span> (</span></span><br><span class="line"><span class="class">  <span class="title">NullDependency</span>.<span class="title">Template</span></span></span><br><span class="line"><span class="class">) </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">apply</span>(<span class="params">dependency, source, templateContext</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> dep.range === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">      source.insert(dep.range, dep.expression);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    source.replace(dep.range[<span class="number">0</span>], dep.range[<span class="number">1</span>] - <span class="number">1</span>, dep.expression);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述 <code>ConstDependencyTemplate</code> 中，<code>apply</code> 函数根据参数条件调用 <code>source.insert</code> 插入一段代码，或者调用 <code>source.replace</code> 替换一段代码。</p>
<h5 id="使用-InitFragment-更新代码"><a href="#使用-InitFragment-更新代码" class="headerlink" title="使用 InitFragment 更新代码"></a>使用 InitFragment 更新代码</h5><p>除直接操作 <code>source</code> 外，<code>Template.apply</code> 中还可以通过操作 <code>initFragments</code> 数组达成修改模块产物的效果。<code>initFragments</code> 数组项通常为 <code>InitFragment</code> 子类实例，它们通常带有两个函数： <code>getContent</code>、<code>getEndContent</code>，分别用于获取代码片段的头尾部分。</p>
<p>例如 <code>HarmonyImportDependencyTemplate</code> 的 <code>apply</code> 函数中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">HarmonyImportDependency.Template = <span class="class"><span class="keyword">class</span> <span class="title">HarmonyImportDependencyTemplate</span> <span class="keyword">extends</span> (</span></span><br><span class="line"><span class="class">  <span class="title">ModuleDependency</span>.<span class="title">Template</span></span></span><br><span class="line"><span class="class">) </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">apply</span>(<span class="params">dependency, source, templateContext</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    templateContext.initFragments.push(</span><br><span class="line">      <span class="keyword">new</span> ConditionalInitFragment(</span><br><span class="line">        importStatement[<span class="number">0</span>] + importStatement[<span class="number">1</span>],</span><br><span class="line">        InitFragment.STAGE_HARMONY_IMPORTS,</span><br><span class="line">        dep.sourceOrder,</span><br><span class="line">        key,</span><br><span class="line">        runtimeCondition</span><br><span class="line">      )</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="代码合并"><a href="#代码合并" class="headerlink" title="代码合并"></a>代码合并</h4><p>上述 <code>Template.apply</code> 处理完毕后，产生转译后的 <code>source</code> 对象与代码片段 <code>initFragments</code> 数组，接着就需要调用 <code>InitFragment.addToSource</code> 函数将两者合并为模块产物。</p>
<p><code>addToSource</code> 的核心代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InitFragment</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">addToSource</span>(<span class="params">source, initFragments, generateContext</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 先排好顺序</span></span><br><span class="line">    <span class="keyword">const</span> sortedFragments = initFragments</span><br><span class="line">      .map(extractFragmentIndex)</span><br><span class="line">      .sort(sortFragmentWithIndex);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> concatSource = <span class="keyword">new</span> ConcatSource();</span><br><span class="line">    <span class="keyword">const</span> endContents = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> fragment <span class="keyword">of</span> sortedFragments) &#123;</span><br><span class="line">      <span class="comment">// 合并 fragment.getContent 取出的片段内容</span></span><br><span class="line">      concatSource.add(fragment.getContent(generateContext));</span><br><span class="line">      <span class="keyword">const</span> endContent = fragment.getEndContent(generateContext);</span><br><span class="line">      <span class="keyword">if</span> (endContent) &#123;</span><br><span class="line">        endContents.push(endContent);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并 source</span></span><br><span class="line">    concatSource.add(source);</span><br><span class="line">    <span class="comment">// 合并 fragment.getEndContent 取出的片段内容</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> content <span class="keyword">of</span> endContents.reverse()) &#123;</span><br><span class="line">      concatSource.add(content);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> concatSource;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>addToSource</code> 函数的逻辑：</p>
<ol>
<li>遍历 <code>initFragments</code> 数组，按顺序合并 <code>fragment.getContent()</code> 的产物</li>
<li>合并 <code>source</code> 对象</li>
<li>遍历 <code>initFragments</code> 数组，按顺序合并 <code>fragment.getEndContent()</code> 的产物</li>
</ol>
<p>所以，模块代码合并操作主要就是用 <code>initFragments</code> 数组一层一层包裹住模块代码 <code>source</code>，而两者都在 <code>Template.apply</code> 层面维护。</p>
<h4 id="自定义-banner-插件"><a href="#自定义-banner-插件" class="headerlink" title="自定义 banner 插件"></a>自定义 banner 插件</h4><p>经过 <code>Template.apply</code> 转译与 <code>InitFragment.addToSource</code> 合并之后，模块就完成了从用户代码形态到产物形态的转变，为加深对上述 <strong>「模块转译」</strong> 流程的理解，接下来我们尝试开发一个 <code>Banner</code> 插件，实现在每个模块前自动插入一段字符串。</p>
<p>实现上，插件主要涉及 <code>Dependency</code>、<code>Template</code>、<code>hooks</code> 对象，代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Dependency, Template &#125; = <span class="built_in">require</span>(<span class="string">&quot;webpack&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoDependency</span> <span class="keyword">extends</span> <span class="title">Dependency</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DemoDependency.Template = <span class="class"><span class="keyword">class</span> <span class="title">DemoDependencyTemplate</span> <span class="keyword">extends</span> <span class="title">Template</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">apply</span>(<span class="params">dependency, source</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> today = <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleDateString();</span><br><span class="line">    source.insert(</span><br><span class="line">      <span class="number">0</span>,</span><br><span class="line">      <span class="string">`/* Author: Tecvan */</span></span><br><span class="line"><span class="string">/* Date: <span class="subst">$&#123;today&#125;</span> */</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="title">DemoPlugin</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">apply</span>(<span class="params">compiler</span>)</span> &#123;</span><br><span class="line">    compiler.hooks.thisCompilation.tap(<span class="string">&quot;DemoPlugin&quot;</span>, <span class="function">(<span class="params">compilation</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 调用 dependencyTemplates ，注册 Dependency 到 Template 的映射</span></span><br><span class="line">      compilation.dependencyTemplates.set(</span><br><span class="line">        DemoDependency,</span><br><span class="line">        <span class="keyword">new</span> DemoDependency.Template()</span><br><span class="line">      );</span><br><span class="line">      compilation.hooks.succeedModule.tap(<span class="string">&quot;DemoPlugin&quot;</span>, <span class="function">(<span class="params"><span class="built_in">module</span></span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 模块构建完毕后，插入 DemoDependency 对象</span></span><br><span class="line">        <span class="built_in">module</span>.addDependency(<span class="keyword">new</span> DemoDependency());</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>关键步骤：</p>
<ul>
<li>编写 <code>DemoDependency</code> 与 <code>DemoDependencyTemplate</code> 类，其中 <code>DemoDependency</code> 仅做示例用，没有实际功能；<code>DemoDependencyTemplate</code>则在其 <code>apply</code> 中调用 <code>source.insert</code> 插入字符串，如示例代码第 <strong><em>10-14</em></strong> 行</li>
<li>使用 <code>compilation.dependencyTemplates</code> 注册 <code>DemoDependency</code> 与 <code>DemoDependencyTemplate</code> 的映射关系</li>
<li>使用 <code>thisCompilation</code> 钩子取得 <code>compilation</code> 对象</li>
<li>使用 <code>succeedModule</code> 钩子订阅 <code>module</code> 构建完毕事件，并调用 <code>module.addDependency</code> 方法添加 <code>DemoDependency</code> 依赖</li>
</ul>
<p><code>module</code> 对象的产物在生成过程就会调用到 <code>DemoDependencyTemplate.apply</code> 函数，插入我们定义好的字符串，效果如：</p>
<p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hqwuzhaoyi.github.io/v2-56c541047a194e96607a7abc5f3112d2_r.jpg" alt="插入我们定义好的字符串"></p>
<ul>
<li><code>lib/dependencies/ConstDependency.js</code>，一个简单示例，可学习 <code>source</code> 的更多操作方法</li>
<li><code>lib/dependencies/HarmonyExportSpecifierDependencyTemplate.js</code>，一个简单示例，可学习 <code>initFragments</code> 数组的更多用法<br>l- <code>ib/dependencies/HarmonyImportDependencyTemplate.js</code>，一个较复杂但使用率极高的示例，可综合学习 <code>source``、initFragments</code> 数组的用法</li>
</ul>
<h3 id="模块合并打包原理"><a href="#模块合并打包原理" class="headerlink" title="模块合并打包原理"></a>模块合并打包原理</h3><p>讲完单个模块的转译过程后，我们先回到这个流程图：</p>
<p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hqwuzhaoyi.github.io/v2-c4550e909eb6646a78fba5a64636641a_r.jpg" alt="模块合并打包"></p>
<p>流程图中，<code>compilation.codeGeneration</code> 函数执行完毕 —— 也就是模块转译阶段完成后，模块的转译结果会一一保存到 <code>compilation.codeGenerationResults</code> 对象中，之后会启动一个新的执行流程 —— <strong>「模块合并打包」</strong>。</p>
<p><strong>「模块合并打包」</strong> 过程会将 <code>chunk</code> 对应的 <code>module</code> 及 <code>runtimeModule</code> 按规则塞进 「<strong>模板框架」</strong> 中，最终合并输出成完整的 <code>bundle</code> 文件，例如上例中：</p>
<p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hqwuzhaoyi.github.io/v2-05007e54fce5e2e5e17706edbd3cb0d6_r.jpg" alt="最终合并输出成完整的 `bundle`"></p>
<p>示例右边 <code>bundle</code> 文件中，红框框出来的部分为用户代码文件及运行时模块生成的产物，其余部分撑起了一个 IIFE 形式的运行框架即为 <strong>「模板框架」</strong>，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// webpackBootstrap</span></span><br><span class="line"><span class="meta">  &quot;use strict&quot;</span>;</span><br><span class="line">  <span class="keyword">var</span> __webpack_modules__ = &#123;</span><br><span class="line">    <span class="string">&quot;module-a&quot;</span>: (</span><br><span class="line">      __unused_webpack_module,</span><br><span class="line">      __webpack_exports__,</span><br><span class="line">      __webpack_require__</span><br><span class="line">    ) =&gt; &#123;</span><br><span class="line">      <span class="comment">// ! module 代码，</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;module-b&quot;</span>: (</span><br><span class="line">      __unused_webpack_module,</span><br><span class="line">      __webpack_exports__,</span><br><span class="line">      __webpack_require__</span><br><span class="line">    ) =&gt; &#123;</span><br><span class="line">      <span class="comment">// ! module 代码，</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// The module cache</span></span><br><span class="line">  <span class="keyword">var</span> __webpack_module_cache__ = &#123;&#125;;</span><br><span class="line">  <span class="comment">// The require function</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ! webpack CMD 实现</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/************************************************************************/</span></span><br><span class="line">  <span class="comment">// ! 各种 runtime</span></span><br><span class="line">  <span class="comment">/************************************************************************/</span></span><br><span class="line">  <span class="keyword">var</span> __webpack_exports__ = &#123;&#125;;</span><br><span class="line">  <span class="comment">// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.</span></span><br><span class="line">  (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ! entry 模块</span></span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<ul>
<li>最外层由一个 IIFE 包裹</li>
<li>一个记录了除 <code>entry</code> 外的其它模块代码的 <code>__webpack_modules__</code> 对象，对象的 key 为模块标志符；值为模块转译后的代码</li>
<li>一个极度简化的 CMD 实现： <code>__webpack_require__</code> 函数</li>
<li>最后，一个包裹了 <code>entry</code> 代码的 IIFE 函数</li>
</ul>
<p><strong>「模块转译」</strong> 是将 <code>module</code> 转译为可以在宿主环境如浏览器上运行的代码形式；而 <strong>「模块合并」</strong> 操作则串联这些 <code>modules</code> ，使之整体符合开发预期，能够正常运行整个应用逻辑。接下来，我们揭晓这部分代码的生成原理。</p>
<h3 id="核心流程-1"><a href="#核心流程-1" class="headerlink" title="核心流程"></a>核心流程</h3><p>在 <code>compilation.codeGeneration</code> 执行完毕，即所有用户代码模块与运行时模块都执行完转译操作后，<code>seal</code> 函数调用 <code>compilation.createChunkAssets</code> 函数，触发 <code>renderManifest</code> <code>钩子，JavascriptModulesPlugin</code> 插件监听到这个钩子消息后开始组装 <code>bundle</code>，伪代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Webpack 5</span></span><br><span class="line"><span class="comment">// lib/Compilation.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compilation</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">seal</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 先把所有模块的代码都转译，准备好</span></span><br><span class="line">    <span class="built_in">this</span>.codeGenerationResults = <span class="built_in">this</span>.codeGeneration(<span class="built_in">this</span>.modules);</span><br><span class="line">    <span class="comment">// 1. 调用 createChunkAssets</span></span><br><span class="line">    <span class="built_in">this</span>.createChunkAssets();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">createChunkAssets</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历 chunks ，为每个 chunk 执行 render 操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> chunk <span class="keyword">of</span> <span class="built_in">this</span>.chunks) &#123;</span><br><span class="line">      <span class="comment">// 2. 触发 renderManifest 钩子</span></span><br><span class="line">      <span class="keyword">const</span> res = <span class="built_in">this</span>.hooks.renderManifest.call([], &#123;</span><br><span class="line">        chunk,</span><br><span class="line">        codeGenerationResults: <span class="built_in">this</span>.codeGenerationResults,</span><br><span class="line">        ...others,</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">// 提交组装结果</span></span><br><span class="line">      <span class="built_in">this</span>.emitAsset(res.render(), ...others);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lib/javascript/JavascriptModulesPlugin.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JavascriptModulesPlugin</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">apply</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    compiler.hooks.compilation.tap(<span class="string">&quot;JavascriptModulesPlugin&quot;</span>, <span class="function">(<span class="params">compilation</span>) =&gt;</span> &#123;</span><br><span class="line">      compilation.hooks.renderManifest.tap(<span class="string">&quot;JavascriptModulesPlugin&quot;</span>, <span class="function">(<span class="params">result, options</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// JavascriptModulesPlugin 插件中通过 renderManifest 钩子返回组装函数 render</span></span><br><span class="line">          <span class="keyword">const</span> render = <span class="function">() =&gt;</span></span><br><span class="line">            <span class="comment">// render 内部根据 chunk 内容，选择使用模板 `renderMain` 或 `renderChunk`</span></span><br><span class="line">            <span class="comment">// 3. 监听钩子，返回打包函数</span></span><br><span class="line">            <span class="built_in">this</span>.renderMain(options);</span><br><span class="line"></span><br><span class="line">          result.push(&#123; render <span class="comment">/* arguments */</span> &#125;);</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">renderMain</span>(<span class="params"></span>)</span> &#123;<span class="comment">/*  */</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">renderChunk</span>(<span class="params"></span>)</span> &#123;<span class="comment">/*  */</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的核心逻辑是，<code>compilation</code> 以 <code>renderManifest</code> 钩子方式对外发布 <code>bundle</code> 打包需求； <code>JavascriptModulesPlugin</code> 监听这个钩子，按照 <code>chunk</code> 的内容特性，调用不同的打包函数。</p>
<p><strong>上述仅针对 Webpack 5。在 Webpack 4 中，打包逻辑集中在 MainTemplate 完成。</strong></p>
<p>两个打包函数实现的逻辑接近，都是按顺序拼接各个模块，下面简单介绍下 <code>renderMain</code> 的实现。</p>
<h3 id="renderMain-函数"><a href="#renderMain-函数" class="headerlink" title="renderMain 函数"></a>renderMain 函数</h3><p><code>renderMain</code> 函数涉及比较多场景判断，原始代码很长很绕，我摘了几个重点步骤</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JavascriptModulesPlugin</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">renderMain</span>(<span class="params">renderContext, hooks, compilation</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; chunk, chunkGraph, runtimeTemplate &#125; = renderContext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> source = <span class="keyword">new</span> ConcatSource();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 1. 先计算出 bundle CMD 核心代码，包含：</span></span><br><span class="line">    <span class="comment">//      - &quot;var __webpack_module_cache__ = &#123;&#125;;&quot; 语句</span></span><br><span class="line">    <span class="comment">//      - &quot;__webpack_require__&quot; 函数</span></span><br><span class="line">    <span class="keyword">const</span> bootstrap = <span class="built_in">this</span>.renderBootstrap(renderContext, hooks);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 计算出当前 chunk 下，除 entry 外其它模块的代码</span></span><br><span class="line">    <span class="keyword">const</span> chunkModules = Template.renderChunkModules(</span><br><span class="line">      renderContext,</span><br><span class="line">      inlinedModules</span><br><span class="line">        ? allModules.filter(<span class="function">(<span class="params">m</span>) =&gt;</span> !inlinedModules.has(m))</span><br><span class="line">        : allModules,</span><br><span class="line">      (<span class="built_in">module</span>) =&gt;</span><br><span class="line">        <span class="built_in">this</span>.renderModule(</span><br><span class="line">          <span class="built_in">module</span>,</span><br><span class="line">          renderContext,</span><br><span class="line">          hooks,</span><br><span class="line">          allStrict ? <span class="string">&quot;strict&quot;</span> : <span class="literal">true</span></span><br><span class="line">        ),</span><br><span class="line">      prefix</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 计算出运行时模块代码</span></span><br><span class="line">    <span class="keyword">const</span> runtimeModules =</span><br><span class="line">      renderContext.chunkGraph.getChunkRuntimeModulesInOrder(chunk);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 重点来了，开始拼接 bundle</span></span><br><span class="line">    <span class="comment">// 4.1 首先，合并核心 CMD 实现，即上述 bootstrap 代码</span></span><br><span class="line">    <span class="keyword">const</span> beforeStartup = Template.asString(bootstrap.beforeStartup) + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    source.add(</span><br><span class="line">      <span class="keyword">new</span> PrefixSource(</span><br><span class="line">        prefix,</span><br><span class="line">        useSourceMap</span><br><span class="line">          ? <span class="keyword">new</span> OriginalSource(beforeStartup, <span class="string">&quot;webpack/before-startup&quot;</span>)</span><br><span class="line">          : <span class="keyword">new</span> RawSource(beforeStartup)</span><br><span class="line">      )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.2 合并 runtime 模块代码</span></span><br><span class="line">    <span class="keyword">if</span> (runtimeModules.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">module</span> <span class="keyword">of</span> runtimeModules) &#123;</span><br><span class="line">        compilation.codeGeneratedModules.add(<span class="built_in">module</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.3 合并除 entry 外其它模块代码</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> m <span class="keyword">of</span> chunkModules) &#123;</span><br><span class="line">      <span class="keyword">const</span> renderedModule = <span class="built_in">this</span>.renderModule(m, renderContext, hooks, <span class="literal">false</span>);</span><br><span class="line">      source.add(renderedModule)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.4 合并 entry 模块代码</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      hasEntryModules &amp;&amp;</span><br><span class="line">      runtimeRequirements.has(RuntimeGlobals.returnExportsFromRuntime)</span><br><span class="line">    ) &#123;</span><br><span class="line">      source.add(<span class="string">`<span class="subst">$&#123;prefix&#125;</span>return __webpack_exports__;\n`</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> source;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>先计算出 <code>bundle CMD</code> 代码，即 <code>__webpack_require__</code> 函数</li>
<li>计算出当前 <code>chunk</code> 下，除 <code>entry</code> 外其它模块代码 <code>chunkModules</code></li>
<li>计算出运行时模块代码</li>
<li>开始执行合并操作，子步骤有：<ol>
<li>合并 <code>CMD</code> 代码</li>
<li>合并 <code>runtime</code> 模块代码</li>
<li>遍历 <code>chunkModules</code> 变量，合并除 <code>entry</code> 外其它模块代码</li>
<li>合并 <code>entry</code> 模块代码</li>
</ol>
</li>
<li>返回结果</li>
</ol>
<p>总结：先计算出不同组成部分的产物形态，之后按顺序拼接打包，输出合并后的版本。</p>
<p>至此，Webpack 完成 <code>bundle</code> 的转译、打包流程，后续调用 <code>compilation.emitAsset</code> ，按上下文环境将产物输出到 <code>fs</code> 即可，Webpack 单次编译打包过程就结束了。</p>
<p>详细讨论了打包流程后半截 —— 从 <code>chunk graph</code> 生成一直到最终输出产物的实现逻辑，重点：</p>
<ul>
<li>首先遍历 <code>chunk</code> 中的所有模块，为每个模块执行转译操作，产出模块级别的产物</li>
<li>根据 <code>chunk</code> 的类型，选择不同结构框架，按序逐次组装模块产物，打包成最终 <code>bundle</code></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:hqwuzhaoyi@foxmail.com">Wu Zhaoyi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://hqwuzhaoyi.github.io/2021/07/20/webpack/webpack%E7%AC%94%E8%AE%B0/">https://hqwuzhaoyi.github.io/2021/07/20/webpack/webpack%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://hqwuzhaoyi.github.io" target="_blank">Prajna's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%BA%90%E7%A0%81/">源码</a><a class="post-meta__tags" href="/tags/webpack/">webpack</a></div><div class="post_share"><div class="social-share" data-image="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210720223312.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/08/01/%E5%87%BD%E6%95%B0%E5%BC%8F/%E5%87%BD%E6%95%B0%E5%BC%8F%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B01/"><img class="prev-cover" src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210801121046.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">函数式入门笔记1</div></div></a></div><div class="next-post pull-right"><a href="/2021/06/01/react%20%E6%BA%90%E7%A0%81/11.%E7%AE%80%E5%8D%95react/"><img class="next-cover" src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hexo/20210602220241.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">react 源码-迷你 react</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Webpack-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">Webpack 核心原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E4%BD%93%E6%A1%86%E6%9E%B6"><span class="toc-number">1.1.</span> <span class="toc-text">主体框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90"><span class="toc-number">1.2.</span> <span class="toc-text">核心流程解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5"><span class="toc-number">1.3.</span> <span class="toc-text">初始化阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E9%98%B6%E6%AE%B5"><span class="toc-number">1.4.</span> <span class="toc-text">构建阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E9%98%B6%E6%AE%B5"><span class="toc-number">1.5.</span> <span class="toc-text">生成阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E5%BD%A2%E6%80%81%E6%B5%81%E8%BD%AC"><span class="toc-number">1.6.</span> <span class="toc-text">资源形态流转</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Webpack-%E6%8F%92%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%B7%B1%E5%BA%A6%E8%AE%B2%E8%A7%A3"><span class="toc-number">2.</span> <span class="toc-text">Webpack 插件架构深度讲解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Tapable-%E5%85%A8%E8%A7%A3%E6%9E%90"><span class="toc-number">2.1.</span> <span class="toc-text">Tapable 全解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">基本用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tapable-%E9%92%A9%E5%AD%90%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.3.</span> <span class="toc-text">Tapable 钩子类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dependency-Graph-%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90"><span class="toc-number">3.</span> <span class="toc-text">Dependency Graph 深度解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Dependency-Graph"><span class="toc-number">3.1.</span> <span class="toc-text">Dependency Graph</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.2.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E8%A7%A3%E6%9E%90"><span class="toc-number">3.3.</span> <span class="toc-text">实例解析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#module-issuer"><span class="toc-number">4.</span> <span class="toc-text">module.issuer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%EF%BC%9A-Stats-%E7%B1%BB"><span class="toc-number">4.1.</span> <span class="toc-text">实例： Stats 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%95%E6%97%B6%E4%BF%AE%E6%94%B9-issuer"><span class="toc-number">4.2.</span> <span class="toc-text">何时修改 issuer</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Webpack-Chunk-%E5%88%86%E5%8C%85%E8%A7%84%E5%88%99%E8%AF%A6%E8%A7%A3"><span class="toc-number">5.</span> <span class="toc-text">Webpack Chunk 分包规则详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%88%86%E5%8C%85%E8%A7%84%E5%88%99"><span class="toc-number">5.1.</span> <span class="toc-text">默认分包规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Entry-%E5%88%86%E5%8C%85%E5%A4%84%E7%90%86"><span class="toc-number">5.2.</span> <span class="toc-text">Entry 分包处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%9D%97%E5%88%86%E5%8C%85%E5%A4%84%E7%90%86"><span class="toc-number">5.3.</span> <span class="toc-text">异步模块分包处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Runtime-%E5%88%86%E5%8C%85"><span class="toc-number">5.4.</span> <span class="toc-text">Runtime 分包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%8C%85%E8%A7%84%E5%88%99%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">5.5.</span> <span class="toc-text">分包规则的问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3-Webpack-%E8%BF%90%E8%A1%8C%E6%97%B6"><span class="toc-number">6.</span> <span class="toc-text">彻底理解 Webpack 运行时</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E4%BA%A7%E7%89%A9%E5%88%86%E6%9E%90"><span class="toc-number">6.1.</span> <span class="toc-text">编译产物分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">6.1.1.</span> <span class="toc-text">基本结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E7%83%AD%E6%9B%B4%E6%96%B0"><span class="toc-number">6.2.</span> <span class="toc-text">模块热更新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">6.3.</span> <span class="toc-text">实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86"><span class="toc-number">6.4.</span> <span class="toc-text">依赖收集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%BE%AA%E7%8E%AF%EF%BC%9A%E6%94%B6%E9%9B%86%E6%A8%A1%E5%9D%97%E4%BE%9D%E8%B5%96"><span class="toc-number">6.4.1.</span> <span class="toc-text">第一次循环：收集模块依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%BE%AA%E7%8E%AF%EF%BC%9A%E6%95%B4%E5%90%88-chunk-%E4%BE%9D%E8%B5%96"><span class="toc-number">6.4.2.</span> <span class="toc-text">第二次循环：整合 chunk 依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%BE%AA%E7%8E%AF%EF%BC%9A%E4%BE%9D%E8%B5%96%E6%A0%87%E8%AF%86%E8%BD%AC-RuntimeModule-%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.4.3.</span> <span class="toc-text">第三次循环：依赖标识转 RuntimeModule 对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E5%90%88%E5%B9%B6%E7%94%9F%E6%88%90"><span class="toc-number">6.5.</span> <span class="toc-text">资源合并生成</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99-loader"><span class="toc-number">7.</span> <span class="toc-text">如何编写 loader</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Loader-%E5%9F%BA%E7%A1%80"><span class="toc-number">7.1.</span> <span class="toc-text">Loader 基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%A4%9A%E4%B8%AA%E7%BB%93%E6%9E%9C"><span class="toc-number">7.2.</span> <span class="toc-text">返回多个结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86"><span class="toc-number">7.3.</span> <span class="toc-text">异步处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98"><span class="toc-number">7.4.</span> <span class="toc-text">缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E-Side-Effect"><span class="toc-number">7.5.</span> <span class="toc-text">上下文与 Side Effect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Loader-%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8"><span class="toc-number">7.6.</span> <span class="toc-text">Loader 链式调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Loader-Pitch"><span class="toc-number">7.7.</span> <span class="toc-text">Loader Pitch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E9%80%BB%E8%BE%91"><span class="toc-number">7.8.</span> <span class="toc-text">调度逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9Astyle-loader"><span class="toc-number">7.8.1.</span> <span class="toc-text">示例：style-loader</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A7%E7%89%A9%E8%BD%AC%E8%AF%91%E6%89%93%E5%8C%85%E9%80%BB%E8%BE%91"><span class="toc-number">8.</span> <span class="toc-text">产物转译打包逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E8%BD%AC%E8%AF%91%E5%8E%9F%E7%90%86"><span class="toc-number">8.1.</span> <span class="toc-text">模块转译原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B"><span class="toc-number">8.1.1.</span> <span class="toc-text">核心流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Template-apply-%E5%87%BD%E6%95%B0"><span class="toc-number">8.1.2.</span> <span class="toc-text">Template.apply 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Source-%E6%9B%B4%E6%94%B9%E4%BB%A3%E7%A0%81"><span class="toc-number">8.1.2.1.</span> <span class="toc-text">使用 Source 更改代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-InitFragment-%E6%9B%B4%E6%96%B0%E4%BB%A3%E7%A0%81"><span class="toc-number">8.1.2.2.</span> <span class="toc-text">使用 InitFragment 更新代码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%90%88%E5%B9%B6"><span class="toc-number">8.1.3.</span> <span class="toc-text">代码合并</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-banner-%E6%8F%92%E4%BB%B6"><span class="toc-number">8.1.4.</span> <span class="toc-text">自定义 banner 插件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%90%88%E5%B9%B6%E6%89%93%E5%8C%85%E5%8E%9F%E7%90%86"><span class="toc-number">8.2.</span> <span class="toc-text">模块合并打包原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B-1"><span class="toc-number">8.3.</span> <span class="toc-text">核心流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#renderMain-%E5%87%BD%E6%95%B0"><span class="toc-number">8.4.</span> <span class="toc-text">renderMain 函数</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2022 By Wu Zhaoyi</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/algolia.js"></script><div class="js-pjax"><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'https://hqwuzhaoyi.github.io/2021/07/20/webpack/webpack%E7%AC%94%E8%AE%B0/'
    this.page.identifier = '2021/07/20/webpack/webpack笔记/'
    this.page.title = 'webpack 笔记'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://wuzhaoyi.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Disqus' === 'Disqus' || !false) {
  if (false) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>