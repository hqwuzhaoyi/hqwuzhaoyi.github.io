<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Prajna&#39;s blog</title>
  <icon>https://www.gravatar.com/avatar/1f8acaabc4170015ca16fd4d0d8d4603</icon>
  <subtitle>personal notes</subtitle>
  <link href="https://hqwuzhaoyi.github.io/atom.xml" rel="self"/>
  
  <link href="https://hqwuzhaoyi.github.io/"/>
  <updated>2022-08-29T03:13:16.656Z</updated>
  <id>https://hqwuzhaoyi.github.io/</id>
  
  <author>
    <name>Wu Zhaoyi</name>
    <email>hqwuzhaoyi@foxmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>rust 生命周期</title>
    <link href="https://hqwuzhaoyi.github.io/2022/02/08/rust/3.%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://hqwuzhaoyi.github.io/2022/02/08/rust/3.%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2022-02-08T00:00:00.000Z</published>
    <updated>2022-08-29T03:13:16.656Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hqwuzhaoyi.github.io/202202101008431.webp" alt="生命周期"></p><ul><li>分配在堆和栈上的内存有其各自的作用域，它们的生命周期是动态的。</li><li>全局变量、静态变量、字符串字面量、代码等内容，在编译时，会被编译到可执行文件中的 BSS/Data/RoData/Text 段，然后在加载时，装入内存。因而，它们的生命周期和进程的生命周期一致，所以是静态的。</li><li>所以，函数指针的生命周期也是静态的，因为函数在 Text 段中，只要进程活着，其内存一直存在。</li></ul><p>生命周期标注的目的是，在参数和返回值之间建立联系或者约束。调用函数时，传入的参数的生命周期需要大于等于（outlive）标注的生命周期。</p><p>在 Rust 中，除非显式地做 <code>Box::leak() / Box::into_raw() / ManualDrop</code> 等动作，<strong>一般来说，堆内存的生命周期，会默认和其栈内存的生命周期绑定在一起。</strong></p><p>在这种默认情况下，在每个函数的作用域中，编译器就可以对比值和其引用的生命周期，来确保“引用的生命周期不超出值的生命周期”。</p><p>根据所有权规则，值的生命周期可以确认，它可以一直存活到所有者离开作用域；而引用的生命周期不能超过值的生命周期。在同一个作用域下，这是显而易见的。然而，<strong>当发生函数调用时，编译器需要通过函数的签名来确定，参数和返回值之间生命周期的约束。</strong></p><h2 id="值的生命周期"><a href="#值的生命周期" class="headerlink" title="值的生命周期"></a>值的生命周期</h2><p>如果一个值的生命周期贯穿整个进程的生命周期，那么我们就称这种生命周期为静态生命周期。</p><pre><code>当值拥有静态生命周期，其引用也具有静态生命周期。我们在表述这种引用的时候，可以用 &#39;static 来表示。比如： &amp;&#39;static str 代表这是一个具有静态生命周期的字符串引用。一般来说，全局变量、静态变量、字符串字面量（string literal）等，都拥有静态生命周期。我们上文中提到的堆内存，如果使用了 Box::leak 后，也具有静态生命周期。</code></pre><p>如果一个值是在某个作用域中定义的，也就是说它被创建在栈上或者堆上，那么其生命周期是动态的。</p><pre><code>当这个值的作用域结束时，值的生命周期也随之结束。对于动态生命周期，我们约定用 &#39;a 、&#39;b 或者 &#39;hello 这样的小写字符或者字符串来表述。</code></pre><h2 id="译器如何识别生命周期"><a href="#译器如何识别生命周期" class="headerlink" title="译器如何识别生命周期"></a>译器如何识别生命周期</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;Lindsey&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> s2 = <span class="built_in">String</span>::from(<span class="string">&quot;Rosie&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = max(&amp;s1, &amp;s2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;bigger one: &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">max</span></span>(s1: &amp;<span class="built_in">str</span>, s2: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s1 &gt; s2 &#123;</span><br><span class="line">        s1</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译器在编译 max() 函数时，无法判断 s1、s2 和返回值的生命周期。</strong></p><p>当出现了多个参数，它们的生命周期可能不一致时，返回值的生命周期就不好确定了。编译器在编译某个函数时，并不知道这个函数将来有谁调用、怎么调用，所以，<strong>函数本身携带的信息，就是编译器在编译时使用的全部信息。</strong></p><p>根据这一点，我们再看示例代码，在编译 max() 函数时，参数 s1 和 s2 的生命周期是什么关系、返回值和参数的生命周期又有什么关系，编译器是无法确定的。</p><p>此时，就需要我们在函数签名中提供生命周期的信息，也就是<strong>生命周期标注（lifetime specifier）</strong>。在生命周期标注时，使用的参数叫<strong>生命周期参数（lifetime parameter）</strong>。通过生命周期标注，我们告诉编译器这些引用间生命周期的约束。</p><p>生命周期参数的描述方式和泛型参数一致，不过只使用小写字母。这里，两个入参 s1、 s2，以及返回值都用 ‘a 来约束。<strong>生命周期参数，描述的是参数和参数之间、参数和返回值之间的关系，并不改变原有的生命周期。</strong></p><p>在我们添加了生命周期参数后，s1 和 s2 的生命周期只要大于等于（outlive） ‘a，就符合参数的约束，而返回值的生命周期同理，也需要大于等于 ‘a 。</p><h2 id="引用需要额外标注吗"><a href="#引用需要额外标注吗" class="headerlink" title="引用需要额外标注吗"></a>引用需要额外标注吗</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;first word of s1: &#123;&#125;&quot;</span>, first(&amp;s1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">first</span></span>(s: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> trimmed = s.trim();</span><br><span class="line">    <span class="keyword">match</span> trimmed.find(<span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="literal">Some</span>(pos) =&gt; &amp;trimmed[..pos],</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然我们没有做任何生命周期的标注，但编译器会通过一些简单的规则为函数自动添加标注：</p><ul><li>所有引用类型的参数都有独立的生命周期 ‘a 、’b 等。</li><li>如果只有一个引用型输入，它的生命周期会赋给所有输出。</li><li>如果有多个引用类型的参数，其中一个是 self，那么它的生命周期会赋给所有输出。</li></ul><p>例子中的 first() 函数通过规则 1 和 2，可以得到一个带生命周期的版本:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">first</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(s: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> trimmed = s.trim();</span><br><span class="line">    <span class="keyword">match</span> trimmed.find(<span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="literal">Some</span>(pos) =&gt; &amp;trimmed[..pos],</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以看到，所有引用都能正常标注，没有冲突。那么对比之前返回较大字符串的示例代码（示例代码）， max() 函数为什么编译器无法处理呢？</p><p>按照规则 1， 我们可以对 max() 函数的参数 s1 和 s2 分别标注’a 和’b ，但是返回值如何标注？是 ‘a 还是’b 呢？这里的冲突，编译器无能为力。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">max</span></span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt;(s1: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>, s2: &amp;<span class="symbol">&#x27;b</span> <span class="built_in">str</span>) -&gt; &amp;&#x27;??? <span class="built_in">str</span></span><br></pre></td></tr></table></figure><p>明白了代码逻辑，才能正确标注参数和返回值的约束关系，顺利编译通过。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hqwuzhaoyi.github.io/202202101008431.webp&quot; alt=&quot;生命周期&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分配在堆和栈上的内存</summary>
      
    
    
    
    <category term="rust" scheme="https://hqwuzhaoyi.github.io/categories/rust/"/>
    
    
  </entry>
  
  <entry>
    <title>rust 所有权</title>
    <link href="https://hqwuzhaoyi.github.io/2022/02/08/rust/2.%E6%89%80%E6%9C%89%E6%9D%83/"/>
    <id>https://hqwuzhaoyi.github.io/2022/02/08/rust/2.%E6%89%80%E6%9C%89%E6%9D%83/</id>
    <published>2022-02-08T00:00:00.000Z</published>
    <updated>2022-08-29T03:13:16.652Z</updated>
    
    <content type="html"><![CDATA[<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hqwuzhaoyi.github.io/605094c2dc6992997e31f687dc908751.webp" alt="第一性原理"></p><ul><li>所有权：一个值只能被一个变量所拥有，且同一时刻只能有一个所有者，当所有者离开作用域，其拥有的值被丢弃，内存得到释放。</li><li>Move 语义：赋值或者传参会导致值 Move，所有权被转移，一旦所有权转移，之前的变量就不能访问。</li><li>Copy 语义：如果值实现了 Copy trait，那么赋值或传参会使用 Copy 语义，相应的值会被按位拷贝（浅拷贝），产生新的值。</li></ul><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hqwuzhaoyi.github.io/202202091504799.jpg" alt="快速回顾"></p><p>规则：</p><ol><li>一个值在同一时刻只有一个所有者。当所有者离开作用域，其拥有的值会被丢弃。赋值或者传参会导致值 Move，所有权被转移，一旦所有权转移，之前的变量就不能访问。</li><li>如果值实现了 Copy trait，那么赋值或传参会使用 Copy 语义，相应的值会被按位拷贝，产生新的值。</li><li>一个值可以有多个只读引用。</li><li>一个值可以有唯一一个活跃的可变引用。可变引用（写）和只读引用（读）是互斥的关系，就像并发下数据的读写互斥那样。</li><li>引用的生命周期不能超出值的生命周期。</li></ol><h2 id="变量在函数调用时发生了什么"><a href="#变量在函数调用时发生了什么" class="headerlink" title="变量在函数调用时发生了什么"></a>变量在函数调用时发生了什么</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> data = <span class="built_in">vec!</span>[<span class="number">10</span>, <span class="number">42</span>, <span class="number">9</span>, <span class="number">8</span>];</span><br><span class="line">    <span class="keyword">let</span> v = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(pos) = find_pos(data, v) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Found &#123;&#125; at &#123;&#125;&quot;</span>, v, pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">find_pos</span></span>(data: <span class="built_in">Vec</span>&lt;<span class="built_in">u32</span>&gt;, v: <span class="built_in">u32</span>) -&gt; <span class="built_in">Option</span>&lt;<span class="built_in">usize</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (pos, item) <span class="keyword">in</span> data.iter().enumerate() &#123;</span><br><span class="line">        <span class="keyword">if</span> *item == v &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">Some</span>(pos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="literal">None</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>动态数组因为大小在编译期无法确定，所以放在堆上，并且在栈上有一个包含了长度和容量的胖指针指向堆上的内存。</strong></p><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hqwuzhaoyi.github.io/f0989fa8611db83b79500060e8cd682f.webp" alt="find_pos"></p><p>对于堆内存多次引用的问题，我们先来看大多数语言的方案：</p><ul><li>C/C++ 要求开发者手工处理</li><li>Java 等语言使用追踪式 GC</li><li>ObjC/Swift 使用自动引用计数（ARC）</li></ul><h2 id="Rust-的解决思路"><a href="#Rust-的解决思路" class="headerlink" title="Rust 的解决思路"></a>Rust 的解决思路</h2><ul><li>一个值只能被一个变量所拥有，这个变量被称为所有者（Each value in Rust has a variable that’s called its owner）。</li><li>一个值同一时刻只能有一个所有者（There can only be one owner at a time），也就是说不能有两个变量拥有相同的值。所以对应刚才说的变量赋值、参数传递、函数返回等行为，旧的所有者会把值的所有权转移给新的所有者，以便保证单一所有者的约束。</li><li>当所有者离开作用域，其拥有的值被丢弃（When the owner goes out of scope, the value will be dropped），内存得到释放。</li></ul><p>在这三条所有权规则的约束下，我们看开头的引用问题是如何解决的：</p><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hqwuzhaoyi.github.io/fe810cf1616bce15f53bcf6d28d7f864.webp" alt="问题是如何解决的"></p><h2 id="Move-语义"><a href="#Move-语义" class="headerlink" title="Move 语义"></a>Move 语义</h2><p>原先 main() 函数中的 data，被移动到 find_pos() 后，就失效了，编译器会保证 main() 函数随后的代码无法访问这个变量，这样，就确保了堆上的内存依旧只有唯一的引用。这也就是 <strong>Move 语义</strong></p><p>如果要同时访问的话就使用 <code>data.clone()</code> 把 <code>data</code> 复制一份出来</p><p><strong>所有权规则，解决了谁真正拥有数据的生杀大权问题，让堆上数据的多重引用不复存在，这是它最大的优势。</strong></p><h2 id="Copy-语义和-Copy-trait"><a href="#Copy-语义和-Copy-trait" class="headerlink" title="Copy 语义和 Copy trait"></a>Copy 语义和 Copy trait</h2><p>符合 Copy 语义的类型，<strong>在你赋值或者传参时，值会自动按位拷贝。</strong></p><p>换句话说，当你要移动一个值，如果值的类型实现了 Copy trait，就会自动使用 Copy 语义进行拷贝，否则使用 Move 语义进行移动。</p><ul><li>原生类型，包括函数、不可变引用和裸指针实现了 Copy；</li><li>数组和元组，如果其内部的数据结构实现了 Copy，那么它们也实现了 Copy；</li><li>可变引用没有实现 Copy；</li><li>非固定大小的数据结构，没有实现 Copy。</li></ul><h4 id="实现了-Copy-trait-的数据结构"><a href="#实现了-Copy-trait-的数据结构" class="headerlink" title="实现了 Copy trait 的数据结构"></a>实现了 Copy trait 的数据结构</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">is_copy</span></span>&lt;T: <span class="built_in">Copy</span>&gt;() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">types_impl_copy_trait</span></span>() &#123;</span><br><span class="line">    is_copy::&lt;<span class="built_in">bool</span>&gt;();</span><br><span class="line">    is_copy::&lt;<span class="built_in">char</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// all iXX and uXX, usize/isize, fXX implement Copy trait</span></span><br><span class="line">    is_copy::&lt;<span class="built_in">i8</span>&gt;();</span><br><span class="line">    is_copy::&lt;<span class="built_in">u64</span>&gt;();</span><br><span class="line">    is_copy::&lt;<span class="built_in">i64</span>&gt;();</span><br><span class="line">    is_copy::&lt;<span class="built_in">usize</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// function (actually a pointer) is Copy</span></span><br><span class="line">    is_copy::&lt;<span class="function"><span class="keyword">fn</span></span>()&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// raw pointer is Copy</span></span><br><span class="line">    is_copy::&lt;*<span class="keyword">const</span> <span class="built_in">String</span>&gt;();</span><br><span class="line">    is_copy::&lt;*<span class="keyword">mut</span> <span class="built_in">String</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// immutable reference is Copy</span></span><br><span class="line">    is_copy::&lt;&amp;[<span class="built_in">Vec</span>&lt;<span class="built_in">u8</span>&gt;]&gt;();</span><br><span class="line">    is_copy::&lt;&amp;<span class="built_in">String</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// array/tuple with values which is Copy is Copy</span></span><br><span class="line">    is_copy::&lt;[<span class="built_in">u8</span>; <span class="number">4</span>]&gt;();</span><br><span class="line">    is_copy::&lt;(&amp;<span class="built_in">str</span>, &amp;<span class="built_in">str</span>)&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">types_not_impl_copy_trait</span></span>() &#123;</span><br><span class="line">    <span class="comment">// unsized or dynamic sized type is not Copy</span></span><br><span class="line">    is_copy::&lt;<span class="built_in">str</span>&gt;();</span><br><span class="line">    is_copy::&lt;[<span class="built_in">u8</span>]&gt;();</span><br><span class="line">    is_copy::&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">u8</span>&gt;&gt;();</span><br><span class="line">    is_copy::&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mutable reference is not Copy</span></span><br><span class="line">    is_copy::&lt;&amp;<span class="keyword">mut</span> <span class="built_in">String</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// array / tuple with values that not Copy is not Copy</span></span><br><span class="line">    is_copy::&lt;[<span class="built_in">Vec</span>&lt;<span class="built_in">u8</span>&gt;; <span class="number">4</span>]&gt;();</span><br><span class="line">    is_copy::&lt;(<span class="built_in">String</span>, <span class="built_in">u32</span>)&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    types_impl_copy_trait();</span><br><span class="line">    types_not_impl_copy_trait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Borrow-语义"><a href="#Borrow-语义" class="headerlink" title="Borrow 语义"></a>Borrow 语义</h2><p>Borrow 语义允许一个值的所有权，在不发生转移的情况下，被其它上下文使用。</p><p>语法（&amp; 或者 &amp;mut）</p><p>在 Rust 下，所有的引用都只是借用了“临时使用权”，它并不破坏值的单一所有权约束。因此默认情况下，<strong>Rust 的借用都是只读的</strong>。</p><h3 id="只读借用-引用"><a href="#只读借用-引用" class="headerlink" title="只读借用 / 引用"></a>只读借用 / 引用</h3><p>本质上，引用是一个受控的指针，指向某个特定的类型。在学习其他语言的时候，你会注意到函数传参有两种方式：传值（pass-by-value）和传引用（pass-by-reference）。</p><p>但 Rust 没有传引用的概念，<strong>Rust 所有的参数传递都是传值</strong>，不管是 Copy 还是 Move。所以在 Rust 中，你必须显式地把某个数据的引用，传给另一个函数。</p><p>Rust 的引用实现了 Copy trait，所以按照 Copy 语义，这个引用会被复制一份交给要调用的函数。对这个函数来说，它并不拥有数据本身，数据只是临时借给它使用，所有权还在原来的拥有者那里。</p><p>在 Rust 里，引用是一等公民，和其他数据类型地位相等。</p><p><strong>只读引用实现了 Copy trait，也就意味着引用的赋值、传参都会产生新的浅拷贝。</strong></p><h3 id="借用的生命周期及其约束"><a href="#借用的生命周期及其约束" class="headerlink" title="借用的生命周期及其约束"></a>借用的生命周期及其约束</h3><p>值的引用也要有约束，这个约束是：借用不能超过（outlive）值的生存期。</p><ol><li><p>生命周期更长的 main() 函数变量 r ，引用了生命周期更短的 local_ref() 函数里的局部变量，这违背了有关引用的约束</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> r = local_ref();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;r: &#123;:p&#125;&quot;</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">local_ref</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;() -&gt; &amp;<span class="symbol">&#x27;a</span> <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">42</span>;</span><br><span class="line">    &amp;a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在堆内存中，使用栈内存的引用</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> data: <span class="built_in">Vec</span>&lt;&amp;<span class="built_in">u32</span>&gt; = <span class="built_in">Vec</span>::new();</span><br><span class="line">    <span class="keyword">let</span> v = <span class="number">42</span>;</span><br><span class="line">    data.push(&amp;v);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;data: &#123;:?&#125;&quot;</span>, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>堆内存中使用了生命周期更短的局部变量</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> data: <span class="built_in">Vec</span>&lt;&amp;<span class="built_in">u32</span>&gt; = <span class="built_in">Vec</span>::new();</span><br><span class="line">    push_local_ref(&amp;<span class="keyword">mut</span> data);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;data: &#123;:?&#125;&quot;</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">push_local_ref</span></span>(data: &amp;<span class="keyword">mut</span> <span class="built_in">Vec</span>&lt;&amp;<span class="built_in">u32</span>&gt;) &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="number">42</span>;</span><br><span class="line">    data.push(&amp;v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p>这三段代码看似错综复杂，但如果抓住了一个核心要素“<strong>在一个作用域下，同一时刻，一个值只能有一个所有者</strong>”，你会发现，其实很简单。</p><p>堆变量的生命周期不具备任意长短的灵活性，因为堆上内存的生死存亡，跟栈上的所有者牢牢绑定。而栈上内存的生命周期，又跟栈的生命周期相关，所以我们核心<strong>只需要关心调用栈的生命周期</strong>。</p><h3 id="可变借用-引用"><a href="#可变借用-引用" class="headerlink" title="可变借用 / 引用"></a>可变借用 / 引用</h3><h4 id="错误示范"><a href="#错误示范" class="headerlink" title="错误示范"></a>错误示范</h4><h5 id="1-多个可变引用"><a href="#1-多个可变引用" class="headerlink" title="1. 多个可变引用"></a>1. 多个可变引用</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> data = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> data.iter_mut() &#123;</span><br><span class="line">        data.push(*item + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码在遍历可变数组 data 的过程中，还往 data 里添加新的数据，这是很危险的动作，因为它破坏了循环的不变性（loop invariant），容易导致死循环甚至系统崩溃。</p><p>所以，在同一个作用域下有多个可变引用，是不安全的。</p><h5 id="2-同时有一个可变引用和若干个只读引用"><a href="#2-同时有一个可变引用和若干个只读引用" class="headerlink" title="2. 同时有一个可变引用和若干个只读引用"></a>2. 同时有一个可变引用和若干个只读引用</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> data = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> data1 = <span class="built_in">vec!</span>[&amp;data[<span class="number">0</span>]];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;data[0]: &#123;:p&#125;&quot;</span>, &amp;data[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">100</span> &#123;</span><br><span class="line">        data.push(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;data[0]: &#123;:p&#125;&quot;</span>, &amp;data[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;boxed: &#123;:p&#125;&quot;</span>, &amp;data1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不可变数组 data1 引用了可变数组 data 中的一个元素，这是个只读引用。后续我们往 data 中添加了 100 个元素，在调用 data.push() 时，我们访问了 data 的可变引用。</p><p>仔细推敲，就会发现这里有内存不安全的潜在操作：如果继续添加元素，堆上的数据预留的空间不够了，就会重新分配一片足够大的内存，把之前的值拷过来，然后释放旧的内存。这样就会让 data1 中保存的 &amp;data[0] 引用失效，导致内存安全问题。</p><h4 id="Rust-的限制"><a href="#Rust-的限制" class="headerlink" title="Rust 的限制"></a>Rust 的限制</h4><p>多个可变引用共存、可变引用和只读引用共存这两种问题，通过 GC 等自动内存管理方案可以避免第二种，但是第一个问题 GC 也无济于事。</p><p>所以为了保证内存安全，Rust 对可变引用的使用也做了严格的约束：</p><ul><li><strong>在一个作用域内，仅允许一个活跃的可变引用。</strong>所谓活跃，就是真正被使用来修改数据的可变引用，如果只是定义了，却没有使用或者当作只读引用使用，不算活跃。</li><li>在一个作用域内，活跃的可变引用（写）和只读引用（读）是互斥的，不能同时存在。</li></ul><h2 id="共享所有权"><a href="#共享所有权" class="headerlink" title="共享所有权"></a>共享所有权</h2><p><strong>Rc（Reference counter） 和 Arc（Atomic reference counter）。</strong></p><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hqwuzhaoyi.github.io/202202091527559.jpg" alt="共享所有权"></p><h3 id="Rc"><a href="#Rc" class="headerlink" title="Rc"></a>Rc</h3><p>我们先看 Rc。对某个数据结构 T，我们可以创建引用计数 Rc，使其有多个所有者。Rc 会把对应的数据结构创建在堆上，我们在第二讲谈到过，堆是唯一可以让动态创建的数据被到处使用的内存。</p><p><strong>对一个 Rc 结构进行 clone()，不会将其内部的数据复制，只会增加引用计数。</strong>而当一个 Rc 结构离开作用域被 drop() 时，也只会减少其引用计数，直到引用计数为零，才会真正清除对应的内存。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = Rc::new(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> b = a.clone();</span><br><span class="line">    <span class="keyword">let</span> c = a.clone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hqwuzhaoyi.github.io/202202091509439.jpg" alt="Rc"></p><p>上面的代码我们创建了三个 Rc，分别是 a、b 和 c。它们共同指向堆上相同的数据，也就是说，堆上的数据有了三个共享的所有者。在这段代码结束时，c 先 drop，引用计数变成 2，然后 b drop、a drop，引用计数归零，堆上内存被释放。</p><p>为什么我们生成了对同一块内存的多个所有者，但是，编译器不抱怨所有权冲突呢？</p><p>仔细看这段代码：首先 a 是 Rc::new(1) 的所有者，这毋庸置疑；然后 b 和 c 都调用了 a.clone()，分别得到了一个新的 Rc，所以从编译器的角度，abc 都各自拥有一个 Rc。如果文字你觉得稍微有点绕，看看 Rc 的 clone() 函数的实现，就很清楚了,<a href="https://doc.rust-lang.org/src/alloc/rc.rs.html#1433-1453">clone 源代码</a></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">clone</span></span>(&amp;<span class="keyword">self</span>) -&gt; Rc&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 增加引用计数</span></span><br><span class="line">    <span class="keyword">self</span>.inner().inc_strong();</span><br><span class="line">    <span class="comment">// 通过 self.ptr 生成一个新的 Rc 结构</span></span><br><span class="line">    Self::from_inner(<span class="keyword">self</span>.ptr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Rc 的 clone() 正如我们刚才说的，不复制实际的数据，只是一个引用计数的增加。</p><p>Rc 是怎么产生在堆上的？并且为什么这段堆内存不受栈内存生命周期的控制呢？</p><h4 id="Box-leak-机制"><a href="#Box-leak-机制" class="headerlink" title="Box::leak() 机制"></a>Box::leak() 机制</h4><p>在所有权模型下，堆内存的生命周期，和创建它的栈内存的生命周期保持一致。所以 Rc 的实现似乎与此格格不入。的确，如果完全按照上一讲的单一所有权模型，Rust 是无法处理 Rc 这样的引用计数的。Rust 必须提供一种机制，让代码可以像 C/C++ 那样，<strong>创建不受栈内存控制的堆内存，从而绕过编译时的所有权规则。</strong>Rust 提供的方式是 Box::leak()。</p><p>Box 是 Rust 下的智能指针，它可以强制把任何数据结构创建在堆上，然后在栈上放一个指针指向这个数据结构，但此时堆内存的生命周期仍然是受控的，跟栈上的指针一致。我们后续讲到智能指针时会详细介绍 Box。</p><p>Box::leak()，顾名思义，它创建的对象，从堆内存上泄漏出去，不受栈内存控制，是一个自由的、生命周期可以大到和整个进程的生命周期一致的对象。有了 Box::leak()，我们就可以跳出 Rust 编译器的静态检查。</p><p>搞明白了 Rc，我们就进一步理解 Rust 是如何进行所有权的静态检查和动态检查了：</p><ul><li>静态检查，靠编译器保证代码符合所有权规则；</li><li>动态检查，通过 Box::leak 让堆内存拥有不受限的生命周期，然后在运行过程中，通过对引用计数的检查，保证这样的堆内存最终会得到释放。</li></ul><h3 id="RefCell"><a href="#RefCell" class="headerlink" title="RefCell"></a>RefCell</h3><p>Rc 是一个只读的引用计数器，你无法拿到 Rc 结构内部数据的可变引用，来修改这个数据。这可怎么办？这里，我们需要使用 RefCell。</p><p>和 Rc 类似，RefCell 也绕过了 Rust 编译器的静态检查，允许我们在运行时，对某个只读数据进行可变借用。这就涉及 Rust 另一个比较独特且有点难懂的概念：内部可变性（interior mutability）。</p><h4 id="内部可变性"><a href="#内部可变性" class="headerlink" title="内部可变性"></a>内部可变性</h4><p>有内部可变性，自然能联想到外部可变性，所以我们先看这个更简单的定义，对比着学。</p><p>当我们用 let mut 显式地声明一个可变的值，或者，用 &amp;mut 声明一个可变引用时，编译器可以在编译时进行严格地检查，保证只有可变的值或者可变的引用，才能修改值内部的数据，这被称作<strong>外部可变性（exterior mutability），外部可变性通过 mut 关键字声明</strong>。</p><p>然而，这样不够灵活，有时候我们希望能够绕开这个编译时的检查，对并未声明成 mut 的值或者引用，也想进行修改。也就是说，<strong>在编译器的眼里，值是只读的，但是在运行时，这个值可以得到可变借用，从而修改内部的数据</strong>，这就是 RefCell 的用武之地。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> data = RefCell::new(<span class="number">1</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获得 RefCell 内部数据的可变借用</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> v = data.borrow_mut();</span><br><span class="line">        *v += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;data: &#123;:?&#125;&quot;</span>, data.borrow());</span><br><span class="line">    <span class="comment">// data: 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子里，data 是一个 RefCell，其初始值为 1。可以看到，我们并未将 data 声明为可变变量。之后我们可以通过使用 RefCell 的 <code>borrow_mut()</code> 方法，来获得一个<strong>可变的内部引用</strong>，然后对它做加 1 的操作。最后，我们可以通过 RefCell 的 <code>borrow()</code> 方法，获得一个<strong>不可变的内部引用</strong>，因为加了 1，此时它的值为 2。</p><p>你也许奇怪，这里为什么要把获取和操作可变借用的两句代码，用花括号分装到一个作用域下？因为根据所有权规则，<strong>在同一个作用域下，我们不能同时有活跃的可变借用和不可变借用。</strong>通过这对花括号，我们明确地缩小了可变借用的生命周期，不至于和后续的不可变借用冲突。</p><h3 id="Arc-和-Mutex-RwLock"><a href="#Arc-和-Mutex-RwLock" class="headerlink" title="Arc 和 Mutex/RwLock"></a>Arc 和 Mutex/RwLock</h3><p>开头提到的多个线程访问同一块内存的问题，是否也可以使用 Rc 来处理呢？不行。因为 Rc 为了性能，使用的不是线程安全的引用计数器。因此，我们需要另一个引用计数的智能指针：Arc，它实现了线程安全的引用计数器。</p><p>Arc 内部的引用计数使用了 Atomic Usize ，而非普通的 usize。从名称上也可以感觉出来，Atomic Usize 是 usize 的原子类型，它使用了 CPU 的特殊指令，来保证多线程下的安全。</p><p>Rust 实现两套不同的引用计数数据结构，完全是为了性能考虑，从这里我们也可以感受到 Rust 对性能的极致渴求。<strong>如果不用跨线程访问，可以用效率非常高的 Rc；如果要跨线程访问，那么必须用 Arc。</strong></p><p>同样的，RefCell 也不是线程安全的，如果我们要在多线程中，使用内部可变性，Rust 提供了 Mutex 和 RwLock。</p><ul><li>Mutex 是互斥量，获得互斥量的线程对数据独占访问</li><li>RwLock 是读写锁，获得写锁的线程对数据独占访问，但当没有写锁的时候，允许有多个读锁。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hqwuzhaoyi.</summary>
      
    
    
    
    <category term="rust" scheme="https://hqwuzhaoyi.github.io/categories/rust/"/>
    
    
  </entry>
  
  <entry>
    <title>rust 初学</title>
    <link href="https://hqwuzhaoyi.github.io/2022/02/03/rust/1.rust%E5%88%9D%E5%AD%A6/"/>
    <id>https://hqwuzhaoyi.github.io/2022/02/03/rust/1.rust%E5%88%9D%E5%AD%A6/</id>
    <published>2022-02-03T00:00:00.000Z</published>
    <updated>2022-08-29T03:13:16.652Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>基本概念</p><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hqwuzhaoyi.github.io/549bd1fd477ba608ac4a3f785cb49043.webp" alt="基本概念"></p><p>Rust 定义变量、函数和数据结构</p><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hqwuzhaoyi.github.io/15e5152fe2b72794074cff40041722cb.webp" alt="Rust 定义变量、函数和数据结构"></p><p>控制流程</p><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hqwuzhaoyi.github.io/e3a96ae58a98f46f98b56yya6378b26c.webp" alt="控制流程"></p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="下载-url-为-md-文件"><a href="#下载-url-为-md-文件" class="headerlink" title="下载 url 为 md 文件"></a>下载 url 为 md 文件</h3><p>在 <code>terminal</code> 输入 <code>cargo run -- https://www.rust-lang.org rust.md</code></p><p>即是把 <code>https://www.rust-lang.org</code> 下载到 <code>rust.md</code></p><p><code>Cargo.toml</code></p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;scrape_url&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2021&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">reqwest</span> = &#123; version = <span class="string">&quot;0.11&quot;</span>, features = [<span class="string">&#x27;blocking&#x27;</span>] &#125;</span><br><span class="line"><span class="attr">html2md</span> = <span class="string">&quot;0.2&quot;</span></span><br></pre></td></tr></table></figure><p><code>main.rs</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">md_params</span></span>() -&gt; <span class="built_in">Result</span>&lt;(<span class="built_in">String</span>, <span class="built_in">String</span>), <span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> std::error::Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> url = std::env::args().nth(<span class="number">1</span>).expect(<span class="string">&quot;Missing argument&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> output = std::env::args().nth(<span class="number">2</span>).expect(<span class="string">&quot;Missing argument&quot;</span>);</span><br><span class="line">    <span class="literal">Ok</span>((url, output))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// let url = &quot;https://www.rust-lang.org/&quot;;</span></span><br><span class="line">    <span class="comment">// let output = &quot;rust.md&quot;;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = md_params();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> result &#123;</span><br><span class="line">        <span class="literal">Ok</span>((url, output)) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Fetching url: &#123;&#125;&quot;</span>, url);</span><br><span class="line">            <span class="keyword">let</span> body = reqwest::blocking::get(url).unwrap().text().unwrap();</span><br><span class="line"></span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Converting html to markdown...&quot;</span>);</span><br><span class="line">            <span class="keyword">let</span> md = html2md::parse_html(&amp;body);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Converted markdown has been saved in &#123;&#125;.&quot;</span>, output);</span><br><span class="line">            fs::write(output, md.as_bytes()).unwrap();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="literal">Err</span>(err) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Error: &#123;&#125;&quot;</span>, err.to_string());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="费波纳基数列"><a href="#费波纳基数列" class="headerlink" title="费波纳基数列"></a>费波纳基数列</h3><p><code>main.rs</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">next_fiber</span></span>(a: &amp;<span class="keyword">mut</span> <span class="built_in">i32</span>, b: &amp;<span class="keyword">mut</span> <span class="built_in">i32</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> c = *a + *b;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">fib_loop</span></span>(n: <span class="built_in">u8</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> i = <span class="number">2u8</span>;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="comment">// let c = a + b;</span></span><br><span class="line">        <span class="comment">// a = b;</span></span><br><span class="line">        <span class="comment">// b = c;</span></span><br><span class="line">        next_fiber(&amp;<span class="keyword">mut</span> a, &amp;<span class="keyword">mut</span> b);</span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;next val is &#123;&#125;&quot;</span>, b);</span><br><span class="line">        <span class="keyword">if</span> i &gt;= n &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">fib_while</span></span>(n: <span class="built_in">u8</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> (<span class="keyword">mut</span> a, <span class="keyword">mut</span> b, <span class="keyword">mut</span> i) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">while</span> i &lt; n &#123;</span><br><span class="line">        <span class="comment">// let c = a + b;</span></span><br><span class="line">        <span class="comment">// a = b;</span></span><br><span class="line">        <span class="comment">// b = c;</span></span><br><span class="line">        next_fiber(&amp;<span class="keyword">mut</span> a, &amp;<span class="keyword">mut</span> b);</span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;next val is &#123;&#125;&quot;</span>, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">fib_for</span></span>(n: <span class="built_in">u8</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> (<span class="keyword">mut</span> a, <span class="keyword">mut</span> b) = (<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> _i <span class="keyword">in</span> <span class="number">2</span>..n &#123;</span><br><span class="line">        <span class="comment">// let c = a + b;</span></span><br><span class="line">        <span class="comment">// a = b;</span></span><br><span class="line">        <span class="comment">// b = c;</span></span><br><span class="line">        next_fiber(&amp;<span class="keyword">mut</span> a, &amp;<span class="keyword">mut</span> b);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;next val is &#123;&#125;&quot;</span>, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">10</span>;</span><br><span class="line">    fib_loop(n);</span><br><span class="line">    fib_while(n);</span><br><span class="line">    fib_for(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h2&gt;&lt;p&gt;基本概念&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com</summary>
      
    
    
    
    <category term="rust" scheme="https://hqwuzhaoyi.github.io/categories/rust/"/>
    
    
  </entry>
  
  <entry>
    <title>js 实用工具</title>
    <link href="https://hqwuzhaoyi.github.io/2021/12/16/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/74.%E5%AE%9E%E7%94%A8js/"/>
    <id>https://hqwuzhaoyi.github.io/2021/12/16/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/74.%E5%AE%9E%E7%94%A8js/</id>
    <published>2021-12-16T00:00:00.000Z</published>
    <updated>2022-08-29T03:13:16.656Z</updated>
    
    <content type="html"><![CDATA[<h2 id="deleteNillValueFromObject"><a href="#deleteNillValueFromObject" class="headerlink" title="deleteNillValueFromObject"></a>deleteNillValueFromObject</h2><p>删除<code>undefined</code>,<code>null</code>,<code>[]</code>,<code>&#123;&#125;</code>从<code>Object</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> deleteNillValueFromObject = <span class="function"><span class="params">obj</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// &#123;a:1, b: 2, c: null, d: []&#125;</span></span><br><span class="line">  <span class="keyword">const</span> noEmpty = <span class="function">(<span class="params">val, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !(R.isNil(val) || R.isEmpty(val));</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> removeEmptyFromObject = R.curry(R.pickBy(noEmpty));</span><br><span class="line">  <span class="keyword">return</span> removeEmptyFromObject(obj);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;deleteNillValueFromObject&quot;&gt;&lt;a href=&quot;#deleteNillValueFromObject&quot; class=&quot;headerlink&quot; title=&quot;deleteNillValueFromObject&quot;&gt;&lt;/a&gt;deleteNillV</summary>
      
    
    
    
    <category term="前端基础" scheme="https://hqwuzhaoyi.github.io/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="JS" scheme="https://hqwuzhaoyi.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>树莓派初试</title>
    <link href="https://hqwuzhaoyi.github.io/2021/12/15/%E6%A0%91%E8%8E%93%E6%B4%BE/first/"/>
    <id>https://hqwuzhaoyi.github.io/2021/12/15/%E6%A0%91%E8%8E%93%E6%B4%BE/first/</id>
    <published>2021-12-15T00:00:00.000Z</published>
    <updated>2022-08-29T03:13:16.656Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>国内镜像<br>debian (bullseye)</p><p>编辑 <code>/etc/apt/sources.list</code> 文件，删除原文件所有内容，用以下内容取代</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/raspbian/raspbian/ bullseye main non-free contrib</span><br><span class="line">deb-src http://mirrors.aliyun.com/raspbian/raspbian/ bullseye main non-free contrib</span><br></pre></td></tr></table></figure><p>编辑 <code>/etc/apt/sources.list.d/raspi.list</code> 文件，删除原文件所有内容，用以下内容取代：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/raspberrypi/ bullseye main</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="docker-搭建-home-assistant"><a href="#docker-搭建-home-assistant" class="headerlink" title="docker 搭建 home assistant"></a>docker 搭建 home assistant</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name homeassistant \</span><br><span class="line">  --privileged \</span><br><span class="line">  --restart=unless-stopped \</span><br><span class="line">  -e TZ=MY_TIME_ZONE \</span><br><span class="line">  -v /PATH_TO_YOUR_CONFIG:/config \</span><br><span class="line">  --network=host \</span><br><span class="line">  ghcr.io/home-assistant/home-assistant:stable</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h2&gt;&lt;p&gt;国内镜像&lt;br&gt;debian (bullseye)&lt;/p&gt;
&lt;p&gt;编辑 &lt;code&gt;/etc/apt/sources.list&lt;/code&gt;</summary>
      
    
    
    
    <category term="树莓派" scheme="https://hqwuzhaoyi.github.io/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    
    <category term="linux" scheme="https://hqwuzhaoyi.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>github action 私钥部署</title>
    <link href="https://hqwuzhaoyi.github.io/2021/10/03/github%20action%20secrect/"/>
    <id>https://hqwuzhaoyi.github.io/2021/10/03/github%20action%20secrect/</id>
    <published>2021-10-03T00:00:00.000Z</published>
    <updated>2022-08-29T03:13:16.652Z</updated>
    
    <content type="html"><![CDATA[<h2 id="生成公私钥"><a href="#生成公私钥" class="headerlink" title="生成公私钥"></a>生成公私钥</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C &quot;$(git config user.email)&quot; -f github-deploy-key -N &quot;&quot;</span><br></pre></td></tr></table></figure><p>目录中生成两个文件：</p><ul><li><code>github-deploy-key.pub</code> — 公钥文件</li><li><code>github-deploy-key</code> — 私钥文件</li></ul><p><strong>公钥和私钥切记要添加到 .gitignore 中！！！</strong></p><h2 id="GitHub-添加公钥"><a href="#GitHub-添加公钥" class="headerlink" title="GitHub 添加公钥"></a>GitHub 添加公钥</h2><p>在 GitHub 中博客工程中按照 <code>Settings-&gt;Deploy keys-&gt;Add deploy key</code> 找到对应的页面，然后进行公钥添加。该页面中 <strong>Title</strong> 自定义即可，<strong>Key</strong> 中添加 <code>github-deploy-key.pub</code> 文件中的内容。</p><p><strong>切记要勾选 Allow write access，否则会出现无法部署的情况。</strong></p><h2 id="GitHub-添加私钥"><a href="#GitHub-添加私钥" class="headerlink" title="GitHub 添加私钥"></a>GitHub 添加私钥</h2><p>在 GitHub 中博客工程中按照 <code>Settings-&gt;Secrets-&gt;Add a new secrets</code> 找到对应的页面，然后进行私钥添加。该页面中 <strong>Name</strong> 自定义即可，<strong>Value</strong> 中添加 <code>github-deploy-key</code> 文件中的内容。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;生成公私钥&quot;&gt;&lt;a href=&quot;#生成公私钥&quot; class=&quot;headerlink&quot; title=&quot;生成公私钥&quot;&gt;&lt;/a&gt;生成公私钥&lt;/h2&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;</summary>
      
    
    
    
    
    <category term="github" scheme="https://hqwuzhaoyi.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>docker 安装问题</title>
    <link href="https://hqwuzhaoyi.github.io/2021/08/29/docker%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98/"/>
    <id>https://hqwuzhaoyi.github.io/2021/08/29/docker%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98/</id>
    <published>2021-08-29T00:00:00.000Z</published>
    <updated>2022-08-29T03:13:16.652Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker-engine"><a href="#docker-engine" class="headerlink" title="docker engine"></a>docker engine</h2><p><a href="https://docs.docker.com/engine/install/ubuntu/">docker engine</a></p><p><code>docker engine</code> 安装后执行 <code>sudo docker run hello-world</code></p><p>报错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">╰─ sudo docker run hello-world</span><br><span class="line">docker: Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?.</span><br><span class="line">See <span class="string">&#x27;docker run --help&#x27;</span>.</span><br></pre></td></tr></table></figure><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo service docker status</span><br><span class="line"></span><br><span class="line">sudo service docker start</span><br></pre></td></tr></table></figure><h2 id="curl-挂代理"><a href="#curl-挂代理" class="headerlink" title="curl 挂代理"></a>curl 挂代理</h2><p><a href="https://docs.docker.com/compose/install/#alternative-install-options">docker compose</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --socks5 172.28.128.1:7890</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;docker-engine&quot;&gt;&lt;a href=&quot;#docker-engine&quot; class=&quot;headerlink&quot; title=&quot;docker engine&quot;&gt;&lt;/a&gt;docker engine&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://docs.dock</summary>
      
    
    
    
    
    <category term="docker" scheme="https://hqwuzhaoyi.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>函数式入门笔记1</title>
    <link href="https://hqwuzhaoyi.github.io/2021/08/01/%E5%87%BD%E6%95%B0%E5%BC%8F/%E5%87%BD%E6%95%B0%E5%BC%8F%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B01/"/>
    <id>https://hqwuzhaoyi.github.io/2021/08/01/%E5%87%BD%E6%95%B0%E5%BC%8F/%E5%87%BD%E6%95%B0%E5%BC%8F%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B01/</id>
    <published>2021-08-01T00:00:00.000Z</published>
    <updated>2022-08-29T03:13:16.656Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/21714695">JavaScript 函数式编程（一）</a></li><li><a href="https://zhuanlan.zhihu.com/p/21926955">JavaScript 函数式编程（二）</a></li><li><a href="https://zhuanlan.zhihu.com/p/22094473">JavaScript 函数式编程（三）</a></li><li><a href="https://www.zhihu.com/question/336788253/answer/765357269">怎么学习函数式编程?</a></li><li><a href="https://www.zhihu.com/question/385453621/answer/1132000547">学习 Computational Trinitarianism 应按照怎样的学习路径</a></li><li><a href="http://learnyouahaskell.com/chapters">Learn You a Haskell for Great Good!</a></li><li><a href="https://medium.com/javascript-scene/composing-software-the-book-f31c77fc3ddc">Composing Software: The Book</a></li><li><a href="https://zhuanlan.zhihu.com/p/32182423?refer=typetheory">类型论驿站写作计划</a></li></ul><h2 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h2><p>纯函数的定义是，对于相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用，也不依赖外部环境的状态</p><h2 id="函数的柯里化"><a href="#函数的柯里化" class="headerlink" title="函数的柯里化"></a>函数的柯里化</h2><p>传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。</p><p>事实上柯里化是一种“预加载”函数的方法，通过传递较少的参数，得到一个已经记住了这些参数的新函数，某种意义上讲，这是一种对参数的“缓存”，是一种非常高效的编写函数的方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; curry &#125; <span class="keyword">from</span> <span class="string">&quot;lodash&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//首先柯里化两个纯函数</span></span><br><span class="line"><span class="keyword">var</span> match = curry(<span class="function">(<span class="params">reg, str</span>) =&gt;</span> str.match(reg));</span><br><span class="line"><span class="keyword">var</span> filter = curry(<span class="function">(<span class="params">f, arr</span>) =&gt;</span> arr.filter(f));</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断字符串里有没有空格</span></span><br><span class="line"><span class="keyword">var</span> haveSpace = match(<span class="regexp">/\s+/g</span>);</span><br><span class="line"></span><br><span class="line">haveSpace(<span class="string">&quot;ffffffff&quot;</span>);</span><br><span class="line"><span class="comment">//=&gt;null</span></span><br><span class="line"></span><br><span class="line">haveSpace(<span class="string">&quot;a b&quot;</span>);</span><br><span class="line"><span class="comment">//=&gt;[&quot; &quot;]</span></span><br><span class="line"></span><br><span class="line">filter(haveSpace, [<span class="string">&quot;abcdefg&quot;</span>, <span class="string">&quot;Hello World&quot;</span>]);</span><br><span class="line"><span class="comment">//=&gt;[&quot;Hello world&quot;]</span></span><br></pre></td></tr></table></figure><h2 id="函数组合"><a href="#函数组合" class="headerlink" title="函数组合"></a>函数组合</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两个函数的组合</span></span><br><span class="line"><span class="keyword">var</span> compose = <span class="function"><span class="keyword">function</span> (<span class="params">f, g</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f(g(x));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">var</span> compose = <span class="function">(<span class="params">f, g</span>) =&gt;</span> <span class="function">(<span class="params">x</span>) =&gt;</span> f(g(x));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add1 = <span class="function">(<span class="params">x</span>) =&gt;</span> x + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> mul5 = <span class="function">(<span class="params">x</span>) =&gt;</span> x * <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">compose(mul5, add1)(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><h2 id="Point-Free"><a href="#Point-Free" class="headerlink" title="Point Free"></a>Point Free</h2><p>细心的话你可能会注意到，之前的代码中我们总是喜欢把一些对象自带的方法转化成纯函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="function">(<span class="params">f, arr</span>) =&gt;</span> arr.map(f);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> toUpperCase = <span class="function">(<span class="params">word</span>) =&gt;</span> word.toUpperCase();</span><br></pre></td></tr></table></figure><p><code>Point Free</code>这种模式现在还暂且没有中文的翻译，有兴趣的话可以看看这里的英文解释：</p><p><a href="https://en.wikipedia.org/wiki/Tacit_programming">Tacit_programming</a><br><a href="https://www.ruanyifeng.com/blog/2017/03/pointfree.html">阮一峰 Pointfree 编程风格指南</a></p><p>比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这不Point free</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function">(<span class="params">str</span>) =&gt;</span> str.toUpperCase().split(<span class="string">&quot; &quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> toUpperCase = <span class="function">(<span class="params">word</span>) =&gt;</span> word.toUpperCase();</span><br><span class="line"><span class="keyword">var</span> split = <span class="function">(<span class="params">x</span>) =&gt;</span> <span class="function">(<span class="params">str</span>) =&gt;</span> str.split(x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = compose(split(<span class="string">&quot; &quot;</span>), toUpperCase);</span><br><span class="line"></span><br><span class="line">f(<span class="string">&quot;abcd efgh&quot;</span>);</span><br></pre></td></tr></table></figure><p>这种风格能够帮助我们减少不必要的命名，让代码保持简洁和通用。当然，为了在一些函数中写出 Point Free 的风格，在代码的其它地方必然是不那么 Point Free 的，这个地方需要自己取舍。</p><h3 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h3><p>比如，读取对象的 role 属性，不要直接写成 obj.role，而是要把这个操作封装成函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> prop = <span class="function">(<span class="params">p, obj</span>) =&gt;</span> obj[p];</span><br><span class="line"><span class="keyword">var</span> propRole = R.curry(prop)(<span class="string">&quot;role&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isWorker = <span class="function">(<span class="params">s</span>) =&gt;</span> s === <span class="string">&quot;worker&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> getWorkers = R.filter(R.pipe(propRole, isWorker));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span>, <span class="attr">role</span>: <span class="string">&quot;worker&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;李四&quot;</span>, <span class="attr">role</span>: <span class="string">&quot;worker&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;王五&quot;</span>, <span class="attr">role</span>: <span class="string">&quot;manager&quot;</span> &#125;,</span><br><span class="line">];</span><br><span class="line">getWorkers(data);</span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//   &#123;&quot;name&quot;: &quot;张三&quot;, &quot;role&quot;: &quot;worker&quot;&#125;,</span></span><br><span class="line"><span class="comment">//   &#123;&quot;name&quot;: &quot;李四&quot;, &quot;role&quot;: &quot;worker&quot;&#125;</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>data</code>是传入的值，<code>getWorkers</code>是处理这个值的函数。定义<code>getWorkers</code>的时候，完全没有提到<code>data</code>，这就是 <code>Pointfree</code>。</p><p>简单说，<code>Pointfree</code> 就是运算过程抽象化，处理一个值，但是不提到这个值。这样做有很多好处，它能够让代码更清晰和简练，更符合语义，更容易复用，测试也变得轻而易举。</p><h3 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;Lorem ipsum dolor sit amet consectetur adipiscing elit&quot;</span>;</span><br></pre></td></tr></table></figure><p>上面是一个字符串，请问其中最长的单词有多少个字符？</p><p>先定义一些基本运算。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以空格分割单词</span></span><br><span class="line"><span class="keyword">var</span> splitBySpace = <span class="function">(<span class="params">s</span>) =&gt;</span> s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个单词的长度</span></span><br><span class="line"><span class="keyword">var</span> getLength = <span class="function">(<span class="params">w</span>) =&gt;</span> w.length;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 词的数组转换成长度的数组</span></span><br><span class="line"><span class="keyword">var</span> getLengthArr = <span class="function">(<span class="params">arr</span>) =&gt;</span> R.map(getLength, arr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回较大的数字</span></span><br><span class="line"><span class="keyword">var</span> getBiggerNumber = <span class="function">(<span class="params">a, b</span>) =&gt;</span> (a &gt; b ? a : b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回最大的一个数字</span></span><br><span class="line"><span class="keyword">var</span> findBiggestNumber = <span class="function">(<span class="params">arr</span>) =&gt;</span> R.reduce(getBiggerNumber, <span class="number">0</span>, arr);</span><br></pre></td></tr></table></figure><p>然后，把基本运算合成为一个函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var getLongestWordLength &#x3D; R.pipe(</span><br><span class="line">  splitBySpace,</span><br><span class="line">  getLengthArr,</span><br><span class="line">  findBiggestNumber</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">getLongestWordLength(str) &#x2F;&#x2F; 11</span><br></pre></td></tr></table></figure><p>可以看到，整个运算由三个步骤构成，每个步骤都有语义化的名称，非常的清晰。这就是 <code>Pointfree</code> 风格的优势。</p><p><code>Ramda</code> 提供了很多现成的方法，可以直接使用这些方法，省得自己定义一些常用函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上面代码的另一种写法</span></span><br><span class="line"><span class="keyword">var</span> getLongestWordLength = R.pipe(</span><br><span class="line">  R.split(<span class="string">&quot; &quot;</span>),</span><br><span class="line">  R.map(R.length),</span><br><span class="line">  R.reduce(R.max, <span class="number">0</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="声明式与命令式代码"><a href="#声明式与命令式代码" class="headerlink" title="声明式与命令式代码"></a>声明式与命令式代码</h2><p>命令式代码的意思就是，我们通过编写一条又一条指令去让计算机执行一些动作，这其中一般都会涉及到很多繁杂的细节。</p><p>而声明式就要优雅很多了，我们通过写表达式的方式来声明我们想干什么，而不是通过一步一步的指示。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//命令式</span></span><br><span class="line"><span class="keyword">var</span> CEOs = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; companies.length; i++) &#123;</span><br><span class="line">  CEOs.push(companies[i].CEO);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明式</span></span><br><span class="line"><span class="keyword">var</span> CEOs = companies.map(<span class="function">(<span class="params">c</span>) =&gt;</span> c.CEO);</span><br></pre></td></tr></table></figure><h2 id="容器、Functor"><a href="#容器、Functor" class="headerlink" title="容器、Functor"></a>容器、Functor</h2><p>容器为函数式编程里普通的变量、对象、函数提供了一层极其强大的外衣，赋予了它们一些很惊艳的特性，就好像 <strong>Tony Stark</strong> 的钢铁外衣，<strong>Dva</strong> 的机甲，明日香的 2 号机一样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Container = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.__value = x;</span><br><span class="line">&#125;;</span><br><span class="line">Container.of = <span class="function">(<span class="params">x</span>) =&gt;</span> <span class="keyword">new</span> Container(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">//试试看</span></span><br><span class="line">Container.of(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//=&gt; Container(1)</span></span><br><span class="line"></span><br><span class="line">Container.of(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line"><span class="comment">//=&gt; Container(&#x27;abcd&#x27;)</span></span><br></pre></td></tr></table></figure><p>我们调用 <code>Container.of</code> 把东西装进容器里之后，由于这一层外壳的阻挡，普通的函数就对他们不再起作用了，所以我们需要加一个接口来让外部的函数也能作用到容器里面的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Container.prototype.map = <span class="function"><span class="keyword">function</span> (<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Container.of(f(<span class="built_in">this</span>.__value));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以这样使用它：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Container.of(<span class="number">3</span>)</span><br><span class="line">  .map(<span class="function">(<span class="params">x</span>) =&gt;</span> x + <span class="number">1</span>) <span class="comment">//=&gt; Container(4)</span></span><br><span class="line">  .map(<span class="function">(<span class="params">x</span>) =&gt;</span> <span class="string">&quot;Result is &quot;</span> + x); <span class="comment">//=&gt; Container(&#x27;Result is 4&#x27;)</span></span><br></pre></td></tr></table></figure><p>没错！我们仅花了 7 行代码就实现了很炫的 <strong>『链式调用』</strong> ，这也是我们的第一个 <code>Functor</code>。</p><p><strong><code>Functor</code>（函子）是实现了 <code>map</code> 并遵守一些特定规则的容器类型。</strong></p><p>也就是说，如果我们要将普通函数应用到一个被容器包裹的值，那么我们首先需要定义一个叫 <code>Functor</code> 的数据类型，在这个数据类型中需要定义如何使用 <code>map</code> 来应用这个普通函数。</p><p>把东西装进一个容器，只留出一个接口 <code>map</code> 给容器外的函数，这么做有什么好处呢？</p><p>本质上，<code>Functor</code> 是一个对于函数调用的抽象，我们赋予容器自己去调用函数的能力。当 <code>map</code> 一个函数时，我们让容器自己来运行这个函数，这样容器就可以自由地选择何时何地如何操作这个函数，以致于拥有惰性求值、错误处理、异步调用等等非常牛掰的特性。</p><h3 id="Maybe"><a href="#Maybe" class="headerlink" title="Maybe"></a>Maybe</h3><p>举个例子，我们现在为 <code>map</code> 函数添加一个检查空值的特性，这个新的容器我们称之为 <code>Maybe</code>（原型来自于 Haskell）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Maybe = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.__value = x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Maybe.of = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Maybe(x);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Maybe.prototype.map = <span class="function"><span class="keyword">function</span> (<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.isNothing() ? Maybe.of(<span class="literal">null</span>) : Maybe.of(f(<span class="built_in">this</span>.__value));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Maybe.prototype.isNothing = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.__value === <span class="literal">null</span> || <span class="built_in">this</span>.__value === <span class="literal">undefined</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//试试看</span></span><br><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">&quot;lodash&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> add = _.curry(_.add);</span><br><span class="line"></span><br><span class="line">Maybe.of(&#123; <span class="attr">name</span>: <span class="string">&quot;Stark&quot;</span> &#125;).map(_.prop(<span class="string">&quot;age&quot;</span>)).map(add(<span class="number">10</span>));</span><br><span class="line"><span class="comment">//=&gt; Maybe(null)</span></span><br><span class="line"></span><br><span class="line">Maybe.of(&#123; <span class="attr">name</span>: <span class="string">&quot;Stark&quot;</span>, <span class="attr">age</span>: <span class="number">21</span> &#125;).map(_.prop(<span class="string">&quot;age&quot;</span>)).map(add(<span class="number">10</span>));</span><br><span class="line"><span class="comment">//=&gt; Maybe(31)</span></span><br></pre></td></tr></table></figure><p>有了柯里化这个强大的工具，我们可以这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">&quot;lodash&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> compose = _.flowRight;</span><br><span class="line"><span class="keyword">var</span> add = _.curry(_.add);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创造一个柯里化的 map</span></span><br><span class="line"><span class="keyword">var</span> map = _.curry(<span class="function">(<span class="params">f, functor</span>) =&gt;</span> functor.map(f));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> doEverything = map(compose(add(<span class="number">10</span>), _.property(<span class="string">&quot;age&quot;</span>)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> functor = Maybe.of(&#123; <span class="attr">name</span>: <span class="string">&quot;Stark&quot;</span>, <span class="attr">age</span>: <span class="number">21</span> &#125;);</span><br><span class="line">doEverything(functor);</span><br><span class="line"><span class="comment">//=&gt; Maybe(31)</span></span><br></pre></td></tr></table></figure><h3 id="错误处理、Either"><a href="#错误处理、Either" class="headerlink" title="错误处理、Either"></a>错误处理、Either</h3><p>如果你对 Promise 熟悉的话应该还记得，Promise 是可以调用 catch 来集中处理错误的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">doSomething()</span><br><span class="line">  .then(async1)</span><br><span class="line">  .then(async2)</span><br><span class="line">  .catch(<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">console</span>.log(e));</span><br></pre></td></tr></table></figure><p>对于函数式编程我们也可以做同样的操作，如果运行正确，那么就返回正确的结果；如果错误，就返回一个用于描述错误的结果。这个概念在 <code>Haskell</code> 中称之为 <code>Either</code> 类，<code>Left</code> 和 <code>Right</code> 是它的两个子类。我们用 JS 来实现一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里是一样的=。=</span></span><br><span class="line"><span class="keyword">var</span> Left = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.__value = x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> Right = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.__value = x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里也是一样的=。=</span></span><br><span class="line">Left.of = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Left(x);</span><br><span class="line">&#125;;</span><br><span class="line">Right.of = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Right(x);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里不同！！！</span></span><br><span class="line">Left.prototype.map = <span class="function"><span class="keyword">function</span> (<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Right.prototype.map = <span class="function"><span class="keyword">function</span> (<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Right.of(f(<span class="built_in">this</span>.__value));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>Left</code> 和 <code>Right</code> 唯一的区别就在于 <code>map</code> 方法的实现，<code>Right.map</code> 的行为和我们之前提到的 <code>map</code> 函数一样。但是 <code>Left.map</code> 就很不同了：<strong>它不会对容器做任何事情，只是很简单地把这个容器拿进来又扔出去。这个特性意味着，<code>Left</code> 可以用来传递一个错误消息。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getAge = <span class="function">(<span class="params">user</span>) =&gt;</span> (user.age ? Right.of(user.age) : Left.of(<span class="string">&quot;ERROR!&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//试试</span></span><br><span class="line">getAge(&#123; <span class="attr">name</span>: <span class="string">&quot;stark&quot;</span>, <span class="attr">age</span>: <span class="string">&quot;21&quot;</span> &#125;).map(<span class="function">(<span class="params">age</span>) =&gt;</span> <span class="string">&quot;Age is &quot;</span> + age);</span><br><span class="line"><span class="comment">//=&gt; Right(&#x27;Age is 21&#x27;)</span></span><br><span class="line"></span><br><span class="line">getAge(&#123; <span class="attr">name</span>: <span class="string">&quot;stark&quot;</span> &#125;).map(<span class="function">(<span class="params">age</span>) =&gt;</span> <span class="string">&quot;Age is &quot;</span> + age);</span><br><span class="line"><span class="comment">//=&gt; Left(&#x27;ERROR!&#x27;)</span></span><br></pre></td></tr></table></figure><p>是的，<code>Left</code> 可以让调用链中任意一环的错误立刻返回到调用链的尾部，这给我们错误处理带来了很大的方便，再也不用一层又一层的 <code>try/catch</code>。</p><p><code>Left</code> 和 <code>Right</code> 是 <code>Either</code> 类的两个子类，事实上 <code>Either</code> 并不只是用来做错误处理的，它表示了逻辑或，范畴学里的 <code>Coproduct</code>。但这些超出了我们的讨论范围。</p><h3 id="惰性求值-IO-URL"><a href="#惰性求值-IO-URL" class="headerlink" title="惰性求值 IO, URL"></a>惰性求值 IO, URL</h3><p>下面我们的程序要走出象牙塔，去接触外面“肮脏”的世界了，在这个世界里，很多事情都是有副作用的或者依赖于外部环境的，比如下面这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readLocalStorage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">window</span>.localStorage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了让它“纯”起来，我们可以把它包裹在一个函数内部，延迟执行它</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readLocalStorage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">window</span>.localStorage;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>额……好吧……好像确实没什么卵用……我们只是（像大多数拖延症晚期患者那样）把讨厌做的事情暂时搁置了而已。为了能彻底解决这些讨厌的事情，我们需要一个叫 <code>IO</code> 的新的 <code>Functor</code>：</p><h4 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">&quot;lodash&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> compose = _.flowRight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> IO = <span class="function"><span class="keyword">function</span> (<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.__value = f;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">IO.of = <span class="function">(<span class="params">x</span>) =&gt;</span> <span class="keyword">new</span> IO(<span class="function">(<span class="params">_</span>) =&gt;</span> x);</span><br><span class="line"></span><br><span class="line">IO.prototype.map = <span class="function"><span class="keyword">function</span> (<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> IO(compose(f, <span class="built_in">this</span>.__value));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>IO</code> 跟前面那几个 <code>Functor</code> 不同的地方在于，它的 <code>__value</code> 是一个函数。它把不纯的操作（比如 IO、网络请求、DOM）包裹到一个函数内，从而延迟这个操作的执行。所以我们认为，<code>IO</code> 包含的是被包裹的操作的返回值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> io_document = <span class="keyword">new</span> IO(<span class="function">(<span class="params">_</span>) =&gt;</span> <span class="built_in">window</span>.document);</span><br><span class="line"></span><br><span class="line">io_document.map(<span class="function"><span class="keyword">function</span> (<span class="params">doc</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> doc.title;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//=&gt; IO(document.title)</span></span><br></pre></td></tr></table></figure><p>注意我们这里虽然感觉上返回了一个实际的值 <code>IO(document.title)</code>，但事实上只是一个对象：<code>&#123; __value: [Function] &#125;</code>，它并没有执行，而是简单地把我们想要的操作存了起来，只有当我们在真的需要这个值得时候，<code>IO</code> 才会真的开始求值，这个特性我们称之为『惰性求值』。</p><h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">&quot;lodash&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先来几个基础函数：</span></span><br><span class="line"><span class="comment">// 字符串</span></span><br><span class="line"><span class="keyword">var</span> split = _.curry(<span class="function">(<span class="params">char, str</span>) =&gt;</span> str.split(char));</span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">var</span> first = <span class="function">(<span class="params">arr</span>) =&gt;</span> arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> last = <span class="function">(<span class="params">arr</span>) =&gt;</span> arr[arr.length - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> filter = _.curry(<span class="function">(<span class="params">f, arr</span>) =&gt;</span> arr.filter(f));</span><br><span class="line"><span class="comment">//注意这里的 x 既可以是数组，也可以是 functor</span></span><br><span class="line"><span class="keyword">var</span> map = _.curry(<span class="function">(<span class="params">f, x</span>) =&gt;</span> x.map(f));</span><br><span class="line"><span class="comment">// 判断</span></span><br><span class="line"><span class="keyword">var</span> eq = _.curry(<span class="function">(<span class="params">x, y</span>) =&gt;</span> x == y);</span><br><span class="line"><span class="comment">// 结合</span></span><br><span class="line"><span class="keyword">var</span> compose = _.flowRight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> toPairs = compose(map(split(<span class="string">&quot;=&quot;</span>)), split(<span class="string">&quot;&amp;&quot;</span>));</span><br><span class="line"><span class="comment">// toPairs(&#x27;a=1&amp;b=2&#x27;)</span></span><br><span class="line"><span class="comment">//=&gt; [[&#x27;a&#x27;, &#x27;1&#x27;], [&#x27;b&#x27;, &#x27;2&#x27;]]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> params = compose(toPairs, last, split(<span class="string">&quot;?&quot;</span>));</span><br><span class="line"><span class="comment">// params(&#x27;http://xxx.com?a=1&amp;b=2&#x27;)</span></span><br><span class="line"><span class="comment">//=&gt; [[&#x27;a&#x27;, &#x27;1&#x27;], [&#x27;b&#x27;, &#x27;2&#x27;]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里会有些难懂=。= 慢慢看</span></span><br><span class="line"><span class="comment">// 1.首先，getParam是一个接受IO(url)，返回一个新的接受 key 的函数；</span></span><br><span class="line"><span class="comment">// 2.我们先对 url 调用 params 函数，得到类似[[&#x27;a&#x27;, &#x27;1&#x27;], [&#x27;b&#x27;, &#x27;2&#x27;]]</span></span><br><span class="line"><span class="comment">//   这样的数组；</span></span><br><span class="line"><span class="comment">// 3.然后调用 filter(compose(eq(key), first))，这是一个过滤器，过滤的</span></span><br><span class="line"><span class="comment">//   条件是 compose(eq(key), first) 为真，它的意思就是只留下首项为 key</span></span><br><span class="line"><span class="comment">//   的数组；</span></span><br><span class="line"><span class="comment">// 4.最后调用 Maybe.of，把它包装起来。</span></span><br><span class="line"><span class="comment">// 5.这一系列的调用是针对 IO 的，所以我们用 map 把这些调用封装起来。</span></span><br><span class="line"><span class="keyword">var</span> getParam = <span class="function">(<span class="params">url</span>) =&gt;</span> <span class="function">(<span class="params">key</span>) =&gt;</span></span><br><span class="line">  map(compose(Maybe.of, filter(compose(eq(key), first)), params))(url);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建充满了洪荒之力的 IO！！！</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="keyword">new</span> IO(<span class="function">(<span class="params">_</span>) =&gt;</span> <span class="built_in">window</span>.location.href);</span><br><span class="line"><span class="comment">// 最终的调用函数！！！</span></span><br><span class="line"><span class="keyword">var</span> findParam = getParam(url);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的代码都是很干净的纯函数，下面我们来对它求值，求值的过程是非纯的。</span></span><br><span class="line"><span class="comment">// 假设现在的 url 是 http://xxx.com?a=1&amp;b=2</span></span><br><span class="line"><span class="comment">// 调用 __value() 来运行它！</span></span><br><span class="line">findParam(<span class="string">&quot;a&quot;</span>).__value();</span><br><span class="line"><span class="comment">//=&gt; Maybe([&#x27;a&#x27;, &#x27;1&#x27;])</span></span><br></pre></td></tr></table></figure><h2 id="Monad"><a href="#Monad" class="headerlink" title="Monad"></a>Monad</h2><p>如果你对 <code>Promise</code> 这种规范有了解的话，应该记得 <code>Promise</code> 里一个很惊艳的特性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">doSomething()</span><br><span class="line">  .then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 你可以return一个Promise链！</span></span><br><span class="line">    <span class="keyword">return</span> fetch(<span class="string">&quot;url&quot;</span>).then(<span class="function">(<span class="params">result</span>) =&gt;</span> parseBody(result));</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这里的result是上面那个Promise的终值</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">doSomething()</span><br><span class="line">  .then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 也可以直接return一个具体的值！</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// result === 123</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>对于 <code>Promise</code> 的一个回调函数来说，它既可以直接返回一个值，也可以返回一个新的 <code>Promise</code>，但对于他们后续的回调函数来说，这二者都是等价的，这就很巧妙地解决了 <code>nodejs</code> 里被诟病已久的嵌套地狱。</p><p>事实上，<code>Promise</code> 就是一种 <code>Monad</code>，是的，可能你天天要写一大堆 <code>Promise</code>，可直到现在才知道天天用的这个东西竟然是个听起来很高大上的函数式概念。</p><p>下面我们来实际实现一个 <code>Monad</code>，如果你不想看的话，只要记住 <strong>『<code>Promise</code> 就是一种 <code>Monad</code>』</strong> 这句话然后直接跳过这一章就好了。</p><p>我们来写一个函数 <code>cat</code>，这个函数的作用和 <code>Linux</code> 命令行下的 <code>cat</code> 一样，读取一个文件，然后打出这个文件的内容，这里 <code>IO</code> 的实现请参考上一篇文章：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">&quot;fs&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">&quot;lodash&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> map = _.curry(<span class="function">(<span class="params">f, x</span>) =&gt;</span> x.map(f));</span><br><span class="line"><span class="keyword">var</span> compose = _.flowRight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> readFile = <span class="function"><span class="keyword">function</span> (<span class="params">filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> IO(<span class="function">(<span class="params">_</span>) =&gt;</span> fs.readFileSync(filename, <span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> print = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> IO(<span class="function">(<span class="params">_</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat = compose(map(print), readFile);</span><br><span class="line"></span><br><span class="line">cat(<span class="string">&quot;file&quot;</span>);</span><br><span class="line"><span class="comment">//=&gt; IO(IO(&quot;file的内容&quot;))</span></span><br></pre></td></tr></table></figure><p>由于这里涉及到两个 <code>IO</code>：读取文件和打印，所以最后结果就是我们得到了两层 <code>IO</code>，想要运行它，只能调用：</p><p><code>cat(&quot;file&quot;).__value().__value();</code></p><p>很尴尬对吧，如果我们涉及到 100 个 <code>IO</code> 操作，那么难道要连续写 100 个 <code>__value()</code> 吗？</p><p>当然不能这样不优雅，我们来实现一个 <code>join</code> 方法，它的作用就是剥开一层 <code>Functor</code>，把里面的东西暴露给我们：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> join = <span class="function">(<span class="params">x</span>) =&gt;</span> x.join();</span><br><span class="line">IO.prototype.join = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.__value ? IO.of(<span class="literal">null</span>) : <span class="built_in">this</span>.__value();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 试试看</span></span><br><span class="line"><span class="keyword">var</span> foo = IO.of(IO.of(<span class="string">&quot;123&quot;</span>));</span><br><span class="line"></span><br><span class="line">foo.join();</span><br><span class="line"><span class="comment">//=&gt; IO(&#x27;123&#x27;)</span></span><br></pre></td></tr></table></figure><p>有了 <code>join</code> 方法之后，就稍微优雅那么一点儿了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cat = compose(join, map(print), readFile);</span><br><span class="line">cat(<span class="string">&quot;file&quot;</span>).__value();</span><br><span class="line"><span class="comment">//=&gt; 读取文件并打印到控制台</span></span><br></pre></td></tr></table></figure><p><code>join</code> 方法可以把 <code>Functor</code> 拍平（flatten），我们一般把具有这种能力的 <code>Functor</code> 称之为 <code>Monad</code>。</p><p>这里只是非常简单地移除了一层 <code>Functor</code> 的包装，但作为优雅的程序员，我们不可能总是在 <code>map</code> 之后手动调用 <code>join</code> 来剥离多余的包装，否则代码会长得像这样：</p><p><code>var doSomething = compose(join, map(f), join, map(g), join, map(h));</code></p><p>所以我们需要一个叫 <code>chain</code> 的方法来实现我们期望的链式调用，它会在调用 <code>map</code> 之后自动调用 <code>join</code> 来去除多余的包装，这也是 <code>Monad</code> 的一大特性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> chain = _.curry(<span class="function">(<span class="params">f, functor</span>) =&gt;</span> functor.chain(f));</span><br><span class="line">IO.prototype.chain = <span class="function"><span class="keyword">function</span> (<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.map(f).join();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在可以这样调用了</span></span><br><span class="line"><span class="keyword">var</span> doSomething = compose(chain(f), chain(g), chain(h));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当然，也可以这样</span></span><br><span class="line">someMonad.chain(f).chain(g).chain(h);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写成这样是不是很熟悉呢？</span></span><br><span class="line">readFile(<span class="string">&quot;file&quot;</span>)</span><br><span class="line">  .chain(</span><br><span class="line">    (x) =&gt;</span><br><span class="line">      <span class="keyword">new</span> IO(<span class="function">(<span class="params">_</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(x);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">      &#125;)</span><br><span class="line">  )</span><br><span class="line">  .chain(</span><br><span class="line">    (x) =&gt;</span><br><span class="line">      <span class="keyword">new</span> IO(<span class="function">(<span class="params">_</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 对x做一些事情，然后返回</span></span><br><span class="line">      &#125;)</span><br><span class="line">  );</span><br></pre></td></tr></table></figure><p>你可能看出来了，<code>chain</code> 不就类似 <code>Promise</code> 中的 <code>then</code> 吗？是的，它们行为上确实是一致的（<code>then</code> 会稍微多一些逻辑，它会记录嵌套的层数以及区别 <code>Promise</code> 和普通返回值），<code>Promise</code> 也确实是一种函数式的思想。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引用&quot;&gt;&lt;a href=&quot;#引用&quot; class=&quot;headerlink&quot; title=&quot;引用&quot;&gt;&lt;/a&gt;引用&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/21714695&quot;&gt;JavaScript 函数式编程</summary>
      
    
    
    
    <category term="函数式" scheme="https://hqwuzhaoyi.github.io/categories/%E5%87%BD%E6%95%B0%E5%BC%8F/"/>
    
    
    <category term="函数式" scheme="https://hqwuzhaoyi.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>webpack 笔记</title>
    <link href="https://hqwuzhaoyi.github.io/2021/07/20/webpack/webpack%E7%AC%94%E8%AE%B0/"/>
    <id>https://hqwuzhaoyi.github.io/2021/07/20/webpack/webpack%E7%AC%94%E8%AE%B0/</id>
    <published>2021-07-20T00:00:00.000Z</published>
    <updated>2022-08-29T03:13:16.656Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Webpack-核心原理"><a href="#Webpack-核心原理" class="headerlink" title="Webpack 核心原理"></a>Webpack 核心原理</h2><p><a href="https://zhuanlan.zhihu.com/p/363928061">一文吃透 Webpack 核心原理</a></p><h3 id="主体框架"><a href="#主体框架" class="headerlink" title="主体框架"></a>主体框架</h3><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210720223438.jpg" alt="主体框架"></p><h3 id="核心流程解析"><a href="#核心流程解析" class="headerlink" title="核心流程解析"></a>核心流程解析</h3><ol><li>初始化阶段<ol><li>初始化参数：从配置文件、 配置对象、Shell 参数中读取，与默认配置结合得出最终的参数</li><li>创建编译器对象：用上一步得到的参数创建 <code>Compiler</code> 对象</li><li>初始化编译环境：包括注入内置插件、注册各种模块工厂、初始化 RuleSet 集合、加载配置的插件等</li><li>开始编译：执行 <code>Compiler</code> 对象的 <code>run</code> 方法</li><li>确定入口：根据配置中的 entry 找出所有的入口文件，调用 <code>compilation.addEntry</code> 将入口文件转换为 <code>dependence</code> 对象</li></ol></li><li>构建阶段<ol><li>编译模块(make)：根据 entry 对应的 <code>dependence</code> 创建 <code>module</code> 对象，调用 <code>loader</code> 将模块转译为标准 JS 内容，调用 JS 解释器将内容转换为 AST 对象，从中找出该模块依赖的模块，再 递归 本步骤直到所有入口依赖的文件都经过了本步骤的处理</li><li>完成模块编译：上一步递归处理所有能触达到的模块后，得到了每个模块被翻译后的内容以及它们之间的 依赖关系图</li></ol></li><li>生成阶段<ol><li>输出资源(seal)：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 <code>Chunk</code>，再把每个 <code>Chunk</code> 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会</li><li>写入文件系统(emitAssets)：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统</li></ol></li></ol><p>技术名词介绍</p><ul><li>Entry：编译入口，webpack 编译的起点</li><li>Compiler：编译管理器，webpack 启动后会创建 <code>compiler</code> 对象，该对象一直存活知道结束退出</li><li>Compilation：单次编辑过程的管理器，比如 watch = true 时，运行过程中只有一个 <code>compiler</code> 但每次文件变更触发重新编译时，都会创建一个新的 <code>compilation</code> 对象</li><li>Dependence：依赖对象，webpack 基于该类型记录模块间依赖关系</li><li>Module：webpack 内部所有资源都会以<code>module</code>对象形式存在，所有关于资源的操作、转译、合并都是以 <code>module</code> 为基本单位进行的</li><li>Chunk：编译完成准备输出时，webpack 会将 <code>module</code> 按特定的规则组织成一个一个的 <code>chunk</code>，这些 <code>chunk</code> 某种程度上跟最终输出一一对应</li><li>Loader：资源内容转换器，其实就是实现从内容 A 转换 B 的转换器</li><li>Plugin：webpack 构建过程中，会在特定的时机广播对应的事件，插件监听这些事件，在特定时间点介入编译过程</li></ul><h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210720225459.jpg" alt="初始化阶段"></p><h3 id="构建阶段"><a href="#构建阶段" class="headerlink" title="构建阶段"></a>构建阶段</h3><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210720230409.jpg" alt="构建阶段"></p><h3 id="生成阶段"><a href="#生成阶段" class="headerlink" title="生成阶段"></a>生成阶段</h3><p><code>seal</code> 原意密封、上锁，我个人理解在 webpack 语境下接近于 “将模块装进蜜罐” 。seal 函数主要完成从 <code>module</code> 到 <code>chunks</code> 的转化，核心流程：</p><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210720230659.jpg" alt="生成阶段"></p><h3 id="资源形态流转"><a href="#资源形态流转" class="headerlink" title="资源形态流转"></a>资源形态流转</h3><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210720231219.jpg" alt="资源形态流转"></p><ul><li><code>compiler.make</code> phase：<ul><li>entry 文件以 <code>dependence</code> 对象形式加入 <code>compilation</code> 的依赖列表，<code>dependence</code> 对象记录有 <code>entry</code> 的类型、路径等信息</li><li>根据 <code>dependence</code> 调用对应的工厂函数创建 <code>module</code> 对象，之后读入 <code>module</code> 对应的文件内容，调用 <code>loader-runner</code> 对内容做转化，转化结果若有其它依赖则继续读入依赖资源，重复此过程直到所有依赖均被转化为 <code>module</code></li></ul></li><li><code>compilation.seal</code> phase：<ul><li>遍历 <code>module</code> 集合，根据 <code>entry</code> 配置及引入资源的方式，将 <code>module</code> 分配到不同的 <code>chunk</code></li><li>遍历 <code>chunk</code> 集合，调用 <code>compilation.emitAsset</code> 方法标记 <code>chunk</code> 的输出规则，即转化为 <code>assets</code> 集合</li></ul></li><li><code>compiler.emitAssets</code> phase：<ul><li>将 <code>assets</code> 写入文件系统</li></ul></li></ul><h2 id="Webpack-插件架构深度讲解"><a href="#Webpack-插件架构深度讲解" class="headerlink" title="Webpack 插件架构深度讲解"></a>Webpack 插件架构深度讲解</h2><p><a href="https://zhuanlan.zhihu.com/p/367931462">[源码解读] Webpack 插件架构深度讲解</a></p><h3 id="Tapable-全解析"><a href="#Tapable-全解析" class="headerlink" title="Tapable 全解析"></a>Tapable 全解析</h3><p>Tapable 是 Webpack 插件架构的核心支架，但它的源码量其实很少，本质上就是围绕着 订阅/发布 模式叠加各种特化逻辑，适配 webpack 体系下复杂的事件源-处理器之间交互需求，比有些场景需要支持将前一个处理器的结果传入下一个回调处理器；有些场景需要支持异步并行调用这些回调处理器。</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>Tapable 使用时通常需要经历如下步骤：</p><ul><li>创建钩子实例</li><li>调用订阅接口注册回调，包括：<code>tap</code>、<code>tapAsync</code>、<code>tapPromise</code></li><li>调用发布接口触发回调，包括：<code>call</code>、<code>callAsync</code>、<code>promise</code></li></ul><p>example</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; SyncHook &#125; = <span class="built_in">require</span>(<span class="string">&quot;tapable&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 创建钩子实例</span></span><br><span class="line"><span class="keyword">const</span> sleep = <span class="keyword">new</span> SyncHook();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 调用订阅接口注册回调</span></span><br><span class="line">sleep.tap(<span class="string">&quot;test&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;callback A&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 调用发布接口触发回调</span></span><br><span class="line">sleep.call();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="comment">// callback A</span></span><br></pre></td></tr></table></figure><p>示例中使用 <code>tap</code> 注册回调，使用 <code>call</code> 触发回调，在某些钩子中还可以使用异步风格的 <code>tapAsync/callAsync</code>、promise 风格 <code>tapPromise/promise</code>，具体使用哪一类函数与钩子类型有关。</p><h3 id="Tapable-钩子类型"><a href="#Tapable-钩子类型" class="headerlink" title="Tapable 钩子类型"></a>Tapable 钩子类型</h3><table><thead><tr><th>名称</th><th>简介</th><th>统计</th></tr></thead><tbody><tr><td>SyncHook</td><td>同步钩子</td><td>Webpack 共出现 86 次，如 Compiler.hooks.compilation</td></tr><tr><td>SyncBailHook</td><td>同步熔断钩子</td><td>Webpack 共出现 90 次，如 Compiler.hooks.shouldEmit</td></tr><tr><td>SyncWaterfallHook</td><td>同步瀑布流钩子</td><td>Webpack 共出现 26 次，如 Compilation.hooks.assetPath</td></tr><tr><td>SyncLoopHook</td><td>同步循环钩子</td><td>Webpack 中未使用</td></tr><tr><td>AsyncParallelHook</td><td>异步并行钩子</td><td>Webpack 仅出现 6 次：Compiler.hooks.make</td></tr><tr><td>AsyncParallelBailHook</td><td>异步并行熔断钩子</td><td>Webpack 中未使用</td></tr><tr><td>AsyncSeriesHook</td><td>异步串行钩子</td><td>Webpack 共出现 32 次，如 Compiler.hooks.done</td></tr><tr><td>AsyncSeriesBailHook</td><td>异步串行熔断钩子</td><td>Webpack 共出现 9 次，如 Compilation.hooks.optimizeChunkModules</td></tr><tr><td>AsyncSeriesLoopHook</td><td>异步串行循环钩子</td><td>Webpack 中未使用</td></tr><tr><td>AsyncSeriesWaterfallHook</td><td>异步串行瀑布流钩子</td><td>Webpack 共出现 3 次，如 ContextModuleFactory.hooks.beforeResolve</td></tr></tbody></table><p>按回调逻辑，分为：</p><ul><li>基本类型，名称不带 <code>Waterfall</code>/<code>Bail</code>/<code>Loop</code> 关键字，与通常 「订阅/回调」 模式相似，按钩子注册顺序，逐次调用回调<ol><li><code>waterfall</code> 类型：前一个回调的返回值会被带入下一个回调</li><li><code>bail</code> 类型：逐次调用回调，若有任何一个回调返回非 undefined 值，则终止后续调用</li><li><code>loop</code> 类型：逐次、循环调用，直到所有回调函数都返回 undefined</li></ol></li><li>第二个维度，按执行回调的并行方式，分为：<ol><li><code>sync</code> ：同步执行，启动后会按次序逐个执行回调，支持 <code>call</code>/<code>tap</code> 调用语句</li><li><code>async</code> ：异步执行，支持传入 callback 或 promise 风格的异步回调函数，支持 <code>callAsync/tapAsync</code> 、<code>promise/tapPromise</code> 两种调用语句</li></ol></li></ul><h2 id="Dependency-Graph-深度解析"><a href="#Dependency-Graph-深度解析" class="headerlink" title="Dependency Graph 深度解析"></a>Dependency Graph 深度解析</h2><p><a href="https://zhuanlan.zhihu.com/p/369953304">有点难的 Webpack 知识点：Dependency Graph 深度解析</a></p><p>webpack 处理应用代码时，会从开发者提供的 <code>entry</code> 开始递归地组建起包含所有模块的 <code>Dependency Graph</code> ，之后再将这些 <code>module</code> 打包为 <code>bundles</code> 。</p><h3 id="Dependency-Graph"><a href="#Dependency-Graph" class="headerlink" title="Dependency Graph"></a>Dependency Graph</h3><p>本节将深入 webpack 源码，解读 Dependency Graph 的内在数据结构及依赖关系收集过程。在正式展开之前，有必要回顾几个 webpack 重要的概念：</p><ul><li><code>Module</code> ：资源在 webpack 内部的映射对象，包含了资源的路径、上下文、依赖、内容等信息</li><li><code>Dependency</code> ：在模块中引用其它模块，例如 <code>import &quot;a.js&quot;</code> 语句，webpack 会先将引用关系表述为 <code>Dependency</code> 子类并关联 <code>module</code> 对象，等到当前 <code>module</code> 内容都解析完毕之后，启动下次循环开始将 <code>Dependency</code> 对象转换为适当的 <code>Module</code> 子类。</li><li><code>Chunk</code> ：用于组织输出结构的对象，webpack 分析完所有模块资源的内容，构建出完整的 <code>Dependency Graph</code> 之后，会根据用户配置及 <code>Dependency Graph</code> 内容构建出一个或多个 <code>chunk</code> 实例，每个 <code>chunk</code> 与最终输出的文件大致上是一一对应的。</li></ul><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>Webpack 4.x 的 <code>Dependency Graph</code> 实现较简单，主要由 Dependence/Module 内置的系列属性记录引用、被引用关系。</p><p>而 Webpack 5.0 之后则实现了一套相对复杂的类结构记录模块间依赖关系，将模块依赖相关的逻辑从 Dependence/Module 解耦为一套独立的类型结构，主要类型有：</p><ul><li><code>ModuleGraph</code> ：记录 <code>Dependency Graph</code> 信息的容器，一方面保存了构建过程中涉及到的所有 <code>module</code> <code>、dependency</code> 对象，以及这些对象互相之间的引用；另一方面提供了各种工具方法，方便使用者迅速读取出 <code>module</code> 或 <code>dependency</code> 附加的信息</li><li><code>ModuleGraphConnection</code> ：记录模块间引用关系的数据结构，内部通过 <code>originModule</code> 属性记录引用关系中的父模块，通过 <code>module</code> 属性记录子模块。此外还提供了一系列函数工具用于判断对应的引用关系的有效性</li><li><code>ModuleGraphModule</code> ：Module 对象在 <code>Dependency Graph</code> 体系下的补充信息，包含模块对象的 <code>incomingConnections</code> —— 指向模块本身的 <code>ModuleGraphConnection</code> 集合，即谁引用了模块自己；<code>outgoingConnections</code> —— 该模块对外的依赖，即该模块引用了其他那些模块。</li></ul><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210720232835.jpg" alt="Dependency Graph"></p><ul><li><code>ModuleGraph</code> 对象通过 <code>_dependencyMap</code> 属性记录 <code>Dependency</code> 对象与 <code>ModuleGraphConnection</code> 连接对象之间的映射关系，后续的处理中可以基于这层映射迅速找到 <code>Dependency</code> 实例对应的引用与被引用者</li><li><code>ModuleGraph</code> 对象通过 <code>_moduleMap</code> 在 <code>module</code> 基础上附加 <code>ModuleGraphModule</code> 信息，而 <code>ModuleGraphModule</code> 最大的作用就是记录了模块的引用与被引用关系，后续的处理可以基于该属性找到 <code>module</code> 实例的所有依赖与被依赖关系</li></ul><p><code>ModuleGraph</code>、<code>ModuleGraphConnection</code>、<code>ModuleGraphModule</code> 三者协作，在 webpack 构建过程(<code>make</code> 阶段)中逐步收集模块间的依赖关系</p><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210720232959.jpg" alt="依赖收集过程"></p><ul><li><code>addDependency</code> ：webpack 从模块内容中解析出引用关系后，创建适当的 <code>Dependency</code> 子类并调用该方法记录到 <code>module</code> 实例</li><li><code>handleModuleCreation</code> ：模块解析完毕后，webpack 遍历父模块的依赖集合，调用该方法创建 <code>Dependency</code> 对应的子模块对象，之后调用 <code>compilation.moduleGraph.setResolvedModule</code> 方法将父子引用信息记录到 <code>ModuleGraph</code> 对象上</li></ul><h3 id="实例解析"><a href="#实例解析" class="headerlink" title="实例解析"></a>实例解析</h3><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210720233135.jpg" alt="实例解析"></p><p>Webpack 启动后，在构建阶段递归调用 <code>compilation.handleModuleCreation</code> 函数，逐步补齐 <code>Dependency Graph</code> 结构，最终可能生成如下数据结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">ModuleGraph: &#123;</span><br><span class="line">    _dependencyMap: Map(3)&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            EntryDependency&#123;request: &quot;./src/index.js&quot;&#125; =&gt; ModuleGraphConnection&#123;</span><br><span class="line">                module: NormalModule&#123;request: &quot;./src/index.js&quot;&#125;,</span><br><span class="line">                // 入口模块没有引用者，故设置为 null</span><br><span class="line">                originModule: null</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            HarmonyImportSideEffectDependency&#123;request: &quot;./src/a.js&quot;&#125; =&gt; ModuleGraphConnection&#123;</span><br><span class="line">                module: NormalModule&#123;request: &quot;./src/a.js&quot;&#125;,</span><br><span class="line">                originModule: NormalModule&#123;request: &quot;./src/index.js&quot;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            HarmonyImportSideEffectDependency&#123;request: &quot;./src/a.js&quot;&#125; =&gt; ModuleGraphConnection&#123;</span><br><span class="line">                module: NormalModule&#123;request: &quot;./src/b.js&quot;&#125;,</span><br><span class="line">                originModule: NormalModule&#123;request: &quot;./src/index.js&quot;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    _moduleMap: Map(3)&#123;</span><br><span class="line">        NormalModule&#123;request: &quot;./src/index.js&quot;&#125; =&gt; ModuleGraphModule&#123;</span><br><span class="line">            incomingConnections: Set(1) [</span><br><span class="line">                // entry 模块，对应 originModule 为null</span><br><span class="line">                ModuleGraphConnection&#123; module: NormalModule&#123;request: &quot;./src/index.js&quot;&#125;, originModule:null &#125;</span><br><span class="line">            ],</span><br><span class="line">            outgoingConnections: Set(2) [</span><br><span class="line">                // 从 index 指向 a 模块</span><br><span class="line">                ModuleGraphConnection&#123; module: NormalModule&#123;request: &quot;./src/a.js&quot;&#125;, originModule: NormalModule&#123;request: &quot;./src/index.js&quot;&#125; &#125;,</span><br><span class="line">                // 从 index 指向 b 模块</span><br><span class="line">                ModuleGraphConnection&#123; module: NormalModule&#123;request: &quot;./src/b.js&quot;&#125;, originModule: NormalModule&#123;request: &quot;./src/index.js&quot;&#125; &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        NormalModule&#123;request: &quot;./src/a.js&quot;&#125; =&gt; ModuleGraphModule&#123;</span><br><span class="line">            incomingConnections: Set(1) [</span><br><span class="line">                ModuleGraphConnection&#123; module: NormalModule&#123;request: &quot;./src/a.js&quot;&#125;, originModule: NormalModule&#123;request: &quot;./src/index.js&quot;&#125; &#125;</span><br><span class="line">            ],</span><br><span class="line">            // a 模块没有其他依赖，故 outgoingConnections 属性值为 undefined</span><br><span class="line">            outgoingConnections: undefined</span><br><span class="line">        &#125;,</span><br><span class="line">        NormalModule&#123;request: &quot;./src/b.js&quot;&#125; =&gt; ModuleGraphModule&#123;</span><br><span class="line">            incomingConnections: Set(1) [</span><br><span class="line">                ModuleGraphConnection&#123; module: NormalModule&#123;request: &quot;./src/b.js&quot;&#125;, originModule: NormalModule&#123;request: &quot;./src/index.js&quot;&#125; &#125;</span><br><span class="line">            ],</span><br><span class="line">            // b 模块没有其他依赖，故 outgoingConnections 属性值为 undefined</span><br><span class="line">            outgoingConnections: undefined</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="module-issuer"><a href="#module-issuer" class="headerlink" title="module.issuer"></a>module.issuer</h2><p><a href="https://zhuanlan.zhihu.com/p/368391369">十分钟精进 Webpack：module.issuer 属性详解</a></p><p>在 webpack 实现上，文件资源使用 <code>Module</code> 类管理，所有关于资源的操作、转译、合并、关系都在 <code>module</code> 实现。而 <code>module.issuer</code> 属性用于记录资源的引用者，例如对于下面的资源依赖：</p><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210726160052.jpg" alt="modole issuer 资源依赖"></p><p><code>index</code> 引用了 <code>a/b</code> 两个文件，webpack 构建时会用三个 <code>module</code> 对象分别对应三个文件，同时在 <code>a/b</code> 模块中通过 <code>issuer</code> 属性指向 <code>index</code> 模块：</p><ul><li><code>module[&#39;a.js&#39;].issuer = module[&#39;index.js&#39;]</code></li><li><code>module[&#39;b.js&#39;].issuer = module[&#39;index.js&#39;]</code><br>通过 <code>issuer</code> 属性，模块可以反向查找到引用者。</li></ul><h3 id="实例：-Stats-类"><a href="#实例：-Stats-类" class="headerlink" title="实例： Stats 类"></a>实例： Stats 类</h3><p><code>Stats</code> 是 webpack 内置的对象，用于收集构建过程信息，比如耗时、模块依赖关系、错误信息、报警信息等，我们运行 webpack 命令输出的命令行信息就是由 <code>Stats</code> 类提供的</p><p>如果编译过程发生错误，<code>Stats</code> 会通过 <code>module.issuer</code> 属性逐级往上查找出完整调用堆栈</p><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210726160742.jpg" alt="Stats"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stats</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">compilation</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">toJson</span>(<span class="params">options, forToString</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> formatError = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">if</span> (showModuleTrace &amp;&amp; e.origin) &#123;</span><br><span class="line">        text += <span class="string">`\n @ <span class="subst">$&#123;<span class="built_in">this</span>.formatFilePath(</span></span></span><br><span class="line"><span class="string"><span class="subst">          e.origin.readableIdentifier(requestShortener)</span></span></span><br><span class="line"><span class="string"><span class="subst">        )&#125;</span>`</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">while</span> (current.issuer) &#123;</span><br><span class="line">          current = current.issuer;</span><br><span class="line">          text += <span class="string">`\n @ <span class="subst">$&#123;current.readableIdentifier(requestShortener)&#125;</span>`</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> text;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210726160604.jpg" alt="Stats 错误堆栈"></p><h3 id="何时修改-issuer"><a href="#何时修改-issuer" class="headerlink" title="何时修改 issuer"></a>何时修改 issuer</h3><p>在 <code>compilation</code> 解析出 <code>index.js</code> 内容的 <code>AST</code> 后，遍历 <code>require/import</code> 语句解读当前模块引用了那些资源，解析到任意依赖后就会调用 <code>addModuleDependencies</code> 记录依赖关系，从 <code>addModuleDependencies</code> 源码看在依赖被创建为 <code>module</code> 时，会同步修改新模块的 <code>issuer</code> ，记录引用者的信息。</p><h2 id="Webpack-Chunk-分包规则详解"><a href="#Webpack-Chunk-分包规则详解" class="headerlink" title="Webpack Chunk 分包规则详解"></a>Webpack Chunk 分包规则详解</h2><p><a href="https://zhuanlan.zhihu.com/p/371999555">Webpack Chunk 分包规则详解</a></p><p>webpack 实现中，原始的资源模块以 <code>Module</code> 对象形式存在、流转、解析处理。</p><p>而 <code>Chunk</code> 则是输出产物的基本组织单位，在生成阶段 webpack 按规则将 <code>entry</code> 及其它 <code>Module</code> 插入 <code>Chunk</code> 中，之后再由 <code>SplitChunksPlugin</code> 插件根据优化规则与 <code>ChunkGraph</code> 对 <code>Chunk</code> 做一系列的变化、拆解、合并操作，重新组织成一批性能(可能)更高的 <code>Chunks</code> 。运行完毕之后 webpack 继续将 <code>chunk</code> 一一写入物理文件中，完成编译工作。</p><p>综上，<code>Module</code> 主要作用在 webpack 编译过程的前半段，解决原始资源“<strong>「如何读」</strong>”的问题；而 <code>Chunk</code> 对象则主要作用在编译的后半段，解决编译产物“<strong>「如何写」</strong>”的问题，两者合作搭建起 webpack 搭建主流程。</p><h3 id="默认分包规则"><a href="#默认分包规则" class="headerlink" title="默认分包规则"></a>默认分包规则</h3><p>Webpack 4 之后编译过程大致上可以拆解为四个阶段</p><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210726163443.jpg" alt="四个阶段"></p><p>在构建(<code>make</code>) 阶段，webpack 从 <code>entry</code> 出发根据模块间的引用关系(<code>require/import</code>) 逐步构建出模块依赖关系图(<a href="#Dependency-Graph-%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90">ModuleDependencyGraph</a>)，依赖关系图表达了模块与模块之间互相引用的先后次序，基于这种次序 webpack 就可以推断出模块运行之前需要先执行那些依赖模块，也就可以进一步推断出那些模块应该打包在一起，那些模块可以延后加载(异步执行)，关于模块依赖图的更多信息，可以参考我另一篇文章 《有点难的 webpack 知识点：Dependency Graph 深度解析》。</p><p>到了生成(<code>seal</code>) 阶段，webpack 会根据模块依赖图的内容组织分包 —— <code>Chunk</code> 对象，默认的分包规则有：</p><ul><li>同一个 <code>entry</code> 下触达到的模块组织成一个 <code>chunk</code></li><li>异步模块单独组织为一个 <code>chunk</code></li><li><code>entry.runtime</code> 单独组织成一个 <code>chunk</code></li></ul><p>默认规则集中在 <code>compilation.seal</code> 函数实现，<code>seal</code> 核心逻辑运行结束后会生成一系列的 <code>Chunk</code>、<code>ChunkGroup</code>、<code>ChunkGraph</code> 对象，后续如 <code>SplitChunksPlugin</code> 插件会在 <code>Chunk</code> 系列对象上做进一步的拆解、优化，最终反映到输出上才会表现出复杂的分包结果。</p><h3 id="Entry-分包处理"><a href="#Entry-分包处理" class="headerlink" title="Entry 分包处理"></a>Entry 分包处理</h3><pre><code>重点：seal 阶段遍历 entry 对象，为每一个 entry 单独生成 chunk，之后再根据模块依赖图将 entry 触达到的所有模块打包进 chunk 中。</code></pre><p>在生成阶段，Webpack 首先根据遍历用户提供的 entry 属性值，为每一个 entry 创建 Chunk 对象，比如对于如下配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">&quot;./src/main&quot;</span>,</span><br><span class="line">    home: <span class="string">&quot;./src/home&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Webpack 遍历 entry 对象属性并创建出 <code>chunk[main]</code> <code>、chunk[home]</code> 两个对象，此时两个 chunk 分别包含 <code>main</code> <code>、home</code> 模块：</p><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210726164728.jpg" alt="chunk[main] 、chunk[home]"></p><p>初始化完毕后，Webpack 会读取 <code>ModuleDependencyGraph</code> 的内容，将 <code>entry</code> 所对应的内容塞入对应的 <code>chunk</code> (发生在 <code>webpack/lib/buildChunkGrap.js</code> 文件)。比如对于如下文件依赖：</p><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210726164819.jpg" alt="entry 所对应的内容塞入对应的 chunk"></p><p><code>main.js</code> 以同步方式直接或间接引用了 <code>a/b/c/d</code> 四个文件，分析 <code>ModuleDependencyGraph</code> 过程会逐步将 <code>a/b/c/d</code> 模块逐步添加到 <code>chunk[main]</code> 中，最终形成：</p><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210726164928.jpg" alt="Initial chunk"></p><h3 id="异步模块分包处理"><a href="#异步模块分包处理" class="headerlink" title="异步模块分包处理"></a>异步模块分包处理</h3><pre><code>重点：分析 ModuleDependencyGraph 时，每次遇到异步模块都会为之创建单独的 Chunk 对象，单独打包异步模块。</code></pre><p>Webpack 4 之后，只需要用异步语句 <code>require.ensure(&quot;./xx.js&quot;)</code> 或 <code>import(&quot;./xx.js&quot;)</code> 方式引入模块，就可以实现模块的动态加载，这种能力本质也是基于 <code>Chunk</code> 实现的。</p><p>Webpack 生成阶段中，遇到异步引入语句时会为该模块单独生成一个 <code>chunk</code> 对象，并将其子模块都加入这个 <code>chunk</code> 中。例如对于下面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js, entry 文件</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync-a&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync-b&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(<span class="string">&quot;async-c&quot;</span>);</span><br></pre></td></tr></table></figure><p>在 <code>index.js</code> 中，以同步方式引入 <code>sync-a</code>、<code>sync-b</code>；以异步方式引入 <code>async-a</code> 模块；同时，在 <code>async-c</code> 中以同步方式引入 <code>sync-c</code> 模块。对应的模块依赖如：</p><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210726165241.jpg" alt="async-c"></p><p>此时，webpack 会为入口 <code>index.js</code>、异步模块 <code>async-a.js</code> 分别创建分包，形成如下数据：</p><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210726165315.jpg" alt="创建分包"></p><p>里需要引入一个新的概念 —— <code>Chunk</code> 间的父子关系。由 <code>entry</code> 生成的 <code>Chunk</code> 之间相互孤立，没有必然的前后依赖关系，但异步生成的 <code>Chunk</code> 则不同，引用者(上例 <code>index.js</code> 块)需要在特定场景下使用被引用者(上例 <code>async-a</code> 块)，两者间存在单向依赖关系，在 webpack 中称引用者为 <code>parent</code>、被引用者为 <code>child</code>，分别存放在 <code>ChunkGroup._parents</code> <code>、ChunkGroup._children</code> 属性中。</p><p>上述分包方案默认情况下会生成两个文件：</p><ul><li>入口 <code>index</code> 对应的 <code>index.js</code></li><li>异步模块 <code>async-a</code> 对应的 <code>src_async-a_js.js</code></li></ul><p>运行时，webpack 在 index.js 中使用 promise 及 <code>__webpack_require__.e</code> 方法异步载入并运行文件 <code>src_async-a_js.js</code> ，从而实现动态加载。</p><p><em>PS</em>: 基于异步模块的 <code>chunk</code> 在 webpack 官方文档中，通常称之为 <strong>「Async chunk」</strong></p><h3 id="Runtime-分包"><a href="#Runtime-分包" class="headerlink" title="Runtime 分包"></a>Runtime 分包</h3><pre><code>重点： Webpack 5 之后还能根据 `entry.runtime` 配置单独打包运行时代码。</code></pre><p>除了 entry、异步模块外，webpack 5 之后还支持基于 <code>runtime</code> 的分包规则。除业务代码外，Webpack 编译产物中还需要包含一些用于支持 webpack 模块化、异步加载等特性的支撑性代码，这类代码在 webpack 中被统称为 <code>runtime</code>。举个例子，产物中通常会包含如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******/</span> (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// webpackBootstrap</span></span><br><span class="line">  <span class="comment">/******/</span> <span class="keyword">var</span> __webpack_modules__ = &#123;&#125;; <span class="comment">// The module cache</span></span><br><span class="line">  <span class="comment">/************************************************************************/</span></span><br><span class="line">  <span class="comment">/******/</span> <span class="comment">/******/</span> <span class="keyword">var</span> __webpack_module_cache__ = &#123;&#125;; <span class="comment">// The require function</span></span><br><span class="line">  <span class="comment">/******/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/******/</span> <span class="comment">/******/</span> <span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/******/</span> <span class="comment">/******/</span> __webpack_modules__[moduleId](</span><br><span class="line">      <span class="built_in">module</span>,</span><br><span class="line">      <span class="built_in">module</span>.exports,</span><br><span class="line">      __webpack_require__</span><br><span class="line">    ); <span class="comment">// Return the exports of the module</span></span><br><span class="line">    <span class="comment">/******/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/******/</span> <span class="comment">/******/</span> <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">    <span class="comment">/******/</span></span><br><span class="line">  &#125; <span class="comment">// expose the modules object (__webpack_modules__)</span></span><br><span class="line">  <span class="comment">/******/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/******/</span> <span class="comment">/******/</span> __webpack_require__.m =</span><br><span class="line">    __webpack_modules__; <span class="comment">/* webpack/runtime/compat get default export */</span></span><br><span class="line">  <span class="comment">/******/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>编译时，Webpack 会根据业务代码决定输出那些支撑特性的运行时代码(基于 <code>Dependency</code> 子类)，例如：</p><ul><li>需要 <code>__webpack_require__.f</code>、<code>__webpack_require__.r</code> 等功能实现最起码的模块化支持</li><li>如果用到动态加载特性，则需要写入 <code>__webpack_require__.e</code> 函数</li><li>如果用到 <code>Module Federation</code> 特性，则需要写入 <code>__webpack_require__.o</code> 函数</li><li>等等</li></ul><p>虽然每段运行时代码可能都很小，但随着特性的增加，最终结果会越来越大，特别对于多 <code>entry</code> 应用，在每个入口都重复打包一份相似的运行时代码显得有点浪费，为此 webpack 5 专门提供了 <code>entry.runtime</code> 配置项用于声明如何打包运行时代码。用法上只需在 <code>entry</code> 项中增加字符串形式的 <code>runtime</code> 值，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: &#123; <span class="attr">import</span>: <span class="string">&quot;./src/index&quot;</span>, <span class="attr">runtime</span>: <span class="string">&quot;solid-runtime&quot;</span> &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Webpack 执行完 <code>entry</code>、异步模块分包后，开始遍历 <code>entry</code> 配置判断是否带有 <code>runtime</code> 属性，如果有则创建以 <code>runtime</code> 值为名的 <code>Chunk</code>，因此，上例配置将生成两个<code>chunk</code>：<code>chunk[index.js]</code> 、<code>chunk[solid-runtime]</code>，并据此最终产出两个文件：</p><ul><li>入口 index 对应的 <code>index.js</code> 文件</li><li>运行时配置对应的 <code>solid-runtime.js</code> 文件</li></ul><p>在多 <code>entry</code> 场景中，只要为每个 <code>entry</code> 都设定相同的 <code>runtime</code> 值，webpack 运行时代码最终就会集中写入到同一个 <code>chunk</code>，例如对于如下配置：</p><p>入口 <code>index</code>、<code>home</code> 共享相同的 <code>runtime</code> ，最终生成三个 <code>chunk</code>，分别为：</p><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210726170017.jpg" alt="Runtime 分包"></p><p>同时生成三个文件：</p><ul><li>入口 index 对应的 <code>index.js</code></li><li>入口 index 对应的 <code>home.js</code></li><li>运行时代码对应的 <code>solid-runtime.js</code></li></ul><h3 id="分包规则的问题"><a href="#分包规则的问题" class="headerlink" title="分包规则的问题"></a>分包规则的问题</h3><p>至此，webpack 分包规则的基本逻辑就介绍完毕了，实现上，大部分功能代码都集中在：</p><ul><li>webpack/lib/compilation.js 文件的 seal 函数</li><li>webpack/lib/buildChunkGraph.js 的 buildChunkGraph 函数</li></ul><p>默认分包规则最大的问题是无法解决模块重复，如果多个 <code>chunk</code> 同时包含同一个 <code>module</code>，那么这个 <code>module</code> 会被不受限制地重复打包进这些 <code>chunk</code>。比如假设我们有两个入口 <code>main/index</code> 同时依赖了同一个模块：</p><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210726170227.jpg" alt="main/index"></p><p>默认情况下，webpack 不会对此做额外处理，只是单纯地将 c 模块同时打包进 <code>main/index</code> 两个 <code>chunk</code>，最终形成：</p><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210726170259.jpg" alt=" c 被重复打包"></p><p>可以看到 <code>chunk</code> 间互相孤立，模块 c 被重复打包，对最终产物可能造成不必要的性能损耗！</p><p>为了解决这个问题，webpack 3 引入 <code>CommonChunkPlugin</code> 插件试图将 <code>entry</code> 之间的公共依赖提取成单独的 <code>chunk</code>，但 <code>CommonChunkPlugin</code> 本质上是基于 <code>Chunk</code> 之间简单的父子关系链实现的，很难推断出提取出的第三个包应该作为 <code>entry</code> 的父 <code>chunk</code> 还是子 <code>chunk</code>，<code>CommonChunkPlugin</code> 统一处理为父 <code>chunk</code>，某些情况下反而对性能造成了不小的负面影响。</p><p>在 webpack 4 之后则引入了更负责的设计 —— <code>ChunkGroup</code> 专门实现关系链管理，配合 <code>SplitChunksPlugin</code> 能够更高效、智能地实现 <strong>「启发式分包」</strong></p><h2 id="彻底理解-Webpack-运行时"><a href="#彻底理解-Webpack-运行时" class="headerlink" title="彻底理解 Webpack 运行时"></a>彻底理解 Webpack 运行时</h2><p><a href="https://zhuanlan.zhihu.com/p/373946949">彻底理解 Webpack 运行时</a></p><h3 id="编译产物分析"><a href="#编译产物分析" class="headerlink" title="编译产物分析"></a>编译产物分析</h3><p>为了正常、正确运行业务项目，Webpack 需要将开发者编写的业务代码以及支撑、调配这些业务代码的「运行时」一并打包到产物(<code>bundle</code>)中，以建筑作类比的话，业务代码相当于砖瓦水泥，是看得见摸得着能直接感知的逻辑；运行时相当于掩埋在砖瓦之下的钢筋地基，通常不会关注但决定了整座建筑的功能、质量。</p><p>大多数 <code>Webpack</code> 特性都需要特定钢筋地基才能跑起来，比如说：</p><p>异步按需加载</p><ul><li><code>HMR</code></li><li><code>WASM</code></li><li><code>Module Federation</code></li></ul><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="string">&quot;a module&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> name <span class="keyword">from</span> <span class="string">&quot;./a&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br></pre></td></tr></table></figure><p>使用如下配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&quot;./src/index&quot;</span>,</span><br><span class="line">  mode: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">  devtool: <span class="literal">false</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">&quot;[name].js&quot;</span>,</span><br><span class="line">    path: path.join(__dirname, <span class="string">&quot;./dist&quot;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>直接看编译生成的结果</p><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hqwuzhaoyi.github.io/v2-f74527dbd49eab6874a81f65ab5598f3_1440w.jpg" alt="编译生成的结果"></p><p>虽然看起来很非主流，但细心分析还是能拆解出代码脉络的，bundle 整体由一个 IIFE 包裹，里面的内容从上到下依次为：</p><ul><li><code>__webpack_modules__</code> 对象，包含了除入口外的所有模块，示例中即 a.js 模块</li><li><code>__webpack_module_cache__</code> 对象，用于存储被引用过的模块</li><li><code>__webpack_require__</code> 函数，实现模块引用(require) 逻辑</li><li><code>__webpack_require__.d</code> ，工具函数，实现将模块导出的内容附加的模块对象上</li><li><code>__webpack_require__.o</code> ，工具函数，判断对象属性用</li><li><code>__webpack_require__.r</code> ，工具函数，在 ESM 模式下声明 ESM 模块标识</li><li>最后的 <code>IIFE</code> ，对应 <code>entry</code> 模块即上述示例的 index.js ，用于启动整个应用</li></ul><p>这几个 <code>__webpack_</code> 开头奇奇怪怪的函数可以统称为 <code>Webpack</code> 运行时代码，作用如前面所说的是搭起整个业务项目的骨架，就上述简单示例所罗列出来的几个函数、对象而言，它们协作构建起一个简单的模块化体系从而实现 <code>ES Module</code> 规范所声明的模块化特性。</p><p>上述示例中最终的函数是 <code>__webpack_require__</code>，它实现了模块间引用功能，核心代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/******/</span> <span class="comment">// 如果模块被引用过</span></span><br><span class="line">  <span class="comment">/******/</span> <span class="keyword">var</span> cachedModule = __webpack_module_cache__[moduleId];</span><br><span class="line">  <span class="comment">/******/</span> <span class="keyword">if</span> (cachedModule !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="comment">/******/</span> <span class="keyword">return</span> cachedModule.exports;</span><br><span class="line">    <span class="comment">/******/</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/******/</span> <span class="comment">// Create a new module (and put it into the cache)</span></span><br><span class="line">  <span class="comment">/******/</span> <span class="keyword">var</span> <span class="built_in">module</span> = (__webpack_module_cache__[moduleId] = &#123;</span><br><span class="line">    <span class="comment">/******/</span> <span class="comment">// no module.id needed</span></span><br><span class="line">    <span class="comment">/******/</span> <span class="comment">// no module.loaded needed</span></span><br><span class="line">    <span class="comment">/******/</span> <span class="built_in">exports</span>: &#123;&#125;,</span><br><span class="line">    <span class="comment">/******/</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">/******/</span></span><br><span class="line">  <span class="comment">/******/</span> <span class="comment">// Execute the module function</span></span><br><span class="line">  <span class="comment">/******/</span> __webpack_modules__[moduleId](</span><br><span class="line">    <span class="built_in">module</span>,</span><br><span class="line">    <span class="built_in">module</span>.exports,</span><br><span class="line">    __webpack_require__</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">/******/</span></span><br><span class="line">  <span class="comment">/******/</span> <span class="comment">// Return the exports of the module</span></span><br><span class="line">  <span class="comment">/******/</span> <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">  <span class="comment">/******/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码可以推测出，它的功能：</p><p>根据 <code>moduleId</code> 参数找到对应的模块代码，执行并返回结果<br>如果 <code>moduleId</code> 对应的模块被引用过，则直接返回存储在 <code>__webpack_module_cache__</code> 缓存对象中的导出内容，避免重复执行</p><p>其中，业务模块代码被存储在 bundle 最开始的 <code>__webpack_modules__</code> 变量中，内容如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> __webpack_modules__ = &#123;</span><br><span class="line">  <span class="string">&quot;./src/a.js&quot;</span>: (</span><br><span class="line">    __unused_webpack_module,</span><br><span class="line">    __webpack_exports__,</span><br><span class="line">    __webpack_require__</span><br><span class="line">  ) =&gt; &#123;</span><br><span class="line">    <span class="comment">// ...​</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结合 <code>__webpack_require__</code> 函数与 <code>__webpack_modules__</code> 变量就可以正确地引用到代码模块，例如上例生成代码最后面的<code>IIFE</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/*!**********************!*\</span></span><br><span class="line"><span class="comment">  !*** ./src/index.js ***!</span></span><br><span class="line"><span class="comment">  \**********************/</span></span><br><span class="line">  <span class="comment">/* harmony import */</span> <span class="keyword">var</span> _a__WEBPACK_IMPORTED_MODULE_0__ =</span><br><span class="line">    __webpack_require__(<span class="comment">/*! ./a */</span> <span class="string">&quot;./src/a.js&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(_a__WEBPACK_IMPORTED_MODULE_0__.name);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>这几个函数、对象构成了 Webpack 运行时最基本的能力 —— 模块化，它们的生成规则与原理我们放到文章第二节《实现原理》再讲，下面我们继续看看异步模块加载、模块热更新场景下对应的运行时内容。</p><p>异步模块加载<br>我们来看个简单的异步模块加载示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./src/a.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="string">&quot;module-a&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ./src/index.js</span></span><br><span class="line"><span class="keyword">import</span>(<span class="string">&quot;./a&quot;</span>).then(<span class="built_in">console</span>.log);</span><br></pre></td></tr></table></figure><p>使用异步模块加载特性时，会额外增加如下运行时：</p><p><code>__webpack_require__.e</code> ：逻辑上包裹了一层中间件模式与 <code>promise.all</code> ，用于异步加载多个模块<br><code>__webpack_require__.f</code> ：供 <code>__webpack_require__.e</code> 使用的中间件对象，例如使用 <code>Module Federation</code> 特性时就需要在这里注册中间件以修改 <code>e</code> 函数的执行逻辑<br><code>__webpack_require__.u</code> ：用于拼接异步模块名称的函数<br><code>__webpack_require__.l</code> ：基于 <code>JSONP</code> 实现的异步模块加载函数<br><code>__webpack_require__.p</code> ：当前文件的完整 <code>URL</code>，可用于计算异步模块的实际 <code>URL</code></p><p>建议读者运行示例对比实际生成代码，感受它们的具体功能。这几个运行时模块构建起 Webpack 异步加载能力，其中最核心的是 <code>__webpack_require__.e</code> 函数，它的代码很简单：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">__webpack_require__.f = &#123;&#125;;</span><br><span class="line"><span class="comment">/******/</span> <span class="comment">// This file contains only the entry chunk.</span></span><br><span class="line"><span class="comment">/******/</span> <span class="comment">// The chunk loading function for additional chunks</span></span><br><span class="line"><span class="comment">/******/</span> __webpack_require__.e = <span class="function">(<span class="params">chunkId</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/******/</span> <span class="keyword">return</span> <span class="built_in">Promise</span>.all(</span><br><span class="line">    <span class="built_in">Object</span>.keys(__webpack_require__.f).reduce(<span class="function">(<span class="params">promises, key</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">/******/</span> __webpack_require__.f[key](chunkId, promises);</span><br><span class="line">      <span class="comment">/******/</span> <span class="keyword">return</span> promises;</span><br><span class="line">      <span class="comment">/******/</span></span><br><span class="line">    &#125;, [])</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">/******/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从代码看，只是实现了一套基于 <code>__webpack_require__.f</code> 的中间件模式，以及用 <code>Promise.all</code> 实现并行处理，实际加载工作由 <code>__webpack_require__.f.j</code> 与 <code>__webpack_require__.l</code>实现，分开来看两个函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******/</span>  __webpack_require__.f.j = <span class="function">(<span class="params">chunkId, promises</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">/******/</span>        <span class="comment">// JSONP chunk loading for javascript</span></span><br><span class="line"><span class="comment">/******/</span>        <span class="keyword">var</span> installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : <span class="literal">undefined</span>;</span><br><span class="line"><span class="comment">/******/</span>        <span class="keyword">if</span>(installedChunkData !== <span class="number">0</span>) &#123; <span class="comment">// 0 means &quot;already installed&quot;.</span></span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span>          <span class="comment">// a Promise means &quot;currently loading&quot;.</span></span><br><span class="line"><span class="comment">/******/</span>          <span class="keyword">if</span>(installedChunkData) &#123;</span><br><span class="line"><span class="comment">/******/</span>            promises.push(installedChunkData[<span class="number">2</span>]);</span><br><span class="line"><span class="comment">/******/</span>          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/******/</span>            <span class="keyword">if</span>(<span class="literal">true</span>) &#123; <span class="comment">// all chunks have JS</span></span><br><span class="line"><span class="comment">/******/</span>              <span class="comment">// ...</span></span><br><span class="line"><span class="comment">/******/</span>              <span class="comment">// start chunk loading</span></span><br><span class="line"><span class="comment">/******/</span>              <span class="keyword">var</span> url = __webpack_require__.p + __webpack_require__.u(chunkId);</span><br><span class="line"><span class="comment">/******/</span>              <span class="comment">// create error before stack unwound to get useful stacktrace later</span></span><br><span class="line"><span class="comment">/******/</span>              <span class="keyword">var</span> error = <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line"><span class="comment">/******/</span>              <span class="keyword">var</span> loadingEnded = ...;</span><br><span class="line"><span class="comment">/******/</span>              __webpack_require__.l(url, loadingEnded, <span class="string">&quot;chunk-&quot;</span> + chunkId, chunkId);</span><br><span class="line"><span class="comment">/******/</span>            &#125; <span class="keyword">else</span> installedChunks[chunkId] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/******/</span>          &#125;</span><br><span class="line"><span class="comment">/******/</span>        &#125;</span><br><span class="line"><span class="comment">/******/</span>    &#125;;</span><br></pre></td></tr></table></figure><p><code>__webpack_require__.f.j</code> 实现了异步 <code>chunk</code> 路径的拼接、缓存、异常处理三个方面的逻辑，而 <code>__webpack_require__.l</code> 函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******/</span>    <span class="keyword">var</span> inProgress = &#123;&#125;;</span><br><span class="line"><span class="comment">/******/</span>    <span class="comment">// data-webpack is not used as build has no uniqueName</span></span><br><span class="line"><span class="comment">/******/</span>    <span class="comment">// loadScript function to load a script via script tag</span></span><br><span class="line"><span class="comment">/******/</span>    __webpack_require__.l = <span class="function">(<span class="params">url, done, key, chunkId</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">/******/</span>      <span class="keyword">if</span>(inProgress[url]) &#123; inProgress[url].push(done); <span class="keyword">return</span>; &#125;</span><br><span class="line"><span class="comment">/******/</span>      <span class="keyword">var</span> script, needAttach;</span><br><span class="line"><span class="comment">/******/</span>      <span class="keyword">if</span>(key !== <span class="literal">undefined</span>) &#123;</span><br><span class="line"><span class="comment">/******/</span>        <span class="keyword">var</span> scripts = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;script&quot;</span>);</span><br><span class="line"><span class="comment">/******/</span>        /​/ ...</span><br><span class="line"><span class="comment">/******/</span>      &#125;</span><br><span class="line"><span class="comment">/******/</span>      <span class="comment">//​ ...</span></span><br><span class="line"><span class="comment">/******/</span>      inProgress[url] = [done];</span><br><span class="line"><span class="comment">/******/</span>      <span class="keyword">var</span> onScriptComplete = <span class="function">(<span class="params">prev, event</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">/******/</span>        <span class="comment">//​ ...</span></span><br><span class="line"><span class="comment">/******/</span>      &#125;</span><br><span class="line"><span class="comment">/******/</span>      ;</span><br><span class="line"><span class="comment">/******/</span>      <span class="keyword">var</span> timeout = <span class="built_in">setTimeout</span>(onScriptComplete.bind(<span class="literal">null</span>, <span class="literal">undefined</span>, &#123; <span class="attr">type</span>: <span class="string">&#x27;timeout&#x27;</span>, <span class="attr">target</span>: script &#125;), <span class="number">120000</span>);</span><br><span class="line"><span class="comment">/******/</span>      script.onerror = onScriptComplete.bind(<span class="literal">null</span>, script.onerror);</span><br><span class="line"><span class="comment">/******/</span>      script.onload = onScriptComplete.bind(<span class="literal">null</span>, script.onload);</span><br><span class="line"><span class="comment">/******/</span>      needAttach &amp;&amp; <span class="built_in">document</span>.head.appendChild(script);</span><br><span class="line"><span class="comment">/******/</span>    &#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******/</span>    <span class="keyword">var</span> inProgress = &#123;&#125;;</span><br><span class="line"><span class="comment">/******/</span>    <span class="comment">// data-webpack is not used as build has no uniqueName</span></span><br><span class="line"><span class="comment">/******/</span>    <span class="comment">// loadScript function to load a script via script tag</span></span><br><span class="line"><span class="comment">/******/</span>    __webpack_require__.l = <span class="function">(<span class="params">url, done, key, chunkId</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">/******/</span>      <span class="keyword">if</span>(inProgress[url]) &#123; inProgress[url].push(done); <span class="keyword">return</span>; &#125;</span><br><span class="line"><span class="comment">/******/</span>      <span class="keyword">var</span> script, needAttach;</span><br><span class="line"><span class="comment">/******/</span>      <span class="keyword">if</span>(key !== <span class="literal">undefined</span>) &#123;</span><br><span class="line"><span class="comment">/******/</span>        <span class="keyword">var</span> scripts = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;script&quot;</span>);</span><br><span class="line"><span class="comment">/******/</span>        /​/ ...</span><br><span class="line"><span class="comment">/******/</span>      &#125;</span><br><span class="line"><span class="comment">/******/</span>      <span class="comment">//​ ...</span></span><br><span class="line"><span class="comment">/******/</span>      inProgress[url] = [done];</span><br><span class="line"><span class="comment">/******/</span>      <span class="keyword">var</span> onScriptComplete = <span class="function">(<span class="params">prev, event</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">/******/</span>        <span class="comment">//​ ...</span></span><br><span class="line"><span class="comment">/******/</span>      &#125;</span><br><span class="line"><span class="comment">/******/</span>      ;</span><br><span class="line"><span class="comment">/******/</span>      <span class="keyword">var</span> timeout = <span class="built_in">setTimeout</span>(onScriptComplete.bind(<span class="literal">null</span>, <span class="literal">undefined</span>, &#123; <span class="attr">type</span>: <span class="string">&#x27;timeout&#x27;</span>, <span class="attr">target</span>: script &#125;), <span class="number">120000</span>);</span><br><span class="line"><span class="comment">/******/</span>      script.onerror = onScriptComplete.bind(<span class="literal">null</span>, script.onerror);</span><br><span class="line"><span class="comment">/******/</span>      script.onload = onScriptComplete.bind(<span class="literal">null</span>, script.onload);</span><br><span class="line"><span class="comment">/******/</span>      needAttach &amp;&amp; <span class="built_in">document</span>.head.appendChild(script);</span><br><span class="line"><span class="comment">/******/</span>    &#125;;</span><br></pre></td></tr></table></figure><p><code>__webpack_require__.l</code>中通过 <code>script</code> 实现异步 <code>chunk</code> 内容的加载与执行。</p><p><code>e + l + f.j</code> 三个运行时函数支撑起 Webpack 异步模块运行的能力，落到实际用法上只需要调用 <code>e</code> 函数即可完成异步模块加载、运行，例如上例对应生成的 <code>entry</code> 内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!**********************!*\</span></span><br><span class="line"><span class="comment">  !*** ./src/index.js ***!</span></span><br><span class="line"><span class="comment">  \**********************/</span></span><br><span class="line">__webpack_require__</span><br><span class="line">  .e(<span class="comment">/*! import() */</span> <span class="string">&quot;src_a_js&quot;</span>)</span><br><span class="line">  .then(__webpack_require__.bind(__webpack_require__, <span class="comment">/*! ./a */</span> <span class="string">&quot;./src/a.js&quot;</span>));</span><br></pre></td></tr></table></figure><h3 id="模块热更新"><a href="#模块热更新" class="headerlink" title="模块热更新"></a>模块热更新</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&quot;./src/index&quot;</span>,</span><br><span class="line">  mode: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">  devtool: <span class="literal">false</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">&quot;[name].js&quot;</span>,</span><br><span class="line">    path: path.join(__dirname, <span class="string">&quot;./dist&quot;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 简单起见，这里使用 HtmlWebpackPlugin 插件自动生成作为 host 的 html 文件</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      title: <span class="string">&quot;Hot Module Replacement&quot;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// 配置 devServer 属性，启动 HMR</span></span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">&quot;./dist&quot;</span>,</span><br><span class="line">    hot: <span class="literal">true</span>,</span><br><span class="line">    writeToDisk: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>按照上述配置，使用命令 <code>webpack serve --hot-only</code> 启动 Webpack，就可以在 dist 文件夹找到产物：</p><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hqwuzhaoyi.github.io/v2-e80ec089dc856473ed26a2855f68e291_1440w.jpg" alt="HMR产物"></p><ul><li>支持 HMR 所需要用到的 webpack-dev-server 、webpack/hot/xxx 、querystring 等框架，这一部分占了大部分代码</li><li><code>__webpack_require__.l</code> ：与异步模块加载一样，基于 JSONP 实现的异步模块加载函数</li><li><code>__webpack_require__.e</code> ：与异步模块加载一样</li><li><code>__webpack_require__.f</code> ：与异步模块加载一样</li><li><code>__webpack_require__.hmrF</code>： 用于拼接热更新模块 url 的函数</li><li><code>webpack/runtime/hot</code> ：这不是单个对象或函数，而是包含了一堆实现模块替换的方法</li></ul><p>可以看到， HMR 运行时是上面异步模块加载运行时的超集，而异步模块加载的运行时又是第一个基本示例运行时的超集，层层叠加。在 HMR 中包含了：</p><ul><li>模块化能力</li><li>异步模块加载能力 —— 实现变更模块的异步加载</li><li>热替换能力 —— 用拉取到的新模块替换掉旧的模块，并触发热更新事件</li></ul><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><ul><li>除了业务代码外，<code>bundle</code> 中还必须包含「运行时」代码才能正常运行</li><li>「运行时的具体内容由业务代码，确切地说由业务代码所使用到的特性决定」，例如使用到异步加载时需要打包 <code>__webpack_require__.e</code> 函数，那么这里面必然有一个运行时依赖收集的过程</li><li>开发者编写的业务代码会被包裹进恰当的运行时函数中，实现整体协调</li></ul><p>落到 Webpack 源码实现上，运行时的生成逻辑可以划分为两个步骤：</p><ol><li><strong>「依赖收集」</strong>：遍历业务代码模块收集模块的特性依赖，从而确定整个项目对 <code>Webpack runtime</code> 的依赖列表</li><li><strong>「生成」</strong>：合并 <code>runtime</code> 的依赖列表，打包到最终输出的 <code>bundle</code></li></ol><p>两个步骤都发生在打包阶段，即 Webpack(v5) 源码的 <code>compilation.seal</code> 函数中：</p><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hqwuzhaoyi.github.io/v2-18896cb76bb6f4f886ebf10b1f5f5016_1440w.jpg" alt="compilation.seal"></p><p>进入 <code>runtime</code> 处理环节时 Webpack 已经解析得出 <code>ModuleDependencyGraph</code> 及 <code>ChunkGraph</code> 关系，也就意味着此时已经可以计算出：</p><ul><li>需要输出那些 <code>chunk</code></li><li>每个 <code>chunk</code> 包含那些 <code>module</code>，以及每个 <code>module</code> 的内容</li><li><code>chunk</code> 与 <code>chunk</code> 之间的父子依赖关系</li></ul><p><a href="#Webpack-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86">bundle</a>、<a href="#Dependency-Graph-%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90">module</a>、<a href="#Webpack-Chunk-%E5%88%86%E5%8C%85%E8%A7%84%E5%88%99%E8%AF%A6%E8%A7%A3">chunk</a></p><p>基于这些信息，接下来首先需要收集运行时依赖。</p><h3 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h3><p>Webpack runtime 的依赖概念上很像 Vue 的依赖，都是用来表达模块对其它模块存在依附关系，只是实现方法上 Vue 基于动态、在运行过程中收集，而 Webpack 则基于静态代码分析的方式收集依赖。实现逻辑大致为：</p><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hqwuzhaoyi.github.io/v2-5e92ef4d53c2d6a8f1d77c050ce5deb2_1440w.jpg" alt="依赖收集"></p><p>运行时依赖的计算逻辑集中在 <code>compilation.processRuntimeRequirements</code> 函数，代码上包含三次循环：</p><p>第一次循环遍历所有 <code>module</code>，收集所有 <code>module</code> 的 <code>runtime</code> 依赖<br>第二次循环遍历所有 <code>chunk</code>，将 <code>chunk</code> 下所有 <code>module</code> 的 <code>runtime</code> 统一收录到 <code>chunk</code> 中<br>第三次循环遍历所有 <code>runtime chunk</code>，收集其对应的子 <code>chunk</code> 下所有 <code>runtime</code> 依赖，之后遍历所有依赖并发布 <code>runtimeRequirementInTree</code> 钩子，(主要是) <code>RuntimePlugin</code> 插件订阅该钩子并根据依赖类型创建对应的 <code>RuntimeModule</code> 子类实例</p><h4 id="第一次循环：收集模块依赖"><a href="#第一次循环：收集模块依赖" class="headerlink" title="第一次循环：收集模块依赖"></a>第一次循环：收集模块依赖</h4><p>在打包(seal)阶段，完成 <code>ChunkGraph</code> 的构建之后，Webpack 会紧接着调用 <code>codeGeneration</code> 函数遍历 <code>module</code> 数组，调用它们的 <code>module.codeGeneration</code> 函数执行模块转译，模块转译结果如：</p><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hqwuzhaoyi.github.io/v2-cdea70759f6d5006a5ca858c1ce28a4a_1440w.jpg" alt="模块转译结果"></p><p>其中，<code>sources</code> 属性为模块经过转译后的结果；而 <code>runtimeRequirements</code> 则是基于 AST 计算出来的，为运行该模块时所需要用到的运行时，计算过程与本文主题无关，挖个坑下一回我们再继续讲。</p><p>所有模块转译完毕后，开始调用 <code>compilation.processRuntimeRequirements</code> 进入第一重循环，将上述转译结果的 <code>runtimeRequirements</code> 记录到 <code>ChunkGraph</code> 对象中。</p><h4 id="第二次循环：整合-chunk-依赖"><a href="#第二次循环：整合-chunk-依赖" class="headerlink" title="第二次循环：整合 chunk 依赖"></a>第二次循环：整合 chunk 依赖</h4><p>第一次循环针对 <code>module</code> 收集依赖，第二次循环则遍历 <code>chunk</code> 数组，收集将其对应所有 <code>module</code> 的 <code>runtime</code> 依赖，例如：</p><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hqwuzhaoyi.github.io/v2-d64a076c37cce5ede403ab245f7728cf_1440w.jpg" alt="收集将其对应所有 module 的 runtime 依赖"></p><p>示例图中，<code>module a</code> 包含两个运行时依赖；<code>module b</code> 包含一个运行时依赖，则经过第二次循环整合后，对应的 <code>chunk</code> 会包含两个模块对应的三个运行时依赖。</p><h4 id="第三次循环：依赖标识转-RuntimeModule-对象"><a href="#第三次循环：依赖标识转-RuntimeModule-对象" class="headerlink" title="第三次循环：依赖标识转 RuntimeModule 对象"></a>第三次循环：依赖标识转 RuntimeModule 对象</h4><p>源码中，第三次循环的代码最少但逻辑最复杂，大致上执行三个操作：</p><ul><li>遍历所有 <code>runtime chunk</code>，收集其所有子 <code>chunk</code> 的 <code>runtime</code> 依赖</li><li>为该 <code>runtime chunk</code> 下的所有依赖发布 <code>runtimeRequirementInTree</code> 钩子</li><li><code>RuntimePlugin</code> 监听钩子，并根据 <code>runtime</code> 依赖的标识信息创建对应的 <code>RuntimeModule</code> 子类对象，并将对象加入到 <code>ModuleDependencyGraph</code> 和 <code>ChunkGraph</code> 体系中管理</li></ul><p>至此，<code>runtime</code> 依赖完成了从 <code>module</code> 内容解析，到收集，到创建依赖对应的 <code>Module</code> 子类，再将 <code>Module</code> 加入到 <code>ModuleDependencyGraph /ChunkGraph</code> 体系的全流程，业务代码及运行时代码对应的模块依赖关系图完全 ready，可以准备进入下一阶段 —— 生成最终产物。</p><p>但在继续讲解产物逻辑之前，我们有必要先解决两个问题：</p><ul><li>何谓 <code>runtime chunk</code>？与普通 <code>chunk</code> 是什么关系</li><li>何谓 <code>RuntimeModule</code>？与普通 <code>Module</code> 有什么区别</li></ul><p>回顾一下在三种特定的情况下，Webpack 会创建新的 chunk：</p><ul><li>每个 <code>entry</code> 项都会对应生成一个 <code>chunk</code> 对象，称之为 <code>initial chunk</code></li><li>每个异步模块都会对应生成一个 <code>chunk</code> 对象，称之为 <code>async chunk</code></li><li>Webpack 5 之后，如果 <code>entry</code> 配置中包含 runtime 值，则在 <code>entry</code> 之外再增加一个专门容纳 <code>runtime</code> 的 <code>chunk</code> 对象，此时可以称之为 <code>runtime chunk</code></li></ul><p>默认情况下 <code>initial chunk</code> 通常包含运行该 <code>entry</code> 所需要的所有 <code>runtime</code> 代码，但 webpack 5 之后出现的第三条规则打破了这一限制，允许开发者将 <code>runtime</code> 从 <code>initial chunk</code> 中剥离出来独立为一个多 entry 间可共享的 <code>runtime chunk</code>。</p><p>类似的，异步模块对应 <code>runtime</code> 代码大部分都被包含在对应的引用者身上，比如说：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="string">&quot;a-module&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="comment">// 异步引入 a 模块</span></span><br><span class="line"><span class="keyword">import</span>(<span class="string">&quot;./a&quot;</span>).then(<span class="built_in">console</span>.log);</span><br></pre></td></tr></table></figure><p>在这个示例中，index 异步引入 a 模块，那么按默认分配规则会产生两个 <code>chunk</code>：入口文件 index 对应的 <code>initial chunk</code>、异步模块 a 对应的 <code>async chunk</code>。此时从 <code>ChunkGraph</code> 的角度看 <code>chunk[index]</code>为 <code>chunk[a]</code> 的父级，运行时代码会被打入 <code>chunk[index]</code>，站在浏览器的角度，运行 <code>chunk[a]</code> 之前必须先运行 <code>chunk[index]</code> ，两者形成明显的父子关系。</p><p>在最开始阅读 Webpack 源码的时候，我就觉得很奇怪，<code>Module</code> 是 Webpack 资源管理的基本单位，但 <code>Module</code> 底下总共衍生出了 54 个子类，且大部分为 <code>Module =&gt; RuntimeModule =&gt; xxxRuntimeModule</code> 的继承关系：</p><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hqwuzhaoyi.github.io/v2-9287287b08a48f29c6d4cd55178adaa2_1440w.jpg" alt="Module =&gt; RuntimeModule =&gt; xxxRuntimeModule"></p><p>在 <a href="https://link.zhihu.com/?target=https://mp.weixin.qq.com/s/kr73Epnn6wAx9DH7KRVUaA">有点难的 webpack 知识点：Dependency Graph 深度解析</a> 一文中我们聊到模块依赖关系图的生成过程及作用，但篇文章的内容是围绕业务代码展开的，用到的大多是 <code>NormalModule</code> 。到 <code>seal</code> 函数收集运行时的过程中，<code>RuntimePlugin</code> 还会为运行时依赖一一创建对应的 <code>RuntimeModule</code> 子类，例如：</p><ul><li>模块化实现中依赖 <code>__webpack_require__.r</code> ，则对应创建 <code>MakeNamespaceObjectRuntimeModule</code> 对象</li><li>ESM 依赖 <code>__webpack_require__.o</code> ，则对应创建 <code>HasOwnPropertyRuntimeModule</code> 对象</li><li>异步模块加载依赖 <code>__webpack_require__.e</code>，则对应创建 <code>EnsureChunkRuntimeModule</code> 对象</li><li>等等</li></ul><p>所以可以推导出所有 <code>RuntimeModule</code> 结尾的类型与特定的运行时功能一一对应，收集依赖的结果就是在业务代码之外创建出一堆支撑性质的 <code>RuntimeModule</code> 子类，这些子类对象随后被加入 <code>ModuleDependencyGraph</code> ，并入整个模块依赖体系中。</p><h3 id="资源合并生成"><a href="#资源合并生成" class="headerlink" title="资源合并生成"></a>资源合并生成</h3><p>经过上面的运行时依赖收集过程后，<code>bundles</code> 所需要的所有内容都就绪了，接着就可以准备写出到文件中，即下图核心流程中的生成(<code>emit</code>)阶段：</p><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hqwuzhaoyi.github.io/v2-e80ec089dc856473ed26a2855f68e291_1440w.jpg" alt="核心流程中的生成(`emit`)阶段"></p><p><a href="#Webpack-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86">Webpack-核心原理</a>对这一块有比较细致的讲解，这里从运行时的视角再简单聊一下代码流程：</p><p>调用 <code>compilation.createChunkAssets</code> ，遍历 <code>chunks</code> 将 <code>chunk</code> 对应的所有 <code>module</code>，包括业务模块、运行时模块全部合并成一个资源(<code>Source</code> 子类)对象<br>调用 <code>compilation.emitAsset</code> 将资源对象挂载到 <code>compilation.assets</code> 属性中<br>调用 <code>compiler.emitAssets</code> 将 <code>assets</code> 全部写到 <code>FileSystem</code><br>发布 <code>compiler.hooks.done</code> 钩子<br>运行结束</p><h2 id="如何编写-loader"><a href="#如何编写-loader" class="headerlink" title="如何编写 loader"></a>如何编写 loader</h2><p><a href="https://zhuanlan.zhihu.com/p/375626250">如何编写 loader</a></p><h3 id="Loader-基础"><a href="#Loader-基础" class="headerlink" title="Loader 基础"></a>Loader 基础</h3><p>代码层面，Loader 通常是一个函数，结构如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">source, sourceMap?, data?</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// source 为 loader 的输入，可能是文件内容，也可能是上一个 loader 处理结果</span></span><br><span class="line">  <span class="keyword">return</span> source;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Loader 函数接收三个参数，分别为：</p><ul><li><code>source</code>：资源输入，对于第一个执行的 loader 为资源文件的内容；后续执行的 loader 则为前一个 loader 的执行结果</li><li><code>sourceMap</code>: 可选参数，代码的 sourcemap 结构</li><li><code>data</code>: 可选参数，其它需要在 Loader 链中传递的信息，比如 posthtml/posthtml-loader 就会通过这个参数传递参数的 AST 对象</li></ul><p>其中 source 是最重要的参数，大多数 Loader 要做的事情就是将 source 转译为另一种形式的 output</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">rawLoader</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> json = <span class="built_in">JSON</span>.stringify(source)</span><br><span class="line">    .replace(<span class="regexp">/\u2028/g</span>, <span class="string">&quot;\\u2028&quot;</span>)</span><br><span class="line">    .replace(<span class="regexp">/\u2029/g</span>, <span class="string">&quot;\\u2029&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> esModule =</span><br><span class="line">    <span class="keyword">typeof</span> options.esModule !== <span class="string">&quot;undefined&quot;</span> ? options.esModule : <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;esModule ? <span class="string">&quot;export default&quot;</span> : <span class="string">&quot;module.exports =&quot;</span>&#125;</span> <span class="subst">$&#123;json&#125;</span>;`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的作用是将文本内容包裹成 JavaScript 模块</p><h3 id="返回多个结果"><a href="#返回多个结果" class="headerlink" title="返回多个结果"></a>返回多个结果</h3><p>上例通过 return 语句返回处理结果，除此之外 Loader 还可以以 callback 方式返回更多信息，供下游 Loader 或者 Webpack 本身使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">loader</span>(<span class="params">content, map</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  linter.printOutput(linter.lint(content));</span><br><span class="line">  <span class="built_in">this</span>.callback(<span class="literal">null</span>, content, map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>this.callback(null, content, map)</code> 语句同时返回转译后的内容与 sourcemap 内容。callback 的完整签名如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.callback(</span><br><span class="line">    <span class="comment">// 异常信息，Loader 正常运行时传递 null 值即可</span></span><br><span class="line">    err: <span class="built_in">Error</span> | <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 转译结果</span></span><br><span class="line">    content: string | Buffer,</span><br><span class="line">    <span class="comment">// 源码的 sourcemap 信息</span></span><br><span class="line">    sourceMap?: SourceMap,</span><br><span class="line">    <span class="comment">// 任意需要在 Loader 间传递的值</span></span><br><span class="line">    <span class="comment">// 经常用来传递 ast 对象，避免重复解析</span></span><br><span class="line">    data?: any</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h3><p>涉及到异步或 CPU 密集操作时，Loader 中还可以以异步形式返回处理结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> less <span class="keyword">from</span> <span class="string">&quot;less&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">lessLoader</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 获取异步回调函数</span></span><br><span class="line">  <span class="keyword">const</span> callback = <span class="built_in">this</span>.async();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> result;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 2. 调用less 将模块内容转译为 css</span></span><br><span class="line">    result = <span class="keyword">await</span> (options.implementation || less).render(data, lessOptions);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; css, imports &#125; = result;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 转译结束，返回结果</span></span><br><span class="line">  callback(<span class="literal">null</span>, css, map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> lessLoader;</span><br></pre></td></tr></table></figure><p>在 less-loader 中，逻辑分三步：</p><ul><li>调用 <code>this.async</code> 获取异步回调函数，此时 Webpack 会将该 Loader 标记为异步加载器，会挂起当前执行队列直到 <code>callback</code> 被触发</li><li>调用 less 库将 less 资源转译为标准 css</li><li>调用异步回调 <code>callback</code> 返回处理结果</li></ul><p><code>this.async</code> 返回的异步回调函数签名与上一节介绍的 <code>this.callback</code> 相同，此处不再赘述。</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>Loader 为开发者提供了一种便捷的扩展方法，但在 Loader 中执行的各种资源内容转译操作通常都是 CPU 密集型 —— 这放在单线程的 Node 场景下可能导致性能问题；又或者异步 Loader 会挂起后续的加载器队列直到异步 Loader 触发回调，稍微不注意就可能导致整个加载器链条的执行时间过长。</p><p>为此，默认情况下 Webpack 会缓存 Loader 的执行结果直到资源或资源依赖发生变化，开发者需要对此有个基本的理解，必要时可以通过 this.cachable 显式声明不作缓存，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.cacheable(<span class="literal">false</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> output;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="上下文与-Side-Effect"><a href="#上下文与-Side-Effect" class="headerlink" title="上下文与 Side Effect"></a>上下文与 Side Effect</h3><p>除了作为内容转换器外，Loader 运行过程还可以通过一些上下文接口，有限制地影响 Webpack 编译过程，从而产生内容转换之外的副作用。</p><p>上下文信息可通过 this 获取，<code>this</code> 对象由 <code>NormolModule.createLoaderContext</code> 函数在调用 Loader 前创建，常用的接口包括：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loaderContext = &#123;</span><br><span class="line">  <span class="comment">// 获取当前 Loader 的配置信息</span></span><br><span class="line">  getOptions: <span class="function">(<span class="params">schema</span>) =&gt;</span> &#123;&#125;,</span><br><span class="line">  <span class="comment">// 添加警告</span></span><br><span class="line">  emitWarning: <span class="function">(<span class="params">warning</span>) =&gt;</span> &#123;&#125;,</span><br><span class="line">  <span class="comment">// 添加错误信息，注意这不会中断 Webpack 运行</span></span><br><span class="line">  emitError: <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;&#125;,</span><br><span class="line">  <span class="comment">// 解析资源文件的具体路径</span></span><br><span class="line">  <span class="function"><span class="title">resolve</span>(<span class="params">context, request, callback</span>)</span> &#123;&#125;,</span><br><span class="line">  <span class="comment">// 直接提交文件，提交的文件不会经过后续的chunk、module处理，直接输出到 fs</span></span><br><span class="line">  emitFile: <span class="function">(<span class="params">name, content, sourceMap, assetInfo</span>) =&gt;</span> &#123;&#125;,</span><br><span class="line">  <span class="comment">// 添加额外的依赖文件</span></span><br><span class="line">  <span class="comment">// watch 模式下，依赖文件发生变化时会触发资源重新编译</span></span><br><span class="line">  <span class="function"><span class="title">addDependency</span>(<span class="params">dep</span>)</span> &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中，<code>addDependency</code>、<code>emitFile</code> 、<code>emitError</code>、<code>emitWarning</code> 都会对后续编译流程产生副作用，例如 <code>less-loader</code> 中包含这样一段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  result = <span class="keyword">await</span> (options.implementation || less).render(data, lessOptions);</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> &#123; css, imports &#125; = result;</span><br><span class="line">imports.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">this</span>.addDependency(path.normalize(item));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>解释一下，代码中首先调用 <code>less</code> 编译文件内容，之后遍历所有 <code>import</code> 语句，也就是上例 <code>result.imports</code> 数组，一一调用 <code>this.addDependency</code> 函数将 <code>import</code> 到的其它资源都注册为依赖，之后这些其它资源文件发生变化时都会触发重新编译。</p><h3 id="Loader-链式调用"><a href="#Loader-链式调用" class="headerlink" title="Loader 链式调用"></a>Loader 链式调用</h3><p>使用上，可以为某种资源文件配置多个 Loader，Loader 之间按照配置的顺序从前到后(pitch)，再从后到前依次执行，从而形成一套内容转译工作流，例如对于下面的配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/i</span>,</span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;less-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这是一个典型的 less 处理场景，针对 <code>.less</code> 后缀的文件设定了：less、css、style 三个 loader 协作处理资源文件，按照定义的顺序，Webpack 解析 less 文件内容后先传入 less-loader；less-loader 返回的结果再传入 css-loader 处理；css-loader 的结果再传入 style-loader；最终以 style-loader 的处理结果为准，流程简化后如：</p><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hqwuzhaoyi.github.io/v2-0bf3696db90bb7629ce498883ded693d_r.jpg" alt="三个 loader 协作处理资源文件"></p><p>上述示例中，三个 Loader 分别起如下作用：</p><ul><li><code>less-loader</code>：实现 <code>less =&gt; css</code> 的转换，输出 css 内容，无法被直接应用在 Webpack 体系下</li><li><code>css-loader</code>：将 css 内容包装成类似 <code>module.exports = &quot;$&#123;css&#125;&quot;</code> 的内容，包装后的内容符合 JavaScript 语法</li><li><code>style-loade</code>r： 做的事情非常简单，就是将 css 模块包进 require 语句，并在运行时调用 <code>injectStyle</code> 等函数将内容注入到页面的 <code>style</code> 标签</li></ul><p>三个 Loader 分别完成内容转化工作的一部分，形成从右到左的调用链条。链式调用这种设计有两个好处，一是保持单个 Loader 的单一职责，一定程度上降低代码的复杂度；二是细粒度的功能能够被组装成复杂而灵活的处理链条，提升单个 Loader 的可复用性。</p><p>不过，这只是链式调用的一部分，这里面有两个问题：</p><ul><li>oader 链条一旦启动之后，需要所有 Loader 都执行完毕才会结束，没有中断的机会 —— 除非显式抛出异常</li><li>某些场景下并不需要关心资源的具体内容，但 Loader 需要在 source 内容被读取出来之后才会执行</li></ul><p>为了解决这两个问题，Webpack 在 loader 基础上叠加了 <code>pitch</code> 的概念。</p><h3 id="Loader-Pitch"><a href="#Loader-Pitch" class="headerlink" title="Loader Pitch"></a>Loader Pitch</h3><p>Webpack 允许在这个函数上挂载名为 <code>pitch</code> 的函数，运行时 <code>pitch</code> 会比 <code>Loader</code> 本身更早执行，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loader = <span class="function"><span class="keyword">function</span> (<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;后执行&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> source;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">loader.pitch = <span class="function"><span class="keyword">function</span> (<span class="params">requestString</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;先执行&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = loader;</span><br></pre></td></tr></table></figure><p>Pitch 函数的完整签名：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pitch</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  remainingRequest: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  previousRequest: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  data = &#123;&#125;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><code>remainingRequest</code> : 当前 loader 之后的资源请求字符串</li><li><code>previousRequest</code> : 在执行当前 loader 之前经历过的 loader 列表</li><li><code>data</code> : 与 Loader 函数的 data 相同，用于传递需要在 Loader 传播的信息</li></ul><p>这些参数不复杂，但与 requestString 紧密相关，我们看个例子加深了解：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.less$/i</span>,</span><br><span class="line">  use: [</span><br><span class="line">    <span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;less-loader&quot;</span></span><br><span class="line">  ],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><code>css-loader.pitch</code> 中拿到的参数依次为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// css-loader 之后的 loader 列表及资源路径</span></span><br><span class="line">remainingRequest = less-loader!./xxx.less</span><br><span class="line"><span class="comment">// css-loader 之前的 loader 列表</span></span><br><span class="line">previousRequest = style-loader</span><br><span class="line"><span class="comment">// 默认值</span></span><br><span class="line">data = &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="调度逻辑"><a href="#调度逻辑" class="headerlink" title="调度逻辑"></a>调度逻辑</h3><p><code>Pitch</code> 翻译成中文是抛、球场、力度、事物最高点等，我觉得 <code>pitch</code> 特性之所以被忽略完全是这个名字的锅，它背后折射的是一整套 <code>Loader</code> 被执行的生命周期概念。</p><p>实现上，<code>Loader</code> 链条执行过程分三个阶段：<code>pitch</code>、解析资源、执行，设计上与 <code>DOM</code> 的事件模型非常相似，<code>pitch</code> 对应到捕获阶段；执行对应到冒泡阶段；而两个阶段之间 Webpack 会执行资源内容的读取、解析操作，对应 <code>DOM</code> 事件模型的 <code>AT_TARGET</code> 阶段：</p><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hqwuzhaoyi.github.io/v2-834d7775c9bac4eabc9b568f61617b64_r.jpg" alt="Loader 被执行的生命周期"></p><p><code>pitch</code> 阶段按配置顺序从左到右逐个执行 <code>loader.pitch</code> 函数(如果有的话)，开发者可以在 <code>pitch</code> 返回任意值中断后续的链路的执行：</p><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hqwuzhaoyi.github.io/v2-74f05b7f818236d2a07c870a7af5436a_r.jpg" alt="中断 Loader 被执行的生命周期"></p><p>那么为什么要设计 pitch 这一特性呢？<strong>「阻断」</strong>！</p><h4 id="示例：style-loader"><a href="#示例：style-loader" class="headerlink" title="示例：style-loader"></a>示例：style-loader</h4><p>实际上， <code>style-loader</code> 只是负责让 <code>css</code> 能够在浏览器环境下跑起来，本质上并不需要关心具体内容，很适合用 <code>pitch</code> 来处理，核心代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// Loader 本身不作任何处理</span></span><br><span class="line"><span class="keyword">const</span> loaderApi = <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pitch 中根据参数拼接模块代码</span></span><br><span class="line">loaderApi.pitch = <span class="function"><span class="keyword">function</span> <span class="title">loader</span>(<span class="params">remainingRequest</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (injectType) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;linkTag&quot;</span>: &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">        esModule</span></span></span><br><span class="line"><span class="string"><span class="subst">          ? <span class="string">`...`</span></span></span></span><br><span class="line"><span class="string"><span class="subst">          : <span class="regexp">//</span> 引入 runtime 模块</span></span></span><br><span class="line"><span class="string"><span class="subst">            <span class="string">`var api = require(<span class="subst">$&#123;loaderUtils.stringifyRequest(</span></span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string"><span class="subst">              <span class="built_in">this</span>,</span></span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string"><span class="subst">              <span class="string">`!<span class="subst">$&#123;path.join(__dirname, <span class="string">&quot;runtime/injectStylesIntoLinkTag.js&quot;</span>)&#125;</span>`</span></span></span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string"><span class="subst">            )&#125;</span>);</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">            // 引入 css 模块</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">            var content = require(<span class="subst">$&#123;loaderUtils.stringifyRequest(</span></span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string"><span class="subst">              <span class="built_in">this</span>,</span></span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string"><span class="subst">              <span class="string">`!!<span class="subst">$&#123;remainingRequest&#125;</span>`</span></span></span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string"><span class="subst">            )&#125;</span>);</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string"></span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">            content = content.__esModule ? content.default : content;`</span></span></span></span><br><span class="line"><span class="string"><span class="subst">      &#125;</span> // ...`</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;lazyStyleTag&quot;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;lazySingletonStyleTag&quot;</span>: &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;styleTag&quot;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;singletonStyleTag&quot;</span>:</span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> loaderApi;</span><br></pre></td></tr></table></figure><ul><li><code>loaderApi</code> 为空函数，不做任何处理</li><li><code>loaderApi.pitch</code> 中拼接结果，导出的代码包含：<ul><li>引入运行时模块 <code>runtime/injectStylesIntoLinkTag.js</code></li></ul></li><li>复用 <code>remainingRequest</code> 参数，重新引入 css 文件</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 运行结果大致如</span></span><br><span class="line"><span class="keyword">var</span> api = <span class="built_in">require</span>(<span class="string">&quot;xxx/style-loader/lib/runtime/injectStylesIntoLinkTag.js&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> content = <span class="built_in">require</span>(<span class="string">&quot;!!css-loader!less-loader!./xxx.less&quot;</span>);</span><br></pre></td></tr></table></figure><p>注意了，到这里 <code>style-loader</code> 的 <code>pitch</code> 函数返回这一段内容，后续的 <code>Loader</code> 就不会继续执行，当前调用链条中断了：</p><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hqwuzhaoyi.github.io/v2-8eb7bcca57abde019b260464345abd34_r.jpg" alt="`style-loader`当前调用链条中断"></p><p>之后，Webpack 继续解析、构建 <code>style-loader</code> 返回的结果，遇到 <code>inline loader</code> 语句：</p><p><code>var content = require(&#39;!!css-loader!less-loader!./xxx.less&#39;);</code></p><p>所以从 Webpack 的角度看，实际上对同一个文件调用了两次 <code>loader</code> 链，第一次在 <code>style-loader</code> 的 <code>pitch</code> 中断，第二次根据 <code>inline loader</code> 的内容跳过了 <code>style-loader</code>。</p><h2 id="产物转译打包逻辑"><a href="#产物转译打包逻辑" class="headerlink" title="产物转译打包逻辑"></a>产物转译打包逻辑</h2><p><a href="https://zhuanlan.zhihu.com/p/384602429">Webpack 原理系列八：产物转译打包逻辑</a></p><p><a href="#Dependency-Graph-%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90">Dependency-Graph-深度解析</a><br>经过 <strong>「构建(<code>make</code>)阶段」</strong> 后，Webpack 解析出：</p><ul><li><code>module</code> 内容</li><li><code>module</code> 与 <code>module</code> 之间的依赖关系图</li></ul><p>而进入 <strong>「生成(「「<code>seal</code>」」)阶段」</strong> 后，Webpack 首先根据模块的依赖关系、模块特性、<code>entry</code>配置等计算出 <code>Chunk Graph</code>，确定最终产物的数量和内容</p><p>本文继续聊聊 <code>Chunk Graph</code> 后面之后，模块开始转译到模块合并打包的过程，大体流程如下：</p><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hqwuzhaoyi.github.io/v2-5e9c0844ec1d40b9664e0745bbb07c7a_r.jpg" alt="模块开始转译到模块合并打包的过程"></p><p>为了方便理解，我将打包过程横向切分为三个阶段：</p><ul><li><strong>「入口」</strong>：指代从 Webpack 启动到调用 <code>compilation.codeGeneration</code> 之前的所有前置操作</li><li><strong>「模块转译」</strong>：遍历 <code>modules</code> 数组，完成所有模块的转译操作，并将结果存储到 <code>compilation.codeGenerationResults</code> 对象</li><li><strong>「模块合并打包」</strong>：在特定上下文框架下，组合业务模块、<code>runtime</code> 模块，合并打包成 <code>bundle</code> ，并调用 <code>compilation.emitAsset</code> 输出产物</li></ul><p>这里说的 <strong>「业务模块」</strong> 是指开发者所编写的项目代码；<strong>「<code>runtime</code> 模块」</strong> 是指 Webpack 分析业务模块后，动态注入的用于支撑各项特性的运行时代码. <a href="#%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3-Webpack-%E8%BF%90%E8%A1%8C%E6%97%B6">彻底理解-Webpack-运行时</a></p><h3 id="模块转译原理"><a href="#模块转译原理" class="headerlink" title="模块转译原理"></a>模块转译原理</h3><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hqwuzhaoyi.github.io/v2-05007e54fce5e2e5e17706edbd3cb0d6_r.jpg" alt="Webpack 产物"></p><p>上述示例由 <code>index.js</code> / <code>name.js</code> 两个业务文件组成，对应的 Webpack 配置如上图左下角所示；Webpack 构建产物如右边 <code>main.js</code> 文件所示，包含三块内容，从上到下分别为：</p><ul><li><code>name.js</code> 模块对应的转译产物，函数形态</li><li>Webpack 按需注入的运行时代码</li><li><code>index.js</code> 模块对应的转译产物，IIFE(立即执行函数) 形态</li></ul><p>以看到产物与源码语义、功能均相同，但表现形式发生了较大变化，例如 index.js 编译前后的内容：</p><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hqwuzhaoyi.github.io/v2-b45326712da78769b9dd45317507f118_r.jpg" alt="运行时代码的作用与生成逻辑"></p><p>上图右边是 Webpack 编译产物中对应的代码，相对于左边的源码有如下变化：</p><ul><li>整个模块被包裹进 IIFE (立即执行函数)中</li><li>添加 <code>__webpack_require__.r(__webpack_exports__);</code> 语句，用于适配 ESM 规范</li><li>源码中的 <code>import</code> 语句被转译为 <code>__webpack_require__</code> 函数调用</li><li>源码 <code>console</code> 语句所使用的 <code>name</code> 变量被转译为 <code>_name__WEBPACK_IMPORTED_MODULE_0__.default</code></li><li>添加注释</li></ul><h4 id="核心流程"><a href="#核心流程" class="headerlink" title="核心流程"></a>核心流程</h4><p><strong>「模块转译」</strong> 操作从 <code>module.codeGeneration</code> 调用开始，对应到上述流程图的：</p><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hqwuzhaoyi.github.io/v2-9694aa2a7519c7480188f0688c550a4f_r.jpg" alt="「模块转译」"></p><ul><li>调用 <code>JavascriptGenerator</code> 的对象的 <code>generate</code> 方法，方法内部：<ol><li>遍历模块的 <code>dependencies</code> 与 <code>presentationalDependencies</code> 数组</li><li>执行每个数组项 <code>dependency</code> 对象的对应的 <code>Template.apply</code> 方法，在 <code>apply</code> 内修改模块代码，或更新 <code>initFragments</code> 数组</li></ol></li><li>遍历完毕后，调用 <code>InitFragment.addToSource</code> 静态方法，将上一步操作产生的 <code>source</code> 对象与 <code>initFragments</code> 数组合并为模块产物</li></ul><p>简单说就是<strong>遍历依赖</strong>，在<strong>依赖对象</strong>中修改 <code>module</code> 代码，最后再将所有变更<strong>合并为最终产物</strong>。这里面关键点：</p><ol><li>在 <code>Template.apply</code> 函数中，如何更新模块代码</li><li>在 <code>InitFragment.addToSource</code> 静态方法中，如何将 <code>Template.apply</code> 所产生的 <code>side effect</code> 合并为最终产物</li></ol><h4 id="Template-apply-函数"><a href="#Template-apply-函数" class="headerlink" title="Template.apply 函数"></a>Template.apply 函数</h4><p>上述流程中，<code>JavascriptGenerator</code> 类是毋庸置疑的 C 位角色，但它并不直接修改 <code>module</code> 的内容，而是绕了几层后委托交由 <code>Template</code> 类型实现。</p><p>Webpack 5 源码中，<code>JavascriptGenerator.generate</code> 函数会遍历模块的 <code>dependencies</code> 数组，调用依赖对象对应的 <code>Template</code> 子类 <code>apply</code> 方法更新模块内容，说起来有点绕，原始代码更饶，所以我将重要步骤抽取为如下伪代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JavascriptGenerator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">generate</span>(<span class="params"><span class="built_in">module</span>, generateContext</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 先取出 module 的原始代码内容</span></span><br><span class="line">        <span class="keyword">const</span> source = <span class="keyword">new</span> ReplaceSource(<span class="built_in">module</span>.originalSource());</span><br><span class="line">        <span class="keyword">const</span> &#123; dependencies, presentationalDependencies &#125; = <span class="built_in">module</span>;</span><br><span class="line">        <span class="keyword">const</span> initFragments = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> dependency <span class="keyword">of</span> [...dependencies, ...presentationalDependencies]) &#123;</span><br><span class="line">            <span class="comment">// 找到 dependency 对应的 template</span></span><br><span class="line">            <span class="keyword">const</span> template = generateContext.dependencyTemplates.get(dependency.constructor);</span><br><span class="line">            <span class="comment">// 调用 template.apply，传入 source、initFragments</span></span><br><span class="line">            <span class="comment">// 在 apply 函数可以直接修改 source 内容，或者更改 initFragments 数组，影响后续转译逻辑</span></span><br><span class="line">            template.apply(dependency, source, &#123;initFragments&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历完毕后，调用 InitFragment.addToSource 合并 source 与 initFragments</span></span><br><span class="line">        <span class="keyword">return</span> InitFragment.addToSource(source, initFragments, generateContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dependency 子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">xxxDependency</span> <span class="keyword">extends</span> <span class="title">Dependency</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dependency 子类对应的 Template 定义</span></span><br><span class="line"><span class="keyword">const</span> xxxDependency.Template = <span class="class"><span class="keyword">class</span> <span class="title">xxxDependencyTemplate</span> <span class="keyword">extends</span> <span class="title">Template</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">apply</span>(<span class="params">dep, source, &#123;initFragments&#125;</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 直接操作 source，更改模块代码</span></span><br><span class="line">        source.replace(dep.range[<span class="number">0</span>], dep.range[<span class="number">1</span>] - <span class="number">1</span>, <span class="string">&#x27;some thing&#x27;</span>)</span><br><span class="line">        <span class="comment">// 2. 通过添加 InitFragment 实例，补充代码</span></span><br><span class="line">        initFragments.push(<span class="keyword">new</span> xxxInitFragment())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述伪代码可以看出，<code>JavascriptGenerator.generate</code> 函数的逻辑相对比较固化：</p><ol><li>初始化一系列变量</li><li>遍历 <code>module</code> 对象的依赖数组，找到每个 <code>dependency</code> 对应的 <code>template</code> 对象，调用 <code>template.apply</code> 函数修改模块内容</li><li>调用 <code>InitFragment.addToSource</code> 方法，合并 <code>source</code> 与 <code>initFragments</code> 数组，生成最终结果</li></ol><p>这里的重点是 <code>JavascriptGenerator.generate</code> 函数并不操作 <code>module</code> 源码，它仅仅提供一个执行框架，真正处理模块内容转译的逻辑都在 <code>xxxDependencyTemplate</code> 对象的 <code>apply</code> 函数实现，如上例伪代码中 <strong><em>24-28</em></strong> 行。</p><p>每个 <code>Dependency</code> 子类都会映射到一个唯一的 <code>Template</code> 子类，且通常这两个类都会写在同一个文件中，例如 <code>ConstDependency</code> 与 <code>ConstDependencyTemplate``；NullDependency</code> 与 <code>NullDependencyTemplate</code>。Webpack 构建(<code>make</code>)阶段，会通过 <code>Dependency</code> 子类记录不同情况下模块之间的依赖关系；到生成(<code>seal</code>)阶段再通过 <code>Template</code> 子类修改 <code>module</code> 代码。</p><p>综上 <code>Module</code>、<code>JavascriptGenerator</code>、<code>Dependency</code>、<code>Template</code> 四个类形成如下交互关系：</p><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hqwuzhaoyi.github.io/v2-42ade2e92de558e40ab78811e966661e_r.jpg" alt="四个类形成如下交互关系"></p><p><code>Template</code> 对象可以通过两种方法更新 <code>module</code> 的代码：</p><p>直接操作 <code>source</code> 对象，直接修改模块代码，该对象最初的内容等于模块的源码，经过多个 <code>Template.apply</code> 函数流转后逐渐被替换成新的代码形式<br>操作 <code>initFragments</code> 数组，在模块源码之外插入补充代码片段<br>这两种操作所产生的 <code>side effect</code>，最终都会被传入 <code>InitFragment.addToSource</code> 函数，合成最终结果，下面简单补充一些细节。</p><h5 id="使用-Source-更改代码"><a href="#使用-Source-更改代码" class="headerlink" title="使用 Source 更改代码"></a>使用 Source 更改代码</h5><p><code>Source</code> 是 Webpack 中编辑字符串的一套工具体系，提供了一系列字符串操作方法，包括：</p><ul><li>字符串合并、替换、插入等</li><li>模块代码缓存、sourcemap 映射、hash 计算等</li></ul><p>Webpack 内部以及社区的很多插件、loader 都会使用 <code>Source</code> 库编辑代码内容，包括上文介绍的 <code>Template.apply</code> 体系中，逻辑上，在启动模块代码生成流程时，Webpack 会先用模块原本的内容初始化 <code>Source</code> 对象，即：</p><p><code>const source = new ReplaceSource(module.originalSource());</code></p><p>之后，不同 <code>Dependency</code> 子类按序、按需更改 <code>source</code> 内容，例如 <code>ConstDependencyTemplate</code> 中的核心代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ConstDependency.Template = <span class="class"><span class="keyword">class</span> <span class="title">ConstDependencyTemplate</span> <span class="keyword">extends</span> (</span></span><br><span class="line"><span class="class">  <span class="title">NullDependency</span>.<span class="title">Template</span></span></span><br><span class="line"><span class="class">) </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">apply</span>(<span class="params">dependency, source, templateContext</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> dep.range === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">      source.insert(dep.range, dep.expression);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    source.replace(dep.range[<span class="number">0</span>], dep.range[<span class="number">1</span>] - <span class="number">1</span>, dep.expression);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述 <code>ConstDependencyTemplate</code> 中，<code>apply</code> 函数根据参数条件调用 <code>source.insert</code> 插入一段代码，或者调用 <code>source.replace</code> 替换一段代码。</p><h5 id="使用-InitFragment-更新代码"><a href="#使用-InitFragment-更新代码" class="headerlink" title="使用 InitFragment 更新代码"></a>使用 InitFragment 更新代码</h5><p>除直接操作 <code>source</code> 外，<code>Template.apply</code> 中还可以通过操作 <code>initFragments</code> 数组达成修改模块产物的效果。<code>initFragments</code> 数组项通常为 <code>InitFragment</code> 子类实例，它们通常带有两个函数： <code>getContent</code>、<code>getEndContent</code>，分别用于获取代码片段的头尾部分。</p><p>例如 <code>HarmonyImportDependencyTemplate</code> 的 <code>apply</code> 函数中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">HarmonyImportDependency.Template = <span class="class"><span class="keyword">class</span> <span class="title">HarmonyImportDependencyTemplate</span> <span class="keyword">extends</span> (</span></span><br><span class="line"><span class="class">  <span class="title">ModuleDependency</span>.<span class="title">Template</span></span></span><br><span class="line"><span class="class">) </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">apply</span>(<span class="params">dependency, source, templateContext</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    templateContext.initFragments.push(</span><br><span class="line">      <span class="keyword">new</span> ConditionalInitFragment(</span><br><span class="line">        importStatement[<span class="number">0</span>] + importStatement[<span class="number">1</span>],</span><br><span class="line">        InitFragment.STAGE_HARMONY_IMPORTS,</span><br><span class="line">        dep.sourceOrder,</span><br><span class="line">        key,</span><br><span class="line">        runtimeCondition</span><br><span class="line">      )</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="代码合并"><a href="#代码合并" class="headerlink" title="代码合并"></a>代码合并</h4><p>上述 <code>Template.apply</code> 处理完毕后，产生转译后的 <code>source</code> 对象与代码片段 <code>initFragments</code> 数组，接着就需要调用 <code>InitFragment.addToSource</code> 函数将两者合并为模块产物。</p><p><code>addToSource</code> 的核心代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InitFragment</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">addToSource</span>(<span class="params">source, initFragments, generateContext</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 先排好顺序</span></span><br><span class="line">    <span class="keyword">const</span> sortedFragments = initFragments</span><br><span class="line">      .map(extractFragmentIndex)</span><br><span class="line">      .sort(sortFragmentWithIndex);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> concatSource = <span class="keyword">new</span> ConcatSource();</span><br><span class="line">    <span class="keyword">const</span> endContents = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> fragment <span class="keyword">of</span> sortedFragments) &#123;</span><br><span class="line">      <span class="comment">// 合并 fragment.getContent 取出的片段内容</span></span><br><span class="line">      concatSource.add(fragment.getContent(generateContext));</span><br><span class="line">      <span class="keyword">const</span> endContent = fragment.getEndContent(generateContext);</span><br><span class="line">      <span class="keyword">if</span> (endContent) &#123;</span><br><span class="line">        endContents.push(endContent);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并 source</span></span><br><span class="line">    concatSource.add(source);</span><br><span class="line">    <span class="comment">// 合并 fragment.getEndContent 取出的片段内容</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> content <span class="keyword">of</span> endContents.reverse()) &#123;</span><br><span class="line">      concatSource.add(content);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> concatSource;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>addToSource</code> 函数的逻辑：</p><ol><li>遍历 <code>initFragments</code> 数组，按顺序合并 <code>fragment.getContent()</code> 的产物</li><li>合并 <code>source</code> 对象</li><li>遍历 <code>initFragments</code> 数组，按顺序合并 <code>fragment.getEndContent()</code> 的产物</li></ol><p>所以，模块代码合并操作主要就是用 <code>initFragments</code> 数组一层一层包裹住模块代码 <code>source</code>，而两者都在 <code>Template.apply</code> 层面维护。</p><h4 id="自定义-banner-插件"><a href="#自定义-banner-插件" class="headerlink" title="自定义 banner 插件"></a>自定义 banner 插件</h4><p>经过 <code>Template.apply</code> 转译与 <code>InitFragment.addToSource</code> 合并之后，模块就完成了从用户代码形态到产物形态的转变，为加深对上述 <strong>「模块转译」</strong> 流程的理解，接下来我们尝试开发一个 <code>Banner</code> 插件，实现在每个模块前自动插入一段字符串。</p><p>实现上，插件主要涉及 <code>Dependency</code>、<code>Template</code>、<code>hooks</code> 对象，代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Dependency, Template &#125; = <span class="built_in">require</span>(<span class="string">&quot;webpack&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoDependency</span> <span class="keyword">extends</span> <span class="title">Dependency</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DemoDependency.Template = <span class="class"><span class="keyword">class</span> <span class="title">DemoDependencyTemplate</span> <span class="keyword">extends</span> <span class="title">Template</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">apply</span>(<span class="params">dependency, source</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> today = <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleDateString();</span><br><span class="line">    source.insert(</span><br><span class="line">      <span class="number">0</span>,</span><br><span class="line">      <span class="string">`/* Author: Tecvan */</span></span><br><span class="line"><span class="string">/* Date: <span class="subst">$&#123;today&#125;</span> */</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="title">DemoPlugin</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">apply</span>(<span class="params">compiler</span>)</span> &#123;</span><br><span class="line">    compiler.hooks.thisCompilation.tap(<span class="string">&quot;DemoPlugin&quot;</span>, <span class="function">(<span class="params">compilation</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 调用 dependencyTemplates ，注册 Dependency 到 Template 的映射</span></span><br><span class="line">      compilation.dependencyTemplates.set(</span><br><span class="line">        DemoDependency,</span><br><span class="line">        <span class="keyword">new</span> DemoDependency.Template()</span><br><span class="line">      );</span><br><span class="line">      compilation.hooks.succeedModule.tap(<span class="string">&quot;DemoPlugin&quot;</span>, <span class="function">(<span class="params"><span class="built_in">module</span></span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 模块构建完毕后，插入 DemoDependency 对象</span></span><br><span class="line">        <span class="built_in">module</span>.addDependency(<span class="keyword">new</span> DemoDependency());</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关键步骤：</p><ul><li>编写 <code>DemoDependency</code> 与 <code>DemoDependencyTemplate</code> 类，其中 <code>DemoDependency</code> 仅做示例用，没有实际功能；<code>DemoDependencyTemplate</code>则在其 <code>apply</code> 中调用 <code>source.insert</code> 插入字符串，如示例代码第 <strong><em>10-14</em></strong> 行</li><li>使用 <code>compilation.dependencyTemplates</code> 注册 <code>DemoDependency</code> 与 <code>DemoDependencyTemplate</code> 的映射关系</li><li>使用 <code>thisCompilation</code> 钩子取得 <code>compilation</code> 对象</li><li>使用 <code>succeedModule</code> 钩子订阅 <code>module</code> 构建完毕事件，并调用 <code>module.addDependency</code> 方法添加 <code>DemoDependency</code> 依赖</li></ul><p><code>module</code> 对象的产物在生成过程就会调用到 <code>DemoDependencyTemplate.apply</code> 函数，插入我们定义好的字符串，效果如：</p><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hqwuzhaoyi.github.io/v2-56c541047a194e96607a7abc5f3112d2_r.jpg" alt="插入我们定义好的字符串"></p><ul><li><code>lib/dependencies/ConstDependency.js</code>，一个简单示例，可学习 <code>source</code> 的更多操作方法</li><li><code>lib/dependencies/HarmonyExportSpecifierDependencyTemplate.js</code>，一个简单示例，可学习 <code>initFragments</code> 数组的更多用法<br>l- <code>ib/dependencies/HarmonyImportDependencyTemplate.js</code>，一个较复杂但使用率极高的示例，可综合学习 <code>source``、initFragments</code> 数组的用法</li></ul><h3 id="模块合并打包原理"><a href="#模块合并打包原理" class="headerlink" title="模块合并打包原理"></a>模块合并打包原理</h3><p>讲完单个模块的转译过程后，我们先回到这个流程图：</p><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hqwuzhaoyi.github.io/v2-c4550e909eb6646a78fba5a64636641a_r.jpg" alt="模块合并打包"></p><p>流程图中，<code>compilation.codeGeneration</code> 函数执行完毕 —— 也就是模块转译阶段完成后，模块的转译结果会一一保存到 <code>compilation.codeGenerationResults</code> 对象中，之后会启动一个新的执行流程 —— <strong>「模块合并打包」</strong>。</p><p><strong>「模块合并打包」</strong> 过程会将 <code>chunk</code> 对应的 <code>module</code> 及 <code>runtimeModule</code> 按规则塞进 「<strong>模板框架」</strong> 中，最终合并输出成完整的 <code>bundle</code> 文件，例如上例中：</p><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hqwuzhaoyi.github.io/v2-05007e54fce5e2e5e17706edbd3cb0d6_r.jpg" alt="最终合并输出成完整的 `bundle`"></p><p>示例右边 <code>bundle</code> 文件中，红框框出来的部分为用户代码文件及运行时模块生成的产物，其余部分撑起了一个 IIFE 形式的运行框架即为 <strong>「模板框架」</strong>，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// webpackBootstrap</span></span><br><span class="line"><span class="meta">  &quot;use strict&quot;</span>;</span><br><span class="line">  <span class="keyword">var</span> __webpack_modules__ = &#123;</span><br><span class="line">    <span class="string">&quot;module-a&quot;</span>: (</span><br><span class="line">      __unused_webpack_module,</span><br><span class="line">      __webpack_exports__,</span><br><span class="line">      __webpack_require__</span><br><span class="line">    ) =&gt; &#123;</span><br><span class="line">      <span class="comment">// ! module 代码，</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;module-b&quot;</span>: (</span><br><span class="line">      __unused_webpack_module,</span><br><span class="line">      __webpack_exports__,</span><br><span class="line">      __webpack_require__</span><br><span class="line">    ) =&gt; &#123;</span><br><span class="line">      <span class="comment">// ! module 代码，</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// The module cache</span></span><br><span class="line">  <span class="keyword">var</span> __webpack_module_cache__ = &#123;&#125;;</span><br><span class="line">  <span class="comment">// The require function</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ! webpack CMD 实现</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/************************************************************************/</span></span><br><span class="line">  <span class="comment">// ! 各种 runtime</span></span><br><span class="line">  <span class="comment">/************************************************************************/</span></span><br><span class="line">  <span class="keyword">var</span> __webpack_exports__ = &#123;&#125;;</span><br><span class="line">  <span class="comment">// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.</span></span><br><span class="line">  (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ! entry 模块</span></span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><ul><li>最外层由一个 IIFE 包裹</li><li>一个记录了除 <code>entry</code> 外的其它模块代码的 <code>__webpack_modules__</code> 对象，对象的 key 为模块标志符；值为模块转译后的代码</li><li>一个极度简化的 CMD 实现： <code>__webpack_require__</code> 函数</li><li>最后，一个包裹了 <code>entry</code> 代码的 IIFE 函数</li></ul><p><strong>「模块转译」</strong> 是将 <code>module</code> 转译为可以在宿主环境如浏览器上运行的代码形式；而 <strong>「模块合并」</strong> 操作则串联这些 <code>modules</code> ，使之整体符合开发预期，能够正常运行整个应用逻辑。接下来，我们揭晓这部分代码的生成原理。</p><h3 id="核心流程-1"><a href="#核心流程-1" class="headerlink" title="核心流程"></a>核心流程</h3><p>在 <code>compilation.codeGeneration</code> 执行完毕，即所有用户代码模块与运行时模块都执行完转译操作后，<code>seal</code> 函数调用 <code>compilation.createChunkAssets</code> 函数，触发 <code>renderManifest</code> <code>钩子，JavascriptModulesPlugin</code> 插件监听到这个钩子消息后开始组装 <code>bundle</code>，伪代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Webpack 5</span></span><br><span class="line"><span class="comment">// lib/Compilation.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compilation</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">seal</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 先把所有模块的代码都转译，准备好</span></span><br><span class="line">    <span class="built_in">this</span>.codeGenerationResults = <span class="built_in">this</span>.codeGeneration(<span class="built_in">this</span>.modules);</span><br><span class="line">    <span class="comment">// 1. 调用 createChunkAssets</span></span><br><span class="line">    <span class="built_in">this</span>.createChunkAssets();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">createChunkAssets</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历 chunks ，为每个 chunk 执行 render 操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> chunk <span class="keyword">of</span> <span class="built_in">this</span>.chunks) &#123;</span><br><span class="line">      <span class="comment">// 2. 触发 renderManifest 钩子</span></span><br><span class="line">      <span class="keyword">const</span> res = <span class="built_in">this</span>.hooks.renderManifest.call([], &#123;</span><br><span class="line">        chunk,</span><br><span class="line">        codeGenerationResults: <span class="built_in">this</span>.codeGenerationResults,</span><br><span class="line">        ...others,</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">// 提交组装结果</span></span><br><span class="line">      <span class="built_in">this</span>.emitAsset(res.render(), ...others);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lib/javascript/JavascriptModulesPlugin.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JavascriptModulesPlugin</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">apply</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    compiler.hooks.compilation.tap(<span class="string">&quot;JavascriptModulesPlugin&quot;</span>, <span class="function">(<span class="params">compilation</span>) =&gt;</span> &#123;</span><br><span class="line">      compilation.hooks.renderManifest.tap(<span class="string">&quot;JavascriptModulesPlugin&quot;</span>, <span class="function">(<span class="params">result, options</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// JavascriptModulesPlugin 插件中通过 renderManifest 钩子返回组装函数 render</span></span><br><span class="line">          <span class="keyword">const</span> render = <span class="function">() =&gt;</span></span><br><span class="line">            <span class="comment">// render 内部根据 chunk 内容，选择使用模板 `renderMain` 或 `renderChunk`</span></span><br><span class="line">            <span class="comment">// 3. 监听钩子，返回打包函数</span></span><br><span class="line">            <span class="built_in">this</span>.renderMain(options);</span><br><span class="line"></span><br><span class="line">          result.push(&#123; render <span class="comment">/* arguments */</span> &#125;);</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">renderMain</span>(<span class="params"></span>)</span> &#123;<span class="comment">/*  */</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">renderChunk</span>(<span class="params"></span>)</span> &#123;<span class="comment">/*  */</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的核心逻辑是，<code>compilation</code> 以 <code>renderManifest</code> 钩子方式对外发布 <code>bundle</code> 打包需求； <code>JavascriptModulesPlugin</code> 监听这个钩子，按照 <code>chunk</code> 的内容特性，调用不同的打包函数。</p><p><strong>上述仅针对 Webpack 5。在 Webpack 4 中，打包逻辑集中在 MainTemplate 完成。</strong></p><p>两个打包函数实现的逻辑接近，都是按顺序拼接各个模块，下面简单介绍下 <code>renderMain</code> 的实现。</p><h3 id="renderMain-函数"><a href="#renderMain-函数" class="headerlink" title="renderMain 函数"></a>renderMain 函数</h3><p><code>renderMain</code> 函数涉及比较多场景判断，原始代码很长很绕，我摘了几个重点步骤</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JavascriptModulesPlugin</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">renderMain</span>(<span class="params">renderContext, hooks, compilation</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; chunk, chunkGraph, runtimeTemplate &#125; = renderContext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> source = <span class="keyword">new</span> ConcatSource();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 1. 先计算出 bundle CMD 核心代码，包含：</span></span><br><span class="line">    <span class="comment">//      - &quot;var __webpack_module_cache__ = &#123;&#125;;&quot; 语句</span></span><br><span class="line">    <span class="comment">//      - &quot;__webpack_require__&quot; 函数</span></span><br><span class="line">    <span class="keyword">const</span> bootstrap = <span class="built_in">this</span>.renderBootstrap(renderContext, hooks);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 计算出当前 chunk 下，除 entry 外其它模块的代码</span></span><br><span class="line">    <span class="keyword">const</span> chunkModules = Template.renderChunkModules(</span><br><span class="line">      renderContext,</span><br><span class="line">      inlinedModules</span><br><span class="line">        ? allModules.filter(<span class="function">(<span class="params">m</span>) =&gt;</span> !inlinedModules.has(m))</span><br><span class="line">        : allModules,</span><br><span class="line">      (<span class="built_in">module</span>) =&gt;</span><br><span class="line">        <span class="built_in">this</span>.renderModule(</span><br><span class="line">          <span class="built_in">module</span>,</span><br><span class="line">          renderContext,</span><br><span class="line">          hooks,</span><br><span class="line">          allStrict ? <span class="string">&quot;strict&quot;</span> : <span class="literal">true</span></span><br><span class="line">        ),</span><br><span class="line">      prefix</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 计算出运行时模块代码</span></span><br><span class="line">    <span class="keyword">const</span> runtimeModules =</span><br><span class="line">      renderContext.chunkGraph.getChunkRuntimeModulesInOrder(chunk);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 重点来了，开始拼接 bundle</span></span><br><span class="line">    <span class="comment">// 4.1 首先，合并核心 CMD 实现，即上述 bootstrap 代码</span></span><br><span class="line">    <span class="keyword">const</span> beforeStartup = Template.asString(bootstrap.beforeStartup) + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    source.add(</span><br><span class="line">      <span class="keyword">new</span> PrefixSource(</span><br><span class="line">        prefix,</span><br><span class="line">        useSourceMap</span><br><span class="line">          ? <span class="keyword">new</span> OriginalSource(beforeStartup, <span class="string">&quot;webpack/before-startup&quot;</span>)</span><br><span class="line">          : <span class="keyword">new</span> RawSource(beforeStartup)</span><br><span class="line">      )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.2 合并 runtime 模块代码</span></span><br><span class="line">    <span class="keyword">if</span> (runtimeModules.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">module</span> <span class="keyword">of</span> runtimeModules) &#123;</span><br><span class="line">        compilation.codeGeneratedModules.add(<span class="built_in">module</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.3 合并除 entry 外其它模块代码</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> m <span class="keyword">of</span> chunkModules) &#123;</span><br><span class="line">      <span class="keyword">const</span> renderedModule = <span class="built_in">this</span>.renderModule(m, renderContext, hooks, <span class="literal">false</span>);</span><br><span class="line">      source.add(renderedModule)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.4 合并 entry 模块代码</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      hasEntryModules &amp;&amp;</span><br><span class="line">      runtimeRequirements.has(RuntimeGlobals.returnExportsFromRuntime)</span><br><span class="line">    ) &#123;</span><br><span class="line">      source.add(<span class="string">`<span class="subst">$&#123;prefix&#125;</span>return __webpack_exports__;\n`</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> source;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>先计算出 <code>bundle CMD</code> 代码，即 <code>__webpack_require__</code> 函数</li><li>计算出当前 <code>chunk</code> 下，除 <code>entry</code> 外其它模块代码 <code>chunkModules</code></li><li>计算出运行时模块代码</li><li>开始执行合并操作，子步骤有：<ol><li>合并 <code>CMD</code> 代码</li><li>合并 <code>runtime</code> 模块代码</li><li>遍历 <code>chunkModules</code> 变量，合并除 <code>entry</code> 外其它模块代码</li><li>合并 <code>entry</code> 模块代码</li></ol></li><li>返回结果</li></ol><p>总结：先计算出不同组成部分的产物形态，之后按顺序拼接打包，输出合并后的版本。</p><p>至此，Webpack 完成 <code>bundle</code> 的转译、打包流程，后续调用 <code>compilation.emitAsset</code> ，按上下文环境将产物输出到 <code>fs</code> 即可，Webpack 单次编译打包过程就结束了。</p><p>详细讨论了打包流程后半截 —— 从 <code>chunk graph</code> 生成一直到最终输出产物的实现逻辑，重点：</p><ul><li>首先遍历 <code>chunk</code> 中的所有模块，为每个模块执行转译操作，产出模块级别的产物</li><li>根据 <code>chunk</code> 的类型，选择不同结构框架，按序逐次组装模块产物，打包成最终 <code>bundle</code></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Webpack-核心原理&quot;&gt;&lt;a href=&quot;#Webpack-核心原理&quot; class=&quot;headerlink&quot; title=&quot;Webpack 核心原理&quot;&gt;&lt;/a&gt;Webpack 核心原理&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhih</summary>
      
    
    
    
    <category term="webpack" scheme="https://hqwuzhaoyi.github.io/categories/webpack/"/>
    
    
    <category term="源码" scheme="https://hqwuzhaoyi.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="webpack" scheme="https://hqwuzhaoyi.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>react 源码-迷你 react</title>
    <link href="https://hqwuzhaoyi.github.io/2021/06/01/react%20%E6%BA%90%E7%A0%81/11.%E7%AE%80%E5%8D%95react/"/>
    <id>https://hqwuzhaoyi.github.io/2021/06/01/react%20%E6%BA%90%E7%A0%81/11.%E7%AE%80%E5%8D%95react/</id>
    <published>2021-06-01T00:00:00.000Z</published>
    <updated>2022-08-29T03:13:16.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="迷你-react"><a href="#迷你-react" class="headerlink" title="迷你 react"></a>迷你 react</h1><p>迷你 react 和真正的源码有哪些区别呢</p><p>在 <code>render</code> 阶段我们遍历了整颗 <code>Fiber</code> 树，在源码中如果节点什么都没改变会命中优化的逻辑，然后跳过这个节点的遍历<br><code>commit</code> 我们也遍历了整颗 <code>Fiber</code> 树，源码中只遍历带有 <code>effect</code> 的 <code>Fiber</code> 节点，也就是遍历 <code>effectList</code><br>每次遍历的时候我们都是新建节点，源码中某些条件会复用节点没有用到优先级</p><h2 id="第一步：渲染器和入口函数"><a href="#第一步：渲染器和入口函数" class="headerlink" title="第一步：渲染器和入口函数"></a>第一步：渲染器和入口函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> React = &#123;</span><br><span class="line">  createElement,</span><br><span class="line">  render,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> updateValue = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  reRender(e.target.value);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reRender = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> element = (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input onInput=&#123;updateValue&#125; value=&#123;value&#125; /&gt;</span><br><span class="line">      &lt;h2&gt;Hello &#123;value&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">  React.render(element, container);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">reRender(<span class="string">&quot;World&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="第二步：创建-dom-节点函数"><a href="#第二步：创建-dom-节点函数" class="headerlink" title="第二步：创建 dom 节点函数"></a>第二步：创建 dom 节点函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">type, props, ...children</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//创建element</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type,</span><br><span class="line">    props: &#123;</span><br><span class="line">      ...props,</span><br><span class="line">      children: children.map(<span class="function">(<span class="params">child</span>) =&gt;</span></span><br><span class="line">        <span class="keyword">typeof</span> child === <span class="string">&quot;object&quot;</span> ? child : createTextElement(child)</span><br><span class="line">      ),</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createTextElement</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//创建text类型</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: <span class="string">&quot;TEXT_ELEMENT&quot;</span>,</span><br><span class="line">    props: &#123;</span><br><span class="line">      nodeValue: text,</span><br><span class="line">      children: [],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createDom</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//创建dom</span></span><br><span class="line">  <span class="keyword">const</span> dom =</span><br><span class="line">    fiber.type == <span class="string">&quot;TEXT_ELEMENT&quot;</span></span><br><span class="line">      ? <span class="built_in">document</span>.createTextNode(<span class="string">&quot;&quot;</span>)</span><br><span class="line">      : <span class="built_in">document</span>.createElement(fiber.type);</span><br><span class="line"></span><br><span class="line">  updateDom(dom, &#123;&#125;, fiber.props);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第三步：更新节点函数"><a href="#第三步：更新节点函数" class="headerlink" title="第三步：更新节点函数"></a>第三步：更新节点函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isEvent = <span class="function">(<span class="params">key</span>) =&gt;</span> key.startsWith(<span class="string">&quot;on&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> isProperty = <span class="function">(<span class="params">key</span>) =&gt;</span> key !== <span class="string">&quot;children&quot;</span> &amp;&amp; !isEvent(key);</span><br><span class="line"><span class="keyword">const</span> isNew = <span class="function">(<span class="params">prev, next</span>) =&gt;</span> <span class="function">(<span class="params">key</span>) =&gt;</span> prev[key] !== next[key];</span><br><span class="line"><span class="keyword">const</span> isGone = <span class="function">(<span class="params">prev, next</span>) =&gt;</span> <span class="function">(<span class="params">key</span>) =&gt;</span> !(key <span class="keyword">in</span> next);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateDom</span>(<span class="params">dom, prevProps, nextProps</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//更新节点属性</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//删除老的事件</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(prevProps)</span><br><span class="line">    .filter(isEvent)</span><br><span class="line">    .filter(<span class="function">(<span class="params">key</span>) =&gt;</span> !(key <span class="keyword">in</span> nextProps) || isNew(prevProps, nextProps)(key))</span><br><span class="line">    .forEach(<span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> eventType = name.toLowerCase().substring(<span class="number">2</span>);</span><br><span class="line">      dom.removeEventListener(eventType, prevProps[name]);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除旧属性</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(prevProps)</span><br><span class="line">    .filter(isProperty)</span><br><span class="line">    .filter(isGone(prevProps, nextProps))</span><br><span class="line">    .forEach(<span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">      dom[name] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置新属性</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(nextProps)</span><br><span class="line">    .filter(isProperty)</span><br><span class="line">    .filter(isNew(prevProps, nextProps))</span><br><span class="line">    .forEach(<span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">      dom[name] = nextProps[name];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 增加新事件</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(nextProps)</span><br><span class="line">    .filter(isEvent)</span><br><span class="line">    .filter(isNew(prevProps, nextProps))</span><br><span class="line">    .forEach(<span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> eventType = name.toLowerCase().substring(<span class="number">2</span>);</span><br><span class="line">      dom.addEventListener(eventType, nextProps[name]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第四步：render-阶段"><a href="#第四步：render-阶段" class="headerlink" title="第四步：render 阶段"></a>第四步：render 阶段</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//render阶段</span></span><br><span class="line">  <span class="keyword">if</span> (!fiber.dom) &#123;</span><br><span class="line">    fiber.dom = createDom(fiber);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> elements = fiber.props.children;</span><br><span class="line">  reconcileChildren(fiber, elements);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fiber.child) &#123;</span><br><span class="line">    <span class="keyword">return</span> fiber.child;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> nextFiber = fiber;</span><br><span class="line">  <span class="keyword">while</span> (nextFiber) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextFiber.sibling) &#123;</span><br><span class="line">      <span class="keyword">return</span> nextFiber.sibling;</span><br><span class="line">    &#125;</span><br><span class="line">    nextFiber = nextFiber.parent;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileChildren</span>(<span class="params">wipFiber, elements</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//reconcile节点</span></span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> oldFiber = wipFiber.alternate &amp;&amp; wipFiber.alternate.child;</span><br><span class="line">  <span class="keyword">let</span> prevSibling = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (index &lt; elements.length || oldFiber != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> element = elements[index];</span><br><span class="line">    <span class="keyword">let</span> newFiber = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> sameType = oldFiber &amp;&amp; element &amp;&amp; element.type == oldFiber.type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sameType) &#123;</span><br><span class="line">      newFiber = &#123;</span><br><span class="line">        type: oldFiber.type,</span><br><span class="line">        props: element.props,</span><br><span class="line">        dom: oldFiber.dom,</span><br><span class="line">        parent: wipFiber,</span><br><span class="line">        alternate: oldFiber,</span><br><span class="line">        effectTag: <span class="string">&quot;UPDATE&quot;</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (element &amp;&amp; !sameType) &#123;</span><br><span class="line">      newFiber = &#123;</span><br><span class="line">        type: element.type,</span><br><span class="line">        props: element.props,</span><br><span class="line">        dom: <span class="literal">null</span>,</span><br><span class="line">        parent: wipFiber,</span><br><span class="line">        alternate: <span class="literal">null</span>,</span><br><span class="line">        effectTag: <span class="string">&quot;PLACEMENT&quot;</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (oldFiber &amp;&amp; !sameType) &#123;</span><br><span class="line">      oldFiber.effectTag = <span class="string">&quot;DELETION&quot;</span>;</span><br><span class="line">      deletions.push(oldFiber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldFiber) &#123;</span><br><span class="line">      oldFiber = oldFiber.sibling;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">      wipFiber.child = newFiber;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element) &#123;</span><br><span class="line">      prevSibling.sibling = newFiber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    prevSibling = newFiber;</span><br><span class="line">    index++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第五步：commit-阶段"><a href="#第五步：commit-阶段" class="headerlink" title="第五步：commit 阶段"></a>第五步：commit 阶段</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitRoot</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//commit阶段</span></span><br><span class="line">  deletions.forEach(commitWork);</span><br><span class="line">  commitWork(wipRoot.child);</span><br><span class="line">  currentRoot = wipRoot;</span><br><span class="line">  wipRoot = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//操作真实dom</span></span><br><span class="line">  <span class="keyword">if</span> (!fiber) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> domParent = fiber.parent.dom;</span><br><span class="line">  <span class="keyword">if</span> (fiber.effectTag === <span class="string">&quot;PLACEMENT&quot;</span> &amp;&amp; fiber.dom != <span class="literal">null</span>) &#123;</span><br><span class="line">    domParent.appendChild(fiber.dom);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fiber.effectTag === <span class="string">&quot;UPDATE&quot;</span> &amp;&amp; fiber.dom != <span class="literal">null</span>) &#123;</span><br><span class="line">    updateDom(fiber.dom, fiber.alternate.props, fiber.props);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fiber.effectTag === <span class="string">&quot;DELETION&quot;</span>) &#123;</span><br><span class="line">    domParent.removeChild(fiber.dom);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  commitWork(fiber.child);</span><br><span class="line">  commitWork(fiber.sibling);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第六步：开始调度"><a href="#第六步：开始调度" class="headerlink" title="第六步：开始调度"></a>第六步：开始调度</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">element, container</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//渲染开始的入口</span></span><br><span class="line">  wipRoot = &#123;</span><br><span class="line">    dom: container,</span><br><span class="line">    props: &#123;</span><br><span class="line">      children: [element],</span><br><span class="line">    &#125;,</span><br><span class="line">    alternate: currentRoot,</span><br><span class="line">  &#125;;</span><br><span class="line">  deletions = [];</span><br><span class="line">  nextUnitOfWork = wipRoot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nextUnitOfWork = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> currentRoot = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> wipRoot = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> deletions = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoop</span>(<span class="params">deadline</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//调度函数</span></span><br><span class="line">  <span class="keyword">let</span> shouldYield = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">while</span> (nextUnitOfWork &amp;&amp; !shouldYield) &#123;</span><br><span class="line">    nextUnitOfWork = performUnitOfWork(</span><br><span class="line">      <span class="comment">//render阶段</span></span><br><span class="line">      nextUnitOfWork</span><br><span class="line">    );</span><br><span class="line">    shouldYield = deadline.timeRemaining() &lt; <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!nextUnitOfWork &amp;&amp; wipRoot) &#123;</span><br><span class="line">    commitRoot(); <span class="comment">//commit阶段</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  requestIdleCallback(workLoop); <span class="comment">//空闲调度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">requestIdleCallback(workLoop);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;迷你-react&quot;&gt;&lt;a href=&quot;#迷你-react&quot; class=&quot;headerlink&quot; title=&quot;迷你 react&quot;&gt;&lt;/a&gt;迷你 react&lt;/h1&gt;&lt;p&gt;迷你 react 和真正的源码有哪些区别呢&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;render&lt;/c</summary>
      
    
    
    
    <category term="react 源码" scheme="https://hqwuzhaoyi.github.io/categories/react-%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="react" scheme="https://hqwuzhaoyi.github.io/tags/react/"/>
    
    <category term="源码" scheme="https://hqwuzhaoyi.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>react 源码-concurrent mode</title>
    <link href="https://hqwuzhaoyi.github.io/2021/05/27/react%20%E6%BA%90%E7%A0%81/10.%20concurrent%20mode/"/>
    <id>https://hqwuzhaoyi.github.io/2021/05/27/react%20%E6%BA%90%E7%A0%81/10.%20concurrent%20mode/</id>
    <published>2021-05-27T00:00:00.000Z</published>
    <updated>2022-08-29T03:13:16.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="concurrent-mode"><a href="#concurrent-mode" class="headerlink" title="concurrent mode"></a>concurrent mode</h1><p>​ react17 开始支持<code>concurrent mode</code>，这种模式的根本目的是为了让应用保持 cpu 和 io 的快速响应，它是一组新功能，包括 <code>Fiber</code>、<code>Scheduler</code>、<code>Lane</code>，可以根据用户硬件性能和网络状况调整应用的响应速度，核心就是为了实现异步可中断的更新。<code>concurrent mode</code> 也是未来 react 主要迭代的方向。</p><ul><li>cup：让耗时的 <code>reconcile</code> 的过程能让出 js 的执行权给更高优先级的任务，例如用户的输入，</li><li>io：依靠 <code>Suspense</code></li></ul><h2 id="Fiber"><a href="#Fiber" class="headerlink" title="Fiber"></a>Fiber</h2><p><code>Fiber</code>我们之前介绍过，这里我们来看下在 <code>concurrent mode</code> 下 <code>Fiber</code> 的意义，<code>react15</code> 之前的 <code>reconcile</code> 是同步执行的，当组件数量很多，<code>reconcile</code> 时的计算量很大时，就会出现页面的卡顿，为了解决这个问题就需要一套异步可中断的更新来让耗时的计算让出 <code>js</code> 的执行权给高优先级的任务，在浏览器有空闲的时候再执行这些计算。所以我们需要一种数据结构来描述真实 <code>dom</code> 和更新的信息，在适当的时候可以在内存中中断 <code>reconcile</code> 的过程，这种数据结构就是 <code>Fiber。</code></p><h2 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h2><p>​ <code>Scheduler</code> 独立于 <code>react</code> 本身，相当于一个单独的 <code>package</code>，<code>Scheduler</code> 的意义在于，当 <code>cup</code> 的计算量很大时，我们根据设备的 <code>fps</code> 算出一帧的时间，在这个时间内执行 <code>cup</code> 的操作，当任务执行的时间快超过一帧的时间时，会暂停任务的执行，让浏览器有时间进行重排和重绘。在适当的时候继续任务。</p><p>​ 在 js 中我们知道 <code>generator</code> 也可以暂停和继续任务，但是我们还需要用优先级来排列任务，这个是 <code>generator</code> 无法完成的。在 <code>Scheduler</code> 中使用 <code>MessageChannel</code> 实现了时间切片，然后用小顶堆排列任务优先级的高低，达到了异步可中断的更新。</p><p>​ <code>Scheduler</code> 可以用过期时间来代表优先级的高低。</p><p>​ 优先级越高，过期时间越短，离当前时间越近，也就是说过一会就要执行它了。</p><p>​ 优先级越低，过期时间越长，离当前时间越长，也就是过很久了才能轮到它执行。</p><h2 id="lane"><a href="#lane" class="headerlink" title="lane"></a>lane</h2><p>​ <code>Lane</code> 用二进制位表示任务的优先级，方便优先级的计算，不同优先级占用不同位置的‘赛道’，而且存在批的概念，优先级越低，‘赛道’越多。高优先级打断低优先级，新建的任务需要赋予什么优先级等问题都是 <code>Lane</code> 所要解决的问题。</p><h2 id="batchedUpdates"><a href="#batchedUpdates" class="headerlink" title="batchedUpdates"></a>batchedUpdates</h2><p>简单来说，在一个上下文中同时触发多次更新，这些更新会合并成一次更新，例如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">onClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.setState(&#123; <span class="attr">count</span>: <span class="built_in">this</span>.state.count + <span class="number">1</span> &#125;);</span><br><span class="line">  <span class="built_in">this</span>.setState(&#123; <span class="attr">count</span>: <span class="built_in">this</span>.state.count + <span class="number">1</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 在之前的 <code>react</code> 版本中如果脱离当前的上下文就不会被合并，例如把多次更新放在 <code>setTimeout</code> 中，原因是处于同一个 <code>context</code> 的多次 <code>setState</code> 的 <code>executionContext</code> 都会包含 <code>BatchedContext</code>，包含 <code>BatchedContext</code> 的 <code>setState</code> 会合并，当 <code>executionContext</code> 等于 <code>NoContext</code>，就会同步执行 <code>SyncCallbackQueue</code> 中的任务，所以 <code>setTimeout</code> 中的多次 <code>setState</code> 不会合并，而且会同步执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">onClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123; <span class="attr">count</span>: <span class="built_in">this</span>.state.count + <span class="number">1</span> &#125;);</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123; <span class="attr">count</span>: <span class="built_in">this</span>.state.count + <span class="number">1</span> &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">unbatchedUpdates</span>&lt;<span class="title">A</span>, <span class="title">R</span>&gt;(<span class="params">fn: (a: A) =&gt; R, a: A</span>): <span class="title">R</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> prevExecutionContext = executionContext;</span><br><span class="line">  executionContext |= BatchedContext; <span class="comment">//包含BatchedContext</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fn(a);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    executionContext = prevExecutionContext;</span><br><span class="line">    <span class="keyword">if</span> (executionContext === NoContext) &#123;</span><br><span class="line">      resetRenderTimer();</span><br><span class="line">      <span class="comment">//executionContext为NoContext就同步执行SyncCallbackQueue中的任务</span></span><br><span class="line">      flushSyncCallbackQueue();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 在 <code>Concurrent mode</code> 下，上面的例子也会合并为一次更新，根本原因在如下一段简化的源码，如果多次 <code>setState</code>，会比较这几次 <code>setState</code> 回调的优先级，如果优先级一致，则先 <code>return</code> 掉，不会进行后面的 <code>render</code> 阶段</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ensureRootIsScheduled</span>(<span class="params">root: FiberRoot, currentTime: number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> existingCallbackNode = root.callbackNode; <span class="comment">//之前已经调用过的setState的回调</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">if</span> (existingCallbackNode !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> existingCallbackPriority = root.callbackPriority;</span><br><span class="line">    <span class="comment">//新的setState的回调和之前setState的回调优先级相等 则进入batchedUpdate的逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (existingCallbackPriority === newCallbackPriority) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cancelCallback(existingCallbackNode);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//调度render阶段的起点</span></span><br><span class="line">  newCallbackNode = scheduleCallback(</span><br><span class="line">    schedulerPriorityLevel,</span><br><span class="line">    performConcurrentWorkOnRoot.bind(<span class="literal">null</span>, root)</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那为什么在 <code>Concurrent mode</code> 下，在 <code>setTimeout</code> 回调多次 <code>setState</code> 优先级一致呢，因为在获取 <code>Lane</code> 的函数 <code>requestUpdateLane</code>，只有第一次 <code>setState</code> 满足 <code>currentEventWipLanes === NoLanes</code>，所以他们的 <code>currentEventWipLanes</code> 参数相同，而在 <code>findUpdateLane</code> 中 <code>schedulerLanePriority</code> 参数也相同（调度的优先级相同），所以返回的 <code>lane</code> 相同。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">requestUpdateLane</span>(<span class="params">fiber: Fiber</span>): <span class="title">Lane</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">if</span> (currentEventWipLanes === NoLanes) &#123;</span><br><span class="line">    <span class="comment">//第一次setState满足currentEventWipLanes === NoLanes</span></span><br><span class="line">    currentEventWipLanes = workInProgressRootIncludedLanes;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">//在setTimeout中schedulerLanePriority, currentEventWipLanes都相同，所以返回的lane也相同</span></span><br><span class="line">  lane = findUpdateLane(schedulerLanePriority, currentEventWipLanes);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> lane;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Suspense"><a href="#Suspense" class="headerlink" title="Suspense"></a>Suspense</h2><p>​ <code>Suspense</code> 可以在请求数据的时候显示 <code>pending</code> 状态，请求成功后展示数据，原因是因为 <code>Suspense</code> 中组件的优先级很低，而离屏的 <code>fallback</code> 组件优先级高，当 <code>Suspense</code> 中组件 <code>resolve</code> 之后就会重新调度一次 <code>render</code> 阶段，此过程发生在 <code>updateSuspenseComponent</code> 函数中，具体可以看调试 <code>suspense</code> 的视频</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;concurrent-mode&quot;&gt;&lt;a href=&quot;#concurrent-mode&quot; class=&quot;headerlink&quot; title=&quot;concurrent mode&quot;&gt;&lt;/a&gt;concurrent mode&lt;/h1&gt;&lt;p&gt;​ react17 开始支持&lt;cod</summary>
      
    
    
    
    <category term="react 源码" scheme="https://hqwuzhaoyi.github.io/categories/react-%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="react" scheme="https://hqwuzhaoyi.github.io/tags/react/"/>
    
    <category term="源码" scheme="https://hqwuzhaoyi.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>react 源码-scheduler &amp; lane</title>
    <link href="https://hqwuzhaoyi.github.io/2021/05/24/react%20%E6%BA%90%E7%A0%81/9.scheduler%20&amp;%20lane/"/>
    <id>https://hqwuzhaoyi.github.io/2021/05/24/react%20%E6%BA%90%E7%A0%81/9.scheduler%20&amp;%20lane/</id>
    <published>2021-05-24T00:00:00.000Z</published>
    <updated>2022-08-29T03:13:16.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h1><p><code>Scheduler</code>主要的功能是时间切片和调度优先级</p><h2 id="时间切片"><a href="#时间切片" class="headerlink" title="时间切片"></a>时间切片</h2><p>在浏览器的一帧中 js 的执行时间如下</p><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hexo/20210524230225.png" alt="一帧中js的执行时间"></p><p>​ <code>requestIdleCallback</code>是在浏览器重绘重排之后，如果还有空闲就可以执行的时机，所以为了不影响重绘重排，可以在浏览器在<code>requestIdleCallback</code>中执行耗性能的计算，但是由于<code>requestIdleCallback</code>存在兼容和触发时机不稳定的问题，<code>scheduler</code>中采用<code>MessageChannel</code>来实现<code>requestIdleCallback</code>，当前环境不支持<code>MessageChannel</code>就采用<code>setTimeout</code>。</p><p>在之前的介绍中我们知道在<code>performUnitOfWork</code>之后会执行<code>render</code>阶段和<code>commit</code>阶段，如果在浏览器的一帧中，cpu 的计算还没完成，就会让出 js 执行权给浏览器，这个判断在<code>workLoopConcurrent</code>函数中，<code>shouldYield</code>就是用来判断剩余的时间有没有用尽。在源码中每个时间片时<code>5ms</code>，这个值会根据设备的<code>fps</code>调整。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoopConcurrent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (workInProgress !== <span class="literal">null</span> &amp;&amp; !shouldYield()) &#123;</span><br><span class="line">    performUnitOfWork(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">forceFrameRate</span>(<span class="params">fps</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//计算时间片</span></span><br><span class="line">  <span class="keyword">if</span> (fps &lt; <span class="number">0</span> || fps &gt; <span class="number">125</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>[<span class="string">&quot;error&quot;</span>](</span><br><span class="line">      <span class="string">&quot;forceFrameRate takes a positive int between 0 and 125, &quot;</span> +</span><br><span class="line">        <span class="string">&quot;forcing frame rates higher than 125 fps is not supported&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (fps &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    yieldInterval = <span class="built_in">Math</span>.floor(<span class="number">1000</span> / fps);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    yieldInterval = <span class="number">5</span>; <span class="comment">//时间片默认5ms</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="任务的暂停"><a href="#任务的暂停" class="headerlink" title="任务的暂停"></a>任务的暂停</h2><p>在<code>shouldYield</code>函数中有一段，所以可以知道，如果当前时间大于<code>任务开始的时间 + yieldInterval</code>，就打断了任务的进行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//deadline = currentTime + yieldInterval，deadline是在performWorkUntilDeadline函数中计算出来的</span></span><br><span class="line"><span class="keyword">if</span> (currentTime &gt;= deadline) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调度优先级"><a href="#调度优先级" class="headerlink" title="调度优先级"></a>调度优先级</h2><p>​ 在 Scheduler 中有两个函数可以创建具有优先级的任务</p><h3 id="runWithPriority"><a href="#runWithPriority" class="headerlink" title="runWithPriority"></a>runWithPriority</h3><p>以一个优先级执行 callback，如果是同步的任务，优先级就是 ImmediateSchedulerPriority</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unstable_runWithPriority</span>(<span class="params">priorityLevel, eventHandler</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (</span><br><span class="line">    priorityLevel <span class="comment">//5种优先级</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">case</span> ImmediatePriority:</span><br><span class="line">    <span class="keyword">case</span> UserBlockingPriority:</span><br><span class="line">    <span class="keyword">case</span> NormalPriority:</span><br><span class="line">    <span class="keyword">case</span> LowPriority:</span><br><span class="line">    <span class="keyword">case</span> IdlePriority:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      priorityLevel = NormalPriority;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> previousPriorityLevel = currentPriorityLevel; <span class="comment">//保存当前的优先级</span></span><br><span class="line">  currentPriorityLevel = priorityLevel; <span class="comment">//priorityLevel赋值给currentPriorityLevel</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> eventHandler(); <span class="comment">//回调函数</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    currentPriorityLevel = previousPriorityLevel; <span class="comment">//还原之前的优先级</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="scheduleCallback"><a href="#scheduleCallback" class="headerlink" title="scheduleCallback"></a>scheduleCallback</h3><p>以一个优先级注册 callback，在适当的时机执行，因为涉及过期时间的计算，所以 scheduleCallback 比 runWithPriority 的粒度更细。</p><ul><li><p>在 scheduleCallback 中优先级意味着过期时间，优先级越高 priorityLevel 就越小，过期时间离当前时间就越近，var expirationTime = startTime + timeout;例如 IMMEDIATE_PRIORITY_TIMEOUT=-1，那 var expirationTime = startTime + (-1);就小于当前时间了，所以要立即执行。</p></li><li><p>scheduleCallback 调度的过程用到了小顶堆，所以我们可以在 O(1)的复杂度找到优先级最高的 task，不了解可以查阅资料，在源码中小顶堆存放着任务，每次 peek 都能取到离过期时间最近的 task。</p></li><li><p>scheduleCallback 中，未过期任务 task 存放在 timerQueue 中，过期任务存放在 taskQueue 中。</p><p>新建 newTask 任务之后，判断 newTask 是否过期，没过期就加入 timerQueue 中，如果此时 taskQueue 中还没有过期任务，timerQueue 中离过期时间最近的 task 正好是 newTask，则设置个定时器，到了过期时间就加入 taskQueue 中。</p><p>​ 当 timerQueue 中有任务，就取出最早过期的任务执行。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unstable_scheduleCallback</span>(<span class="params">priorityLevel, callback, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> currentTime = getCurrentTime();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> startTime;<span class="comment">//开始时间</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> options === <span class="string">&#x27;object&#x27;</span> &amp;&amp; options !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> delay = options.delay;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> delay === <span class="string">&#x27;number&#x27;</span> &amp;&amp; delay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      startTime = currentTime + delay;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      startTime = currentTime;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    startTime = currentTime;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> timeout;</span><br><span class="line">  <span class="keyword">switch</span> (priorityLevel) &#123;</span><br><span class="line">    <span class="keyword">case</span> ImmediatePriority:<span class="comment">//优先级越高timeout越小</span></span><br><span class="line">      timeout = IMMEDIATE_PRIORITY_TIMEOUT;<span class="comment">//-1</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> UserBlockingPriority:</span><br><span class="line">      timeout = USER_BLOCKING_PRIORITY_TIMEOUT;<span class="comment">//250</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> IdlePriority:</span><br><span class="line">      timeout = IDLE_PRIORITY_TIMEOUT;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LowPriority:</span><br><span class="line">      timeout = LOW_PRIORITY_TIMEOUT;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> NormalPriority:</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      timeout = NORMAL_PRIORITY_TIMEOUT;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> expirationTime = startTime + timeout;<span class="comment">//优先级越高 过期时间越小</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> newTask = &#123;<span class="comment">//新建task</span></span><br><span class="line">    id: taskIdCounter++,</span><br><span class="line">    callback<span class="comment">//回调函数</span></span><br><span class="line">    priorityLevel,</span><br><span class="line">    startTime,<span class="comment">//开始时间</span></span><br><span class="line">    expirationTime,<span class="comment">//过期时间</span></span><br><span class="line">    sortIndex: -<span class="number">1</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">if</span> (enableProfiling) &#123;</span><br><span class="line">    newTask.isQueued = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (startTime &gt; currentTime) &#123;<span class="comment">//没有过期</span></span><br><span class="line">    newTask.sortIndex = startTime;</span><br><span class="line">    push(timerQueue, newTask);<span class="comment">//加入timerQueue</span></span><br><span class="line">    <span class="comment">//taskQueue中还没有过期任务，timerQueue中离过期时间最近的task正好是newTask</span></span><br><span class="line">    <span class="keyword">if</span> (peek(taskQueue) === <span class="literal">null</span> &amp;&amp; newTask === peek(timerQueue)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isHostTimeoutScheduled) &#123;</span><br><span class="line">        cancelHostTimeout();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        isHostTimeoutScheduled = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//定时器，到了过期时间就加入taskQueue中</span></span><br><span class="line">      requestHostTimeout(handleTimeout, startTime - currentTime);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    newTask.sortIndex = expirationTime;</span><br><span class="line">    push(taskQueue, newTask);<span class="comment">//加入taskQueue</span></span><br><span class="line">    <span class="keyword">if</span> (enableProfiling) &#123;</span><br><span class="line">      markTaskStart(newTask, currentTime);</span><br><span class="line">      newTask.isQueued = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isHostCallbackScheduled &amp;&amp; !isPerformingWork) &#123;</span><br><span class="line">      isHostCallbackScheduled = <span class="literal">true</span>;</span><br><span class="line">      requestHostCallback(flushWork);<span class="comment">//执行过期的任务</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hexo/20210524230926.png" alt="var expirationTime = startTime + timeout"></p><h2 id="任务暂停之后怎么继续"><a href="#任务暂停之后怎么继续" class="headerlink" title="任务暂停之后怎么继续"></a>任务暂停之后怎么继续</h2><p>​ 在<code>workLoop</code>函数中有这样一段</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> continuationCallback = callback(didUserCallbackTimeout); <span class="comment">//callback就是调度的callback</span></span><br><span class="line">currentTime = getCurrentTime();</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> continuationCallback === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">  <span class="comment">//判断callback执行之后的返回值类型</span></span><br><span class="line">  currentTask.callback = continuationCallback; <span class="comment">//如果是function类型就把又赋值给currentTask.callback</span></span><br><span class="line">  markTaskYield(currentTask, currentTime);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (enableProfiling) &#123;</span><br><span class="line">    markTaskCompleted(currentTask, currentTime);</span><br><span class="line">    currentTask.isQueued = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (currentTask === peek(taskQueue)) &#123;</span><br><span class="line">    pop(taskQueue); <span class="comment">//如果是function类型就从taskQueue中删除</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">advanceTimers(currentTime);</span><br></pre></td></tr></table></figure><p>​ 在<code>performConcurrentWorkOnRoot</code>函数的结尾有这样一个判断，如果<code>callbackNode</code>等于<code>originalCallbackNode</code>那就恢复任务的执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root.callbackNode === originalCallbackNode) &#123;</span><br><span class="line">  <span class="comment">// The task node scheduled for this root is the same one that&#x27;s</span></span><br><span class="line">  <span class="comment">// currently executed. Need to return a continuation.</span></span><br><span class="line">  <span class="keyword">return</span> performConcurrentWorkOnRoot.bind(<span class="literal">null</span>, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Lane"><a href="#Lane" class="headerlink" title="Lane"></a>Lane</h1><p>​ <code>Lane</code>的和<code>Scheduler</code>是两套优先级机制，相比来说<code>Lane</code>的优先级粒度更细，<code>Lane</code>的意思是车道，类似赛车一样，在<code>task</code>获取优先级时，总是会优先抢内圈的赛道，<code>Lane</code>表示的优先级有一下几个特点。</p><ul><li><p>可以表示不同批次的优先级</p><p>从代码中中可以看到，每个优先级都是个<strong>31</strong>位二进制数字，<strong>1</strong>表示该位置可以用，<strong>0</strong>代表这个位置不能用，从第一个优先级<code>NoLanes</code>到<code>OffscreenLane</code>优先级是降低的，优先级越低<strong>1</strong>的个数也就越多（赛车比赛外圈的车越多），也就是说含多个<strong>1</strong>的优先级就是同一个批次。</p><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> NoLanes: Lanes = <span class="comment">/*                        */</span> <span class="number">0b0000000000000000000000000000000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> NoLane: Lane = <span class="comment">/*                          */</span> <span class="number">0b0000000000000000000000000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SyncLane: Lane = <span class="comment">/*                        */</span> <span class="number">0b0000000000000000000000000000001</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SyncBatchedLane: Lane = <span class="comment">/*                 */</span> <span class="number">0b0000000000000000000000000000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> InputDiscreteHydrationLane: Lane = <span class="comment">/*      */</span> <span class="number">0b0000000000000000000000000000100</span>;</span><br><span class="line"><span class="keyword">const</span> InputDiscreteLanes: Lanes = <span class="comment">/*                    */</span> <span class="number">0b0000000000000000000000000011000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> InputContinuousHydrationLane: Lane = <span class="comment">/*           */</span> <span class="number">0b0000000000000000000000000100000</span>;</span><br><span class="line"><span class="keyword">const</span> InputContinuousLanes: Lanes = <span class="comment">/*                  */</span> <span class="number">0b0000000000000000000000011000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DefaultHydrationLane: Lane = <span class="comment">/*            */</span> <span class="number">0b0000000000000000000000100000000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DefaultLanes: Lanes = <span class="comment">/*                   */</span> <span class="number">0b0000000000000000000111000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TransitionHydrationLane: Lane = <span class="comment">/*                */</span> <span class="number">0b0000000000000000001000000000000</span>;</span><br><span class="line"><span class="keyword">const</span> TransitionLanes: Lanes = <span class="comment">/*                       */</span> <span class="number">0b0000000001111111110000000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> RetryLanes: Lanes = <span class="comment">/*                            */</span> <span class="number">0b0000011110000000000000000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SomeRetryLane: Lanes = <span class="comment">/*                  */</span> <span class="number">0b0000010000000000000000000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SelectiveHydrationLane: Lane = <span class="comment">/*          */</span> <span class="number">0b0000100000000000000000000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> NonIdleLanes = <span class="comment">/*                                 */</span> <span class="number">0b0000111111111111111111111111111</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> IdleHydrationLane: Lane = <span class="comment">/*               */</span> <span class="number">0b0001000000000000000000000000000</span>;</span><br><span class="line"><span class="keyword">const</span> IdleLanes: Lanes = <span class="comment">/*                             */</span> <span class="number">0b0110000000000000000000000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> OffscreenLane: Lane = <span class="comment">/*                   */</span> <span class="number">0b1000000000000000000000000000000</span>;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>优先级的计算的性能高</p><p>​ 例如，可以通过二进制按位与来判断 <code>a</code> 和 <code>b</code> 代表的 <code>lane</code> 是否存在交集</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">includesSomeLane</span>(<span class="params">a: Lanes | Lane, b: Lanes | Lane</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (a &amp; b) !== NoLanes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Lane-模型中-task-时怎么获取优先级的（赛车的初始赛道）"><a href="#Lane-模型中-task-时怎么获取优先级的（赛车的初始赛道）" class="headerlink" title="Lane 模型中 task 时怎么获取优先级的（赛车的初始赛道）"></a>Lane 模型中 task 时怎么获取优先级的（赛车的初始赛道）</h2><p>​ 任务获取赛道的方式是从高优先级的<code>lanes</code>开始的，这个过程发生在 <code>findUpdateLane</code> 函数中，如果高优先级没有可用的 <code>lane</code> 了就下降到优先级低的<code>lanes</code>中寻找，其中 <code>pickArbitraryLane</code> 会调用 <code>getHighestPriorityLane</code> 获取一批<code>lanes</code>中优先级最高的那一位，也就是通过<code>lanes &amp; -lanes</code>获取最右边的一位</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">findUpdateLane</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  lanePriority: LanePriority,</span></span></span><br><span class="line"><span class="function"><span class="params">  wipLanes: Lanes</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Lane</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (lanePriority) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">case</span> DefaultLanePriority: &#123;</span><br><span class="line">      <span class="keyword">let</span> lane = pickArbitraryLane(DefaultLanes &amp; ~wipLanes); <span class="comment">//找到下一个优先级最高的lane</span></span><br><span class="line">      <span class="keyword">if</span> (lane === NoLane) &#123;</span><br><span class="line">        <span class="comment">//上一个level的lane都占满了下降到TransitionLanes继续寻找可用的赛道</span></span><br><span class="line">        lane = pickArbitraryLane(TransitionLanes &amp; ~wipLanes);</span><br><span class="line">        <span class="keyword">if</span> (lane === NoLane) &#123;</span><br><span class="line">          <span class="comment">//TransitionLanes也满了</span></span><br><span class="line">          lane = pickArbitraryLane(DefaultLanes); <span class="comment">//从DefaultLanes开始找</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> lane;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Lane-模型中高优先级时怎么插队的（赛车抢赛道）"><a href="#Lane-模型中高优先级时怎么插队的（赛车抢赛道）" class="headerlink" title="Lane 模型中高优先级时怎么插队的（赛车抢赛道）"></a>Lane 模型中高优先级时怎么插队的（赛车抢赛道）</h2><p>​ 在<code>Lane</code>模型中如果一个低优先级的任务执行，并且还在调度的时候触发了一个高优先级的任务，则高优先级的任务打断低优先级任务，此时应该先取消低优先级的任务，因为此时低优先级的任务可能已经进行了一段时间，<code>Fiber</code>树已经构建了一部分，所以需要将<code>Fiber</code>树还原，这个过程发生在函数<code>prepareFreshStack</code>中，在这个函数中会初始化已经构建的<code>Fiber</code>树</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ensureRootIsScheduled</span>(<span class="params">root: FiberRoot, currentTime: number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> existingCallbackNode = root.callbackNode; <span class="comment">//之前已经调用过的setState的回调</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">if</span> (existingCallbackNode !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> existingCallbackPriority = root.callbackPriority;</span><br><span class="line">    <span class="comment">//新的setState的回调和之前setState的回调优先级相等 则进入batchedUpdate的逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (existingCallbackPriority === newCallbackPriority) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//两个回调优先级不一致，则被高优先级任务打断，先取消当前低优先级的任务</span></span><br><span class="line">    cancelCallback(existingCallbackNode);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//调度render阶段的起点</span></span><br><span class="line">  newCallbackNode = scheduleCallback(</span><br><span class="line">    schedulerPriorityLevel,</span><br><span class="line">    performConcurrentWorkOnRoot.bind(<span class="literal">null</span>, root)</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prepareFreshStack</span>(<span class="params">root: FiberRoot, lanes: Lanes</span>) </span>&#123;</span><br><span class="line">  root.finishedWork = <span class="literal">null</span>;</span><br><span class="line">  root.finishedLanes = NoLanes;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">//workInProgressRoot等变量重新赋值和初始化</span></span><br><span class="line">  workInProgressRoot = root;</span><br><span class="line">  workInProgress = createWorkInProgress(root.current, <span class="literal">null</span>);</span><br><span class="line">  workInProgressRootRenderLanes =</span><br><span class="line">    subtreeRenderLanes =</span><br><span class="line">    workInProgressRootIncludedLanes =</span><br><span class="line">      lanes;</span><br><span class="line">  workInProgressRootExitStatus = RootIncomplete;</span><br><span class="line">  workInProgressRootFatalError = <span class="literal">null</span>;</span><br><span class="line">  workInProgressRootSkippedLanes = NoLanes;</span><br><span class="line">  workInProgressRootUpdatedLanes = NoLanes;</span><br><span class="line">  workInProgressRootPingedLanes = NoLanes;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Lane-模型中怎么解决饥饿问题（最后一名赛车最后也要到达终点啊）"><a href="#Lane-模型中怎么解决饥饿问题（最后一名赛车最后也要到达终点啊）" class="headerlink" title="Lane 模型中怎么解决饥饿问题（最后一名赛车最后也要到达终点啊）"></a>Lane 模型中怎么解决饥饿问题（最后一名赛车最后也要到达终点啊）</h2><p>在调度优先级的过程中，会调用 <code>markStarvedLanesAsExpired</code> 遍历 <code>pendingLanes</code>（未执行的任务包含的 <code>lane</code>），如果没过期时间就计算一个过期时间，如果过期了就加入 <code>root.expiredLanes</code> 中，然后在下次调用 <code>getNextLane</code> 函数的时候会优先返回 <code>expiredLanes</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">markStarvedLanesAsExpired</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  currentTime: number</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> pendingLanes = root.pendingLanes;</span><br><span class="line">  <span class="keyword">const</span> suspendedLanes = root.suspendedLanes;</span><br><span class="line">  <span class="keyword">const</span> pingedLanes = root.pingedLanes;</span><br><span class="line">  <span class="keyword">const</span> expirationTimes = root.expirationTimes;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> lanes = pendingLanes;</span><br><span class="line">  <span class="keyword">while</span> (lanes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//遍历lanes</span></span><br><span class="line">    <span class="keyword">const</span> index = pickArbitraryLaneIndex(lanes);</span><br><span class="line">    <span class="keyword">const</span> lane = <span class="number">1</span> &lt;&lt; index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> expirationTime = expirationTimes[index];</span><br><span class="line">    <span class="keyword">if</span> (expirationTime === NoTimestamp) &#123;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        (lane &amp; suspendedLanes) === NoLanes ||</span><br><span class="line">        (lane &amp; pingedLanes) !== NoLanes</span><br><span class="line">      ) &#123;</span><br><span class="line">        expirationTimes[index] = computeExpirationTime(lane, currentTime); <span class="comment">//计算过期时间</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (expirationTime &lt;= currentTime) &#123;</span><br><span class="line">      <span class="comment">//过期了</span></span><br><span class="line">      root.expiredLanes |= lane; <span class="comment">//在expiredLanes加入当前遍历到的lane</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lanes &amp;= ~lane;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getNextLanes</span>(<span class="params">root: FiberRoot, wipLanes: Lanes</span>): <span class="title">Lanes</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">if</span> (expiredLanes !== NoLanes) &#123;</span><br><span class="line">    nextLanes = expiredLanes;</span><br><span class="line">    nextLanePriority = return_highestLanePriority = SyncLanePriority; <span class="comment">//优先返回过期的lane</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nextLanes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 下图更直观，随之时间的推移，低优先级的任务被插队，最后也会变成高优先级的任务</p><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210531102258.png" alt="Lane 饥饿问题"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Scheduler&quot;&gt;&lt;a href=&quot;#Scheduler&quot; class=&quot;headerlink&quot; title=&quot;Scheduler&quot;&gt;&lt;/a&gt;Scheduler&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Scheduler&lt;/code&gt;主要的功能是时间切片和调度优先级&lt;/p&gt;</summary>
      
    
    
    
    <category term="react 源码" scheme="https://hqwuzhaoyi.github.io/categories/react-%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="react" scheme="https://hqwuzhaoyi.github.io/tags/react/"/>
    
    <category term="源码" scheme="https://hqwuzhaoyi.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>react源码-hook</title>
    <link href="https://hqwuzhaoyi.github.io/2021/05/19/react%20%E6%BA%90%E7%A0%81/8.hook/"/>
    <id>https://hqwuzhaoyi.github.io/2021/05/19/react%20%E6%BA%90%E7%A0%81/8.hook/</id>
    <published>2021-05-19T00:00:00.000Z</published>
    <updated>2022-08-29T03:13:16.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hook"><a href="#hook" class="headerlink" title="hook"></a>hook</h1><h2 id="hook调用入口"><a href="#hook调用入口" class="headerlink" title="hook调用入口"></a>hook调用入口</h2><p>在<code>hook</code>源码中<code>hook</code>存在于<code>Dispatcher</code>中，<code>Dispatcher</code>就是一个对象，不同<code>hook</code> 调用的函数不一样，全局变量<code>ReactCurrentDispatcher.current</code>会根据是<code>mount</code>还是<code>update</code>赋值为<code>HooksDispatcherOnMount</code>或<code>HooksDispatcherOnUpdate</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ReactCurrentDispatcher.current =</span><br><span class="line">  current === <span class="literal">null</span> || current.memoizedState === <span class="literal">null</span><span class="comment">//mount or update</span></span><br><span class="line">  ? HooksDispatcherOnMount</span><br><span class="line"> : HooksDispatcherOnUpdate;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HooksDispatcherOnMount: Dispatcher = &#123;<span class="comment">//mount时</span></span><br><span class="line">  useCallback: mountCallback,</span><br><span class="line">  useContext: readContext,</span><br><span class="line">  useEffect: mountEffect,</span><br><span class="line">  useImperativeHandle: mountImperativeHandle,</span><br><span class="line">  useLayoutEffect: mountLayoutEffect,</span><br><span class="line">  useMemo: mountMemo,</span><br><span class="line">  useReducer: mountReducer,</span><br><span class="line">  useRef: mountRef,</span><br><span class="line">  useState: mountState,</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> HooksDispatcherOnUpdate: Dispatcher = &#123;<span class="comment">//update时</span></span><br><span class="line">  useCallback: updateCallback,</span><br><span class="line">  useContext: readContext,</span><br><span class="line">  useEffect: updateEffect,</span><br><span class="line">  useImperativeHandle: updateImperativeHandle,</span><br><span class="line">  useLayoutEffect: updateLayoutEffect,</span><br><span class="line">  useMemo: updateMemo,</span><br><span class="line">  useReducer: updateReducer,</span><br><span class="line">  useRef: updateRef,</span><br><span class="line">  useState: updateState,</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="hook数据结构"><a href="#hook数据结构" class="headerlink" title="hook数据结构"></a>hook数据结构</h2><p>在<code>FunctionComponent</code>中，多个<code>hook</code>会形成<code>hook</code>链表，保存在<code>Fiber</code>的<code>memoizedState</code>的上，而需要更新的<code>Update</code>保存在<code>hook.queue.pending</code>中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hook: Hook = &#123;</span><br><span class="line">  memoizedState: <span class="literal">null</span>,<span class="comment">//对于不同hook，有不同的值</span></span><br><span class="line">  baseState: <span class="literal">null</span>,<span class="comment">//初始state</span></span><br><span class="line">  baseQueue: <span class="literal">null</span>,<span class="comment">//初始queue队列</span></span><br><span class="line">  queue: <span class="literal">null</span>,<span class="comment">//需要更新的update</span></span><br><span class="line">  next: <span class="literal">null</span>,<span class="comment">//下一个hook</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面来看下<code>memoizedState</code>对应的值</p><ul><li><code>useState</code>：例如<code>const [state, updateState] = useState(initialState)</code>，<code>memoizedState</code>等于<code>state</code>的值</li><li><code>useReducer</code>：例如<code>const [state, dispatch] = useReducer(reducer, &#123;&#125;)</code>，``memoizedState<code>等于</code>state`的值</li><li><code>useEffect</code>：在<code>mountEffect</code>时会调用<code>pushEffect</code>创建<code>effect</code>链表，<code>memoizedState</code>就等于<code>effect</code>链表，<code>effect</code>链表也会挂载到<code>fiber.updateQueue</code>上，每个<code>effect</code>上存在<code>useEffect</code>的第一个参数回调和第二个参数依赖数组，例如，<code>useEffect(callback, [dep])</code>，<code>effect</code>就是<code>&#123;create:callback, dep:dep,...&#125;</code></li><li><code>useRef</code>：例如<code>useRef(0)</code>，<code>memoizedState</code>就等于<code>&#123;current: 0&#125;</code></li><li><code>useMemo</code>: 例如<code>useMemo(callback, [dep])</code>，<code>memoizedState</code>等于<code>[callback(), dep]</code></li><li><code>useCallback</code>: 例如<code>useCallback(callback, [dep])</code>，<code>memoizedState</code>等于<code>[callback, dep]</code>。<code>useCallback</code>保存<code>callback</code>函数，<code>useMemo</code>保存<code>callback</code>的执行结果</li></ul><h2 id="useState-amp-useReducer"><a href="#useState-amp-useReducer" class="headerlink" title="useState&amp;useReducer"></a>useState&amp;useReducer</h2><p>之所以把<code>useState</code>和<code>useReducer</code>放在一起，是因为在源码中<code>useState</code>就是有默认<code>reducer</code>参数的<code>useReducer</code>。</p><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><pre><code>`​resolveDispatcher`函数会获取当前的`Dispatcher`</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useState</span>(<span class="params">initialState</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> dispatcher = resolveDispatcher();</span><br><span class="line">  <span class="keyword">return</span> dispatcher.useState(initialState);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useReducer</span>(<span class="params">reducer, initialArg, init</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> dispatcher = resolveDispatcher();</span><br><span class="line">  <span class="keyword">return</span> dispatcher.useReducer(reducer, initialArg, init);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mount阶段"><a href="#mount阶段" class="headerlink" title="mount阶段"></a>mount阶段</h3><p>​mount阶段<code>useState</code>调用<code>mountState</code>，<code>useReducer</code>调用<code>mountReducer</code>，唯一区别就是它们创建的<code>queue</code>中<code>lastRenderedReducer</code>不一样，mount有初始值<code>basicStateReducer</code>，所以说<code>useState</code>就是有默认<code>reducer</code>参数的<code>useReducer</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountState</span>&lt;<span class="title">S</span>&gt;(<span class="params"><span class="comment">//</span></span></span></span><br><span class="line"><span class="function"><span class="params">  initialState: (() =&gt; S) | S,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): [<span class="title">S</span>, <span class="title">Dispatch</span>&lt;<span class="title">BasicStateAction</span>&lt;<span class="title">S</span>&gt;&gt;] </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = mountWorkInProgressHook();<span class="comment">//创建当前hook</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> initialState === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    initialState = initialState();</span><br><span class="line">  &#125;</span><br><span class="line">  hook.memoizedState = hook.baseState = initialState;<span class="comment">//hook.memoizedState赋值</span></span><br><span class="line">  <span class="keyword">const</span> queue = (hook.queue = &#123;<span class="comment">//赋值hook.queue</span></span><br><span class="line">    pending: <span class="literal">null</span>,</span><br><span class="line">    dispatch: <span class="literal">null</span>,</span><br><span class="line">    lastRenderedReducer: basicStateReducer,<span class="comment">//和mountReducer的区别</span></span><br><span class="line">    lastRenderedState: (initialState: any),</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">const</span> dispatch: Dispatch&lt;<span class="comment">//创建dispatch函数</span></span><br><span class="line">    BasicStateAction&lt;S&gt;,</span><br><span class="line">  &gt; = (queue.dispatch = (dispatchAction.bind(</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    currentlyRenderingFiber,</span><br><span class="line">    quewque,</span><br><span class="line">  ): any));</span><br><span class="line">  <span class="keyword">return</span> [hook.memoizedState, dispatch];<span class="comment">//返回memoizedState和dispatch</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountReducer</span>&lt;<span class="title">S</span>, <span class="title">I</span>, <span class="title">A</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  reducer: (S, A) =&gt; S,</span></span></span><br><span class="line"><span class="function"><span class="params">  initialArg: I,</span></span></span><br><span class="line"><span class="function"><span class="params">  init?: I =&gt; S,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): [<span class="title">S</span>, <span class="title">Dispatch</span>&lt;<span class="title">A</span>&gt;] </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = mountWorkInProgressHook();<span class="comment">//创建当前hook</span></span><br><span class="line">  <span class="keyword">let</span> initialState;</span><br><span class="line">  <span class="keyword">if</span> (init !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    initialState = init(initialArg);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    initialState = ((initialArg: any): S);</span><br><span class="line">  &#125;</span><br><span class="line">  hook.memoizedState = hook.baseState = initialState;<span class="comment">//hook.memoizedState赋值</span></span><br><span class="line">  <span class="keyword">const</span> queue = (hook.queue = &#123;<span class="comment">//创建queue</span></span><br><span class="line">    pending: <span class="literal">null</span>,</span><br><span class="line">    dispatch: <span class="literal">null</span>,</span><br><span class="line">    lastRenderedReducer: reducer,</span><br><span class="line">    lastRenderedState: (initialState: any),</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">const</span> dispatch: Dispatch&lt;A&gt; = (queue.dispatch = (dispatchAction.bind(<span class="comment">//创建dispatch函数</span></span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    currentlyRenderingFiber,</span><br><span class="line">    queue,</span><br><span class="line">  ): any));</span><br><span class="line">  <span class="keyword">return</span> [hook.memoizedState, dispatch];<span class="comment">//返回memoizedState和dispatch</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">basicStateReducer</span>&lt;<span class="title">S</span>&gt;(<span class="params">state: S, action: BasicStateAction&lt;S&gt;</span>): <span class="title">S</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> action === <span class="string">&#x27;function&#x27;</span> ? action(state) : action;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="update阶段"><a href="#update阶段" class="headerlink" title="update阶段"></a>update阶段</h3><p><code>update</code>时会根据<code>hook</code>中的<code>update</code>计算新的<code>state</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateReducer</span>&lt;<span class="title">S</span>, <span class="title">I</span>, <span class="title">A</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  reducer: (S, A) =&gt; S,</span></span></span><br><span class="line"><span class="function"><span class="params">  initialArg: I,</span></span></span><br><span class="line"><span class="function"><span class="params">  init?: I =&gt; S,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): [<span class="title">S</span>, <span class="title">Dispatch</span>&lt;<span class="title">A</span>&gt;] </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = updateWorkInProgressHook();<span class="comment">//获取hook</span></span><br><span class="line">  <span class="keyword">const</span> queue = hook.queue;</span><br><span class="line">  queue.lastRenderedReducer = reducer;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...更新state和第5章的state计算逻辑基本一致</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> dispatch: Dispatch&lt;A&gt; = (queue.dispatch: any);</span><br><span class="line">  <span class="keyword">return</span> [hook.memoizedState, dispatch];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h3><p><code>useState</code>执行<code>setState</code>后会调用<code>dispatchAction</code>，<code>dispatchAction</code>做的事情就是将<code>Update</code>加入<code>queue.pending</code>中，然后开始调度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchAction</span>(<span class="params">fiber, queue, action</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> update = &#123;<span class="comment">//创建update</span></span><br><span class="line">    eventTime: eventTime,</span><br><span class="line">    lane: lane,</span><br><span class="line">    suspenseConfig: suspenseConfig,</span><br><span class="line">    action: action,</span><br><span class="line">    eagerReducer: <span class="literal">null</span>,</span><br><span class="line">    eagerState: <span class="literal">null</span>,</span><br><span class="line">    next: <span class="literal">null</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//queue.pending中加入update</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> alternate = fiber.alternate;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fiber === currentlyRenderingFiber$<span class="number">1</span> || alternate !== <span class="literal">null</span> &amp;&amp; alternate === currentlyRenderingFiber$<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//如果是render阶段执行的更新didScheduleRenderPhaseUpdate=true</span></span><br><span class="line">&#125;</span><br><span class="line">    didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (fiber.lanes === NoLanes &amp;&amp; (alternate === <span class="literal">null</span> || alternate.lanes === NoLanes)) &#123;</span><br><span class="line">      <span class="comment">//如果fiber不存在优先级并且当前alternate不存在或者没有优先级，那就不需要更新了</span></span><br><span class="line">      <span class="comment">//优化的步骤</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    scheduleUpdateOnFiber(fiber, lane, eventTime);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><h3 id="声明-1"><a href="#声明-1" class="headerlink" title="声明"></a>声明</h3><p>获取并返回<code>useEffect</code>函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useEffect</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  create: () =&gt; (() =&gt; <span class="keyword">void</span>) | <span class="keyword">void</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  deps: <span class="built_in">Array</span>&lt;mixed&gt; | <span class="keyword">void</span> | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dispatcher = resolveDispatcher();</span><br><span class="line">  <span class="keyword">return</span> dispatcher.useEffect(create, deps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mount阶段-1"><a href="#mount阶段-1" class="headerlink" title="mount阶段"></a>mount阶段</h3><p>​ 调用<code>mountEffect</code>，<code>mountEffect</code>调用<code>mountEffectImpl</code>，<code>hook.memoizedState</code>赋值为<code>effect</code>链表</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountEffectImpl</span>(<span class="params">fiberFlags, hookFlags, create, deps</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = mountWorkInProgressHook();<span class="comment">//获取hook</span></span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;<span class="comment">//依赖</span></span><br><span class="line">  currentlyRenderingFiber.flags |= fiberFlags;<span class="comment">//增加flag</span></span><br><span class="line">  hook.memoizedState = pushEffect(<span class="comment">//memoizedState=effects环状链表</span></span><br><span class="line">    HookHasEffect | hookFlags,</span><br><span class="line">    create,</span><br><span class="line">    <span class="literal">undefined</span>,</span><br><span class="line">    nextDeps,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="update阶段-1"><a href="#update阶段-1" class="headerlink" title="update阶段"></a>update阶段</h3><p> 浅比较依赖，如果依赖性变了<code>pushEffect</code>第一个参数传<code>HookHasEffect | hookFlags</code>，<code>HookHasEffect</code>表示<code>useEffect</code>依赖项改变了，需要在commit阶段重新执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateEffectImpl</span>(<span class="params">fiberFlags, hookFlags, create, deps</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = updateWorkInProgressHook();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="keyword">let</span> destroy = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (currentHook !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> prevEffect = currentHook.memoizedState;</span><br><span class="line">    destroy = prevEffect.destroy;<span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (nextDeps !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> prevDeps = prevEffect.deps;</span><br><span class="line">      <span class="keyword">if</span> (areHookInputsEqual(nextDeps, prevDeps)) &#123;<span class="comment">//比较deps</span></span><br><span class="line">        <span class="comment">//即使依赖相等也要将effect加入链表，以保证顺序一致</span></span><br><span class="line">        pushEffect(hookFlags, create, destroy, nextDeps);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  currentlyRenderingFiber.flags |= fiberFlags;</span><br><span class="line"></span><br><span class="line">  hook.memoizedState = pushEffect(</span><br><span class="line">    <span class="comment">//参数传HookHasEffect | hookFlags，包含hookFlags的useEffect会在commit阶段执行这个effect</span></span><br><span class="line">    HookHasEffect | hookFlags,</span><br><span class="line">    create,</span><br><span class="line">    destroy,</span><br><span class="line">    nextDeps,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行阶段-1"><a href="#执行阶段-1" class="headerlink" title="执行阶段"></a>执行阶段</h3><p>​ 在commit阶段的<code>commitLayoutEffects</code>函数中会调用<code>schedulePassiveEffects</code>，将<code>useEffect</code>的销毁和回调函数push到<code>pendingPassiveHookEffectsUnmount</code>和<code>pendingPassiveHookEffectsMount</code>中，然后在mutation之后调用<code>flushPassiveEffects</code>依次执行上次render的销毁函数回调和本次render的回调函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unmountEffects = pendingPassiveHookEffectsUnmount;</span><br><span class="line">pendingPassiveHookEffectsUnmount = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; unmountEffects.length; i += <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> effect = ((unmountEffects[i]: any): HookEffect);</span><br><span class="line">  <span class="keyword">const</span> fiber = ((unmountEffects[i + <span class="number">1</span>]: any): Fiber);</span><br><span class="line">  <span class="keyword">const</span> destroy = effect.destroy;</span><br><span class="line">  effect.destroy = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> destroy === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      destroy();<span class="comment">//销毁函数执行</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      captureCommitPhaseError(fiber, error);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mountEffects = pendingPassiveHookEffectsMount;</span><br><span class="line">pendingPassiveHookEffectsMount = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; mountEffects.length; i += <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> effect = ((mountEffects[i]: any): HookEffect);</span><br><span class="line">  <span class="keyword">const</span> fiber = ((mountEffects[i + <span class="number">1</span>]: any): Fiber);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> create = effect.create;<span class="comment">//本次render的创建函数</span></span><br><span class="line">   effect.destroy = create();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    captureCommitPhaseError(fiber, error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h2><p><code>string</code>类型的<code>ref</code>已经不在推荐使用，<code>ForwardRef</code>只是把<code>ref</code>通过传参传下去，<code>createRef</code>也是<code>&#123;current: any&#125;</code>这种结构，所以我们只讨论<code>function</code>或者<code>&#123;current: any&#125;</code>的<code>useRef</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//createRef返回&#123;current: any&#125;</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createRef</span>(<span class="params"></span>): <span class="title">RefObject</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> refObject = &#123;</span><br><span class="line">    current: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> refObject;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ForwardRef第二个参数是ref对象</span></span><br><span class="line"><span class="keyword">let</span> children = Component(props, secondArg);</span><br></pre></td></tr></table></figure><h3 id="声明阶段"><a href="#声明阶段" class="headerlink" title="声明阶段"></a>声明阶段</h3><p>​ 和其他hook一样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useRef</span>&lt;<span class="title">T</span>&gt;(<span class="params">initialValue: T</span>): </span>&#123;|current: T|&#125; &#123;</span><br><span class="line">  <span class="keyword">const</span> dispatcher = resolveDispatcher();</span><br><span class="line">  <span class="keyword">return</span> dispatcher.useRef(initialValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mount阶段-2"><a href="#mount阶段-2" class="headerlink" title="mount阶段"></a>mount阶段</h3><p>​ mount时会调用<code>mountRef</code>，创建hook和ref对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountRef</span>&lt;<span class="title">T</span>&gt;(<span class="params">initialValue: T</span>): </span>&#123;|current: T|&#125; &#123;</span><br><span class="line">  <span class="keyword">const</span> hook = mountWorkInProgressHook();<span class="comment">//获取useRef</span></span><br><span class="line">  <span class="keyword">const</span> ref = &#123;<span class="attr">current</span>: initialValue&#125;;<span class="comment">//ref初始化</span></span><br><span class="line">  hook.memoizedState = ref;</span><br><span class="line">  <span class="keyword">return</span> ref;</span><br></pre></td></tr></table></figure><h3 id="render阶段"><a href="#render阶段" class="headerlink" title="render阶段"></a>render阶段</h3><p>将带有ref属性的<code>Fiber</code>标记上<code>Ref Tag</code>，在一步发生在<code>beginWork</code>和<code>completeWork</code>函数中的<code>markRef</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Ref = <span class="number">0b0000000010000000</span>;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//beginWork中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">markRef</span>(<span class="params">current: Fiber | <span class="literal">null</span>, workInProgress: Fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ref = workInProgress.ref;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    (current === <span class="literal">null</span> &amp;&amp; ref !== <span class="literal">null</span>) ||</span><br><span class="line">    (current !== <span class="literal">null</span> &amp;&amp; current.ref !== ref)</span><br><span class="line">  ) &#123;</span><br><span class="line">    workInProgress.effectTag |= Ref;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//completeWork中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">markRef</span>(<span class="params">workInProgress: Fiber</span>) </span>&#123;</span><br><span class="line">  workInProgress.effectTag |= Ref;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="commit阶段"><a href="#commit阶段" class="headerlink" title="commit阶段"></a>commit阶段</h3><p>会在<code>commitMutationEffects</code>函数中判断<code>ref</code>是否改变，如果改变了会先执行<code>commitDetachRef</code>先删除之前的<code>ref</code>，然后在<code>commitLayoutEffect</code>中会执行<code>commitAttachRef</code>赋值<code>ref</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitMutationEffects</span>(<span class="params">root: FiberRoot, renderPriorityLevel</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> effectTag = nextEffect.effectTag;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (effectTag &amp; Ref) &#123;</span><br><span class="line">      <span class="keyword">const</span> current = nextEffect.alternate;</span><br><span class="line">      <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">        commitDetachRef(current);<span class="comment">//移除ref</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitDetachRef</span>(<span class="params">current: Fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> currentRef = current.ref;</span><br><span class="line">  <span class="keyword">if</span> (currentRef !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> currentRef === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      currentRef(<span class="literal">null</span>);<span class="comment">//类型是function，则调用</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      currentRef.current = <span class="literal">null</span>;<span class="comment">//否则赋值&#123;current: null&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitAttachRef</span>(<span class="params">finishedWork: Fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ref = finishedWork.ref;</span><br><span class="line">  <span class="keyword">if</span> (ref !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> instance = finishedWork.stateNode;<span class="comment">//获取ref的实例</span></span><br><span class="line">    <span class="keyword">let</span> instanceToUse;</span><br><span class="line">    <span class="keyword">switch</span> (finishedWork.tag) &#123;</span><br><span class="line">      <span class="keyword">case</span> HostComponent:</span><br><span class="line">        instanceToUse = getPublicInstance(instance);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        instanceToUse = instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> ref === <span class="string">&#x27;function&#x27;</span>) &#123;<span class="comment">//ref赋值</span></span><br><span class="line">      ref(instanceToUse);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ref.current = instanceToUse;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="update阶段-2"><a href="#update阶段-2" class="headerlink" title="update阶段"></a>update阶段</h3><p>update时调用<code>updateRef</code>获取获取当前<code>useRef</code>，然后返回<code>hook链表</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateRef</span>&lt;<span class="title">T</span>&gt;(<span class="params">initialValue: T</span>): </span>&#123;|current: T|&#125; &#123;</span><br><span class="line">  <span class="keyword">const</span> hook = updateWorkInProgressHook();<span class="comment">//获取当前useRef</span></span><br><span class="line">  <span class="keyword">return</span> hook.memoizedState;<span class="comment">//返回hook链表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="useMemo-amp-useCallback"><a href="#useMemo-amp-useCallback" class="headerlink" title="useMemo&amp;useCallback"></a>useMemo&amp;useCallback</h2><h3 id="声明阶段-1"><a href="#声明阶段-1" class="headerlink" title="声明阶段"></a>声明阶段</h3><p>和其他hook 一样</p><h3 id="mount阶段-3"><a href="#mount阶段-3" class="headerlink" title="mount阶段"></a>mount阶段</h3><p>mount阶段<code>useMemo</code>和<code>useCallback</code>唯一区别是在<code>memoizedState</code>中存贮<code>callback</code>还是<code>callback计算出来的函数</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountMemo</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  nextCreate: () =&gt; T,</span></span></span><br><span class="line"><span class="function"><span class="params">  deps: <span class="built_in">Array</span>&lt;mixed&gt; | <span class="keyword">void</span> | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = mountWorkInProgressHook();<span class="comment">//创建hook</span></span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="keyword">const</span> nextValue = nextCreate();<span class="comment">//计算value</span></span><br><span class="line">  hook.memoizedState = [nextValue, nextDeps];<span class="comment">//把value和依赖保存在memoizedState中</span></span><br><span class="line">  <span class="keyword">return</span> nextValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountCallback</span>&lt;<span class="title">T</span>&gt;(<span class="params">callback: T, deps: <span class="built_in">Array</span>&lt;mixed&gt; | <span class="keyword">void</span> | <span class="literal">null</span></span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = mountWorkInProgressHook();<span class="comment">//创建hook</span></span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  hook.memoizedState = [callback, nextDeps];<span class="comment">//把callback和依赖保存在memoizedState中</span></span><br><span class="line">  <span class="keyword">return</span> callback;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="update阶段-3"><a href="#update阶段-3" class="headerlink" title="update阶段"></a>update阶段</h3><p>update时也一样，唯一区别就是直接用<code>回调函数</code>还是<code>执行回调后返回的value</code>作为<code>[?, nextDeps]</code>赋值给<code>memoizedState</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateMemo</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  nextCreate: () =&gt; T,</span></span></span><br><span class="line"><span class="function"><span class="params">  deps: <span class="built_in">Array</span>&lt;mixed&gt; | <span class="keyword">void</span> | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = updateWorkInProgressHook();<span class="comment">//获取hook</span></span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="keyword">const</span> prevState = hook.memoizedState;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (prevState !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextDeps !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> prevDeps: <span class="built_in">Array</span>&lt;mixed&gt; | <span class="literal">null</span> = prevState[<span class="number">1</span>];</span><br><span class="line">      <span class="keyword">if</span> (areHookInputsEqual(nextDeps, prevDeps)) &#123;<span class="comment">//浅比较依赖</span></span><br><span class="line">        <span class="keyword">return</span> prevState[<span class="number">0</span>];<span class="comment">//没变 返回之前的状态</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> nextValue = nextCreate();<span class="comment">//有变化重新调用callback</span></span><br><span class="line">  hook.memoizedState = [nextValue, nextDeps];</span><br><span class="line">  <span class="keyword">return</span> nextValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateCallback</span>&lt;<span class="title">T</span>&gt;(<span class="params">callback: T, deps: <span class="built_in">Array</span>&lt;mixed&gt; | <span class="keyword">void</span> | <span class="literal">null</span></span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = updateWorkInProgressHook();<span class="comment">//获取hook</span></span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="keyword">const</span> prevState = hook.memoizedState;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (prevState !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextDeps !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> prevDeps: <span class="built_in">Array</span>&lt;mixed&gt; | <span class="literal">null</span> = prevState[<span class="number">1</span>];</span><br><span class="line">      <span class="keyword">if</span> (areHookInputsEqual(nextDeps, prevDeps)) &#123;<span class="comment">//浅比较依赖</span></span><br><span class="line">        <span class="keyword">return</span> prevState[<span class="number">0</span>];<span class="comment">//没变 返回之前的状态</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  hook.memoizedState = [callback, nextDeps];<span class="comment">//变了重新将[callback, nextDeps]赋值给memoizedState</span></span><br><span class="line">  <span class="keyword">return</span> callback;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;hook&quot;&gt;&lt;a href=&quot;#hook&quot; class=&quot;headerlink&quot; title=&quot;hook&quot;&gt;&lt;/a&gt;hook&lt;/h1&gt;&lt;h2 id=&quot;hook调用入口&quot;&gt;&lt;a href=&quot;#hook调用入口&quot; class=&quot;headerlink&quot; title=&quot;h</summary>
      
    
    
    
    <category term="react 源码" scheme="https://hqwuzhaoyi.github.io/categories/react-%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="react" scheme="https://hqwuzhaoyi.github.io/tags/react/"/>
    
    <category term="源码" scheme="https://hqwuzhaoyi.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>react源码-diff</title>
    <link href="https://hqwuzhaoyi.github.io/2021/05/16/react%20%E6%BA%90%E7%A0%81/7.diff/"/>
    <id>https://hqwuzhaoyi.github.io/2021/05/16/react%20%E6%BA%90%E7%A0%81/7.diff/</id>
    <published>2021-05-16T00:00:00.000Z</published>
    <updated>2022-08-29T03:13:16.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h1><p>​ 在<code>render</code>阶段更新<code>Fiber</code>节点时，我们会调用<code>reconcileChildFibers</code>对比<code>current Fiber</code>和<code>jsx</code>对象构建<code>workInProgress Fiber</code>，这里<code>current Fiber</code>是指当前<code>dom</code>对应的<code>fiber</code>树，<code>jsx</code>是<code>class</code>组件<code>render</code>方法或者函数组件的返回值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileChildFibers</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  returnFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  currentFirstChild: Fiber | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  newChild: any,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> isObject = <span class="keyword">typeof</span> newChild === <span class="string">&#x27;object&#x27;</span> &amp;&amp; newChild !== <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isObject) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (newChild.$$typeof) &#123;</span><br><span class="line">      <span class="keyword">case</span> REACT_ELEMENT_TYPE:</span><br><span class="line">    <span class="comment">//单一节点diff</span></span><br><span class="line">        <span class="keyword">return</span> placeSingleChild(</span><br><span class="line">            reconcileSingleElement(</span><br><span class="line">              returnFiber,</span><br><span class="line">              currentFirstChild,</span><br><span class="line">              newChild,</span><br><span class="line">              lanes,</span><br><span class="line">            ),</span><br><span class="line">          );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isArray(newChild)) &#123;</span><br><span class="line">     <span class="comment">//多节点diff</span></span><br><span class="line">    <span class="keyword">return</span> reconcileChildrenArray(</span><br><span class="line">        returnFiber,</span><br><span class="line">        currentFirstChild,</span><br><span class="line">        newChild,</span><br><span class="line">        lanes,</span><br><span class="line">      );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除节点</span></span><br><span class="line">  <span class="keyword">return</span> deleteRemainingChildren(returnFiber, currentFirstChild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hexo/20210515174941.png" alt="diff过程的主要流程如下图"></p><p>我们知道对比两颗树的复杂度本身是<code>O(n3)</code>，对我们的应用来说这个是不能承受的量级，react为了降低复杂度，提出了三个前提：</p><ul><li><p>只对同级比较，跨层级的dom不会进行复用</p></li><li><p>不同类型节点生成的dom树不同，此时会直接销毁老节点及子孙节点，并新建节点</p></li><li><p>可以通过key来对元素diff的过程提供复用的线索，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = (</span><br><span class="line">  &lt;&gt;</span><br><span class="line">    &lt;p key=<span class="string">&quot;0&quot;</span>&gt;<span class="number">0</span>&lt;/p&gt;</span><br><span class="line">    &lt;p key=<span class="string">&quot;1&quot;</span>&gt;<span class="number">1</span>&lt;/p&gt;</span><br><span class="line">   &lt;/&gt;</span><br><span class="line">);</span><br><span class="line"><span class="keyword">const</span> b = (</span><br><span class="line">  &lt;&gt;</span><br><span class="line">    &lt;p key=<span class="string">&quot;1&quot;</span>&gt;<span class="number">1</span>&lt;/p&gt;</span><br><span class="line">    &lt;p key=<span class="string">&quot;0&quot;</span>&gt;<span class="number">0</span>&lt;/p&gt;</span><br><span class="line">  &lt;/&gt;</span><br><span class="line"> );</span><br></pre></td></tr></table></figure></li></ul><p>如果<code>a</code>和<code>b</code>里的元素都没有<code>key</code>，因为节点的更新前后文本节点不同，导致他们都不能复用，所以会销毁之前的节点，并新建节点，但是现在有<code>key</code>了，<code>b</code>中的节点会在老的<code>a</code>中寻找<code>key</code>相同的节点尝试复用，最后发现只是交换位置就可以完成更新，具体对比过程后面会讲到。</p><h2 id="单节点diff"><a href="#单节点diff" class="headerlink" title="单节点diff"></a>单节点diff</h2><p>单点diff有如下几种情况：</p><ul><li>key和type相同表示可以复用节点</li><li>key不同直接标记删除节点，然后新建节点</li><li>key相同type不同，标记删除该节点和兄弟节点，然后新创建节点</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileSingleElement</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  returnFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  currentFirstChild: Fiber | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  element: ReactElement</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> key = element.key;</span><br><span class="line">  <span class="keyword">let</span> child = currentFirstChild;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//child节点不为null执行对比</span></span><br><span class="line">  <span class="keyword">while</span> (child !== <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.比较key</span></span><br><span class="line">    <span class="keyword">if</span> (child.key === key) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 2.比较type</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">switch</span> (child.tag) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line">          <span class="keyword">if</span> (child.elementType === element.type) &#123;</span><br><span class="line">            <span class="comment">// type相同则可以复用 返回复用的节点</span></span><br><span class="line">            <span class="keyword">return</span> existing;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// type不同跳出</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//key相同，type不同则把fiber及和兄弟fiber标记删除</span></span><br><span class="line">      deleteRemainingChildren(returnFiber, child);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//key不同直接标记删除该节点</span></span><br><span class="line">      deleteChild(returnFiber, child);</span><br><span class="line">    &#125;</span><br><span class="line">    child = child.sibling;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//新建新Fiber</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多节点diff"><a href="#多节点diff" class="headerlink" title="多节点diff"></a>多节点diff</h2><p>多节点diff比较复杂，我们分三种情况进行讨论，其中a表示更新前的节点，b表示更新后的节点</p><ul><li><p>属性变化</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = (</span><br><span class="line">  &lt;&gt;</span><br><span class="line">    &lt;p key=<span class="string">&quot;0&quot;</span> name=<span class="string">&#x27;0&#x27;</span>&gt;<span class="number">0</span>&lt;/p&gt;</span><br><span class="line">    &lt;p key=<span class="string">&quot;1&quot;</span>&gt;<span class="number">1</span>&lt;/p&gt;</span><br><span class="line">  &lt;/&gt;</span><br><span class="line">);</span><br><span class="line"><span class="keyword">const</span> b = (</span><br><span class="line">  &lt;&gt;</span><br><span class="line">    &lt;p key=<span class="string">&quot;0&quot;</span> name=<span class="string">&#x27;00&#x27;</span>&gt;<span class="number">0</span>&lt;/p&gt;</span><br><span class="line">    &lt;p key=<span class="string">&quot;1&quot;</span>&gt;<span class="number">1</span>&lt;/p&gt;</span><br><span class="line">  &lt;/&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>type变化</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = (</span><br><span class="line">  &lt;&gt;</span><br><span class="line">    &lt;p key=<span class="string">&quot;0&quot;</span>&gt;<span class="number">0</span>&lt;/p&gt;</span><br><span class="line">    &lt;p key=<span class="string">&quot;1&quot;</span>&gt;<span class="number">1</span>&lt;/p&gt;</span><br><span class="line">  &lt;/&gt;</span><br><span class="line">);</span><br><span class="line"><span class="keyword">const</span> b = (</span><br><span class="line">  &lt;&gt;</span><br><span class="line">    &lt;div key=<span class="string">&quot;0&quot;</span>&gt;<span class="number">0</span>&lt;/div&gt;</span><br><span class="line">    &lt;p key=<span class="string">&quot;1&quot;</span>&gt;<span class="number">1</span>&lt;/p&gt;</span><br><span class="line">  &lt;/&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>新增节点</p></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;p key=<span class="string">&quot;0&quot;</span>&gt;<span class="number">0</span>&lt;/p&gt;</span><br><span class="line">      &lt;p key=<span class="string">&quot;1&quot;</span>&gt;<span class="number">1</span>&lt;/p&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">const</span> b = (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;p key=<span class="string">&quot;0&quot;</span>&gt;<span class="number">0</span>&lt;/p&gt;</span><br><span class="line">      &lt;p key=<span class="string">&quot;1&quot;</span>&gt;<span class="number">1</span>&lt;/p&gt;</span><br><span class="line">      &lt;p key=<span class="string">&quot;2&quot;</span>&gt;<span class="number">2</span>&lt;/p&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br></pre></td></tr></table></figure><ul><li>节点删除</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;p key=<span class="string">&quot;0&quot;</span>&gt;<span class="number">0</span>&lt;/p&gt;</span><br><span class="line">      &lt;p key=<span class="string">&quot;1&quot;</span>&gt;<span class="number">1</span>&lt;/p&gt;</span><br><span class="line">      &lt;p key=<span class="string">&quot;2&quot;</span>&gt;<span class="number">2</span>&lt;/p&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">const</span> b = (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;p key=<span class="string">&quot;0&quot;</span>&gt;<span class="number">0</span>&lt;/p&gt;</span><br><span class="line">      &lt;p key=<span class="string">&quot;1&quot;</span>&gt;<span class="number">1</span>&lt;/p&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br></pre></td></tr></table></figure><ul><li><p>节点位置变化</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = (</span><br><span class="line">  &lt;&gt;</span><br><span class="line">    &lt;p key=<span class="string">&quot;0&quot;</span>&gt;<span class="number">0</span>&lt;/p&gt;</span><br><span class="line">    &lt;p key=<span class="string">&quot;1&quot;</span>&gt;<span class="number">1</span>&lt;/p&gt;</span><br><span class="line">  &lt;/&gt;</span><br><span class="line">);</span><br><span class="line"><span class="keyword">const</span> b = (</span><br><span class="line">  &lt;&gt;</span><br><span class="line">    &lt;p key=<span class="string">&quot;1&quot;</span>&gt;<span class="number">1</span>&lt;/p&gt;</span><br><span class="line">    &lt;p key=<span class="string">&quot;0&quot;</span>&gt;<span class="number">0</span>&lt;/p&gt;</span><br><span class="line">  &lt;/&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><p>在源码中多节点<code>diff</code>会经历三次遍历，第一次遍历处理节点的更新（包括<code>props</code>更新和<code>type</code>更新和删除），第二次遍历处理其他的情况（节点新增），其原因在于在大多数的应用中，节点更新的频率更加频繁，第三次处理位节点置改变</p><h3 id="第一次遍历"><a href="#第一次遍历" class="headerlink" title="第一次遍历"></a>第一次遍历</h3><p>​ 因为老的节点存在于<code>current Fiber</code>中，所以它是个链表结构，还记得<code>Fiber</code>双缓存结构嘛，节点通过<code>child</code>、<code>return</code>、<code>sibling</code>连接，而<code>newChildren</code>存在于<code>jsx</code>当中，所以遍历对比的时候，首先让<code>newChildren[i]</code>与<code>oldFiber</code>对比，然后让<code>i++</code>、<code>nextOldFiber = oldFiber.sibling</code>。在第一轮遍历中，会处理三种情况，其中第1，2两种情况会结束第一次循环</p><ol><li><code>key</code>不同，第一次循环结束</li><li><code>newChildren</code>或者<code>oldFiber</code>遍历完，第一次循环结束</li><li><code>key</code>同<code>type</code>不同，标记<code>oldFiber</code>为<code>DELETION</code></li><li><code>key</code>相同<code>type</code>相同则可以复用</li></ol><p><code>newChildren</code>遍历完，<code>oldFiber</code>没遍历完，在第一次遍历完成之后将<code>oldFiber</code>中没遍历完的节点标记为<code>DELETION</code>，即删除的<code>DELETION Tag</code></p><h3 id="第二次遍历"><a href="#第二次遍历" class="headerlink" title="第二次遍历"></a>第二次遍历</h3><p>第二次遍历考虑三种情况</p><ol><li><code>newChildren</code>和<code>oldFiber</code>都遍历完：多节点<code>diff</code>过程结束</li><li><code>newChildren</code>没遍历完，<code>oldFiber</code>遍历完，将剩下的<code>newChildren</code>的节点标记为<code>Placement</code>，即插入的<code>Tag</code></li><li><code>newChildren</code>和<code>oldFiber</code>没遍历完，则进入节点移动的逻辑</li></ol><h3 id="第三次遍历"><a href="#第三次遍历" class="headerlink" title="第三次遍历"></a>第三次遍历</h3><ul><li><p>主要逻辑在<code>placeChild</code>函数中，例如更新前节点顺序是<code>ABCD</code>，更新后是  <code>ACDB</code></p><ol><li><code>newChild</code>中第一个位置的<code>A</code>和<code>oldFiber</code>第一个位置的<code>A</code>，<code>key</code>  相同可复用，<code>lastPlacedIndex=0</code></li><li><code>newChild</code>中第二个位置的<code>C</code>和<code>oldFiber</code>第二个位置的<code>B</code>，<code>key</code>不同  跳出第一次循环，将<code>oldFiber</code>中的<code>BCD</code>保存在<code>map</code>中</li><li><code>newChild</code>中第二个位置的<code>C</code>在<code>oldFiber</code>中的<code>index=2 &gt;  lastPlacedIndex=0</code>不需要移动，<code>lastPlacedIndex=2</code></li><li><code>newChild</code>中第三个位置的<code>D</code>在<code>oldFiber</code>中的<code>index=3 &gt;  lastPlacedIndex=2</code>不需要移动，<code>lastPlacedIndex=3</code></li><li><code>newChild</code>中第四个位置的<code>B</code>在<code>oldFiber</code>中的<code>index=1 &lt;  lastPlacedIndex=3</code>,移动到最后</li></ol><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hexo/20210516131544.png" alt="ABCD --&gt; ACDB"></p></li><li><p>例如更新前节点顺序是<code>ABCD</code>，更新后是<code>DABC</code></p><ol><li><code>newChild</code>中第一个位置的<code>D</code>和<code>oldFiber</code>第一个位置的<code>A</code>，<code>key</code>不相同不可复用，将<code>oldFiber</code>中的<code>ABCD</code>保存在<code>map</code>中，<code>lastPlacedIndex=0</code></li><li><code>newChild</code>中第一个位置的<code>D</code>在<code>oldFiber</code>中的<code>index=3 &gt; lastPlacedIndex=0</code>不需要移动，<code>lastPlacedIndex=3</code></li><li><code>newChild</code>中第二个位置的<code>A</code>在<code>oldFiber</code>中的<code>index=0 &lt; lastPlacedIndex=3</code>,移动到最后</li><li><code>newChild</code>中第三个位置的<code>B</code>在<code>oldFiber</code>中的<code>index=1 &lt; lastPlacedIndex=3</code>,移动到最后</li><li><code>newChild</code>中第四个位置的<code>C</code>在<code>oldFiber</code>中的<code>index=2 &lt; lastPlacedIndex=3</code>,移动到最后</li></ol><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hexo/20210516132556.png" alt="ABCD --&gt; DABC"></p></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">placeChild</span>(<span class="params">newFiber, lastPlacedIndex, newIndex</span>) </span>&#123;</span><br><span class="line">  newFiber.index = newIndex;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!shouldTrackSideEffects) &#123;</span><br><span class="line">    <span class="keyword">return</span> lastPlacedIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> current = newFiber.alternate;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> oldIndex = current.index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldIndex &lt; lastPlacedIndex) &#123;</span><br><span class="line">      <span class="comment">//oldIndex小于lastPlacedIndex的位置 则将节点插入到最后</span></span><br><span class="line">      newFiber.flags = Placement;</span><br><span class="line">      <span class="keyword">return</span> lastPlacedIndex;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> oldIndex;<span class="comment">//不需要移动 lastPlacedIndex = oldIndex;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//新增插入</span></span><br><span class="line">    newFiber.flags = Placement;</span><br><span class="line">    <span class="keyword">return</span> lastPlacedIndex;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileChildrenArray</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  returnFiber: Fiber, <span class="comment">//父fiber节点</span></span></span></span><br><span class="line"><span class="function"><span class="params">  currentFirstChild: Fiber | <span class="literal">null</span>, <span class="comment">//children中第一个节点</span></span></span></span><br><span class="line"><span class="function"><span class="params">  newChildren: <span class="built_in">Array</span>&lt;*&gt;, <span class="comment">//新节点数组 也就是jsx数组</span></span></span></span><br><span class="line"><span class="function"><span class="params">  lanes: Lanes <span class="comment">//lane相关 第12章介绍</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> resultingFirstChild: Fiber | <span class="literal">null</span> = <span class="literal">null</span>; <span class="comment">//diff之后返回的第一个节点</span></span><br><span class="line">  <span class="keyword">let</span> previousNewFiber: Fiber | <span class="literal">null</span> = <span class="literal">null</span>; <span class="comment">//新节点中上次对比过的节点</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> oldFiber = currentFirstChild; <span class="comment">//正在对比的oldFiber</span></span><br><span class="line">  <span class="keyword">let</span> lastPlacedIndex = <span class="number">0</span>; <span class="comment">//上次可复用的节点位置 或者oldFiber的位置</span></span><br><span class="line">  <span class="keyword">let</span> newIdx = <span class="number">0</span>; <span class="comment">//新节点中对比到了的位置</span></span><br><span class="line">  <span class="keyword">let</span> nextOldFiber = <span class="literal">null</span>; <span class="comment">//正在对比的oldFiber</span></span><br><span class="line">  <span class="keyword">for</span> (; oldFiber !== <span class="literal">null</span> &amp;&amp; newIdx &lt; newChildren.length; newIdx++) &#123;</span><br><span class="line">    <span class="comment">//第一次遍历</span></span><br><span class="line">    <span class="keyword">if</span> (oldFiber.index &gt; newIdx) &#123;</span><br><span class="line">      <span class="comment">//nextOldFiber赋值</span></span><br><span class="line">      nextOldFiber = oldFiber;</span><br><span class="line">      oldFiber = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      nextOldFiber = oldFiber.sibling;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> newFiber = updateSlot(</span><br><span class="line">      <span class="comment">//更新节点，如果key不同则newFiber=null</span></span><br><span class="line">      returnFiber,</span><br><span class="line">      oldFiber,</span><br><span class="line">      newChildren[newIdx],</span><br><span class="line">      lanes</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (newFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (oldFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">        oldFiber = nextOldFiber;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>; <span class="comment">//跳出第一次遍历</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (shouldTrackSideEffects) &#123;</span><br><span class="line">      <span class="comment">//检查shouldTrackSideEffects</span></span><br><span class="line">      <span class="keyword">if</span> (oldFiber &amp;&amp; newFiber.alternate === <span class="literal">null</span>) &#123;</span><br><span class="line">        deleteChild(returnFiber, oldFiber);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx); <span class="comment">//标记节点插入</span></span><br><span class="line">    <span class="keyword">if</span> (previousNewFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">      resultingFirstChild = newFiber;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      previousNewFiber.sibling = newFiber;</span><br><span class="line">    &#125;</span><br><span class="line">    previousNewFiber = newFiber;</span><br><span class="line">    oldFiber = nextOldFiber;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (newIdx === newChildren.length) &#123;</span><br><span class="line">    deleteRemainingChildren(returnFiber, oldFiber); <span class="comment">//将oldFiber中没遍历完的节点标记为DELETION</span></span><br><span class="line">    <span class="keyword">return</span> resultingFirstChild;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (oldFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (; newIdx &lt; newChildren.length; newIdx++) &#123;</span><br><span class="line">      <span class="comment">//第2次遍历</span></span><br><span class="line">      <span class="keyword">const</span> newFiber = createChild(returnFiber, newChildren[newIdx], lanes);</span><br><span class="line">      <span class="keyword">if</span> (newFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx); <span class="comment">//插入新增节点</span></span><br><span class="line">      <span class="keyword">if</span> (previousNewFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">        resultingFirstChild = newFiber;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        previousNewFiber.sibling = newFiber;</span><br><span class="line">      &#125;</span><br><span class="line">      previousNewFiber = newFiber;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultingFirstChild;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将剩下的oldFiber加入map中</span></span><br><span class="line">  <span class="keyword">const</span> existingChildren = mapRemainingChildren(returnFiber, oldFiber);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (; newIdx &lt; newChildren.length; newIdx++) &#123;</span><br><span class="line">    <span class="comment">//第三次循环 处理节点移动</span></span><br><span class="line">    <span class="keyword">const</span> newFiber = updateFromMap(</span><br><span class="line">      existingChildren,</span><br><span class="line">      returnFiber,</span><br><span class="line">      newIdx,</span><br><span class="line">      newChildren[newIdx],</span><br><span class="line">      lanes</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (newFiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (shouldTrackSideEffects) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newFiber.alternate !== <span class="literal">null</span>) &#123;</span><br><span class="line">          existingChildren.delete(</span><br><span class="line">            <span class="comment">//删除找到的节点</span></span><br><span class="line">            newFiber.key === <span class="literal">null</span> ? newIdx : newFiber.key</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx); <span class="comment">//标记为插入的逻辑</span></span><br><span class="line">      <span class="keyword">if</span> (previousNewFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">        resultingFirstChild = newFiber;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        previousNewFiber.sibling = newFiber;</span><br><span class="line">      &#125;</span><br><span class="line">      previousNewFiber = newFiber;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (shouldTrackSideEffects) &#123;</span><br><span class="line">    <span class="comment">//删除existingChildren中剩下的节点</span></span><br><span class="line">    existingChildren.forEach(<span class="function">(<span class="params">child</span>) =&gt;</span> deleteChild(returnFiber, child));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> resultingFirstChild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;diff&quot;&gt;&lt;a href=&quot;#diff&quot; class=&quot;headerlink&quot; title=&quot;diff&quot;&gt;&lt;/a&gt;diff&lt;/h1&gt;&lt;p&gt;​ 在&lt;code&gt;render&lt;/code&gt;阶段更新&lt;code&gt;Fiber&lt;/code&gt;节点时，我们会调用&lt;code&gt;rec</summary>
      
    
    
    
    <category term="react 源码" scheme="https://hqwuzhaoyi.github.io/categories/react-%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="react" scheme="https://hqwuzhaoyi.github.io/tags/react/"/>
    
    <category term="源码" scheme="https://hqwuzhaoyi.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>react源码-commit阶段</title>
    <link href="https://hqwuzhaoyi.github.io/2021/04/21/react%20%E6%BA%90%E7%A0%81/6.commit%E9%98%B6%E6%AE%B5/"/>
    <id>https://hqwuzhaoyi.github.io/2021/04/21/react%20%E6%BA%90%E7%A0%81/6.commit%E9%98%B6%E6%AE%B5/</id>
    <published>2021-04-21T00:00:00.000Z</published>
    <updated>2022-08-29T03:13:16.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="commit-阶段"><a href="#commit-阶段" class="headerlink" title="commit 阶段"></a>commit 阶段</h1><p> 在<code>render</code>阶段的末尾会调用<code>commitRoot(root)</code>;进入<code>commit</code>阶段，这里的<code>root</code>指的就是<code>fiberRoot</code>，然后会遍历<code>render</code>阶段生成的<code>effectList</code>，<code>effectList</code>上的<code>Fiber</code>节点保存着对应的<code>props</code>变化。之后会遍历<code>effectList</code>进行对应的<code>dom</code>操作和生命周期、<code>hooks</code>回调或销毁函数，各个函数做的事情如下</p><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hexo/20210421221836.png" alt="render 概览"></p><p>在<code>commitRoot</code>函数中其实是调度了<code>commitRootImpl</code>函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitRoot</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> renderPriorityLevel = getCurrentPriorityLevel();</span><br><span class="line">  runWithPriority$<span class="number">1</span>(ImmediatePriority$<span class="number">1</span>, commitRootImpl.bind(<span class="literal">null</span>, root, renderPriorityLevel)); <span class="comment">// 这个函数优先级非常高，会同步的去执行</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在commitRootImpl的函数中主要分三个部分"><a href="#在commitRootImpl的函数中主要分三个部分" class="headerlink" title="在commitRootImpl的函数中主要分三个部分"></a>在<code>commitRootImpl</code>的函数中主要分三个部分</h2><ul><li><p>mutation前</p><ol><li><p>调用flushPassiveEffects执行完所有effect的任务</p></li><li><p>初始化相关变量</p></li><li><p>赋值firstEffect给后面遍历effectList用</p></li></ol>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="comment">// 调用flushPassiveEffects执行完所有effect的任务</span></span><br><span class="line">  flushPassiveEffects(); <span class="comment">// 执行上一次render阶段useEffect阶段的销毁函数，和本次useEffect阶段的回调函数</span></span><br><span class="line">&#125; <span class="keyword">while</span> (rootWithPendingPassiveEffects !== <span class="literal">null</span>); <span class="comment">// 没有未执行的useEffect</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置变量 finishedWork指rooFiber</span></span><br><span class="line">root.finishedWork = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">//重置优先级</span></span><br><span class="line">root.finishedLanes = NoLanes;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Scheduler回调函数重置</span></span><br><span class="line">root.callbackNode = <span class="literal">null</span>;</span><br><span class="line">root.callbackId = NoLanes;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置全局变量</span></span><br><span class="line"><span class="keyword">if</span> (root === workInProgressRoot) &#123;</span><br><span class="line">  workInProgressRoot = <span class="literal">null</span>;</span><br><span class="line">  workInProgress = <span class="literal">null</span>;</span><br><span class="line">  workInProgressRootRenderLanes = NoLanes;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//rootFiber可能会有新的副作用 将它也加入到effectLis</span></span><br><span class="line"><span class="keyword">let</span> firstEffect;</span><br><span class="line"><span class="keyword">if</span> (finishedWork.effectTag &gt; PerformedWork) &#123;</span><br><span class="line">  <span class="keyword">if</span> (finishedWork.lastEffect !== <span class="literal">null</span>) &#123; <span class="comment">// root 上有effectList 则挂载在链表最后</span></span><br><span class="line">    finishedWork.lastEffect.nextEffect = finishedWork;</span><br><span class="line">    firstEffect = finishedWork.firstEffect;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    firstEffect = finishedWork;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  firstEffect = finishedWork.firstEffect; <span class="comment">// root 上没有 effect</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>mutation阶段</p><p>  遍历effectList分别执行三个方法commitBeforeMutationEffects、commitMutationEffects、commitLayoutEffects执行对应的dom操作和生命周期</p><p>  在介绍双缓存Fiber树的时候，我们在构建完workInProgress Fiber树之后会将fiberRoot的current指向workInProgress Fiber，让workInProgress Fiber成为current，这个步骤发生在commitMutationEffects函数执行之后，commitLayoutEffects之前，因为componentWillUnmount发生在commitMutationEffects函数中，这时还可以获取之前的Update，而componentDidMount和componentDidUpdate会在commitLayoutEffects中执行，这时已经可以获取更新后的真实dom了</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitRootImpl</span>(<span class="params">root, renderPriorityLevel</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      commitBeforeMutationEffects();</span><br><span class="line">      nextEffect = nextEffect.nextEffect <span class="comment">// 向后遍历</span></span><br><span class="line">  &#125; <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      commitMutationEffects(root, renderPriorityLevel);<span class="comment">//commitMutationEffects</span></span><br><span class="line">  &#125; <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  root.current = finishedWork;<span class="comment">//切换current Fiber树</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    commitLayoutEffects(root, lanes);<span class="comment">//commitLayoutEffects</span></span><br><span class="line">  &#125; <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>mutation 后</p><ol><li><p>根据rootDoesHavePassiveEffects赋值相关变量</p></li><li><p>执行flushSyncCallbackQueue处理componentDidMount等生命周期或者useLayoutEffect等同步任务</p></li></ol>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rootDidHavePassiveEffects = rootDoesHavePassiveEffects;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据rootDoesHavePassiveEffects赋值相关变量</span></span><br><span class="line"><span class="keyword">if</span> (rootDoesHavePassiveEffects) &#123;</span><br><span class="line">  rootDoesHavePassiveEffects = <span class="literal">false</span>;</span><br><span class="line">  rootWithPendingPassiveEffects = root;</span><br><span class="line">  pendingPassiveEffectsLanes = lanes;</span><br><span class="line">  pendingPassiveEffectsRenderPriority = renderPriorityLevel;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保被调度</span></span><br><span class="line">ensureRootIsScheduled(root, now()); <span class="comment">// commit 阶段可能会产生新的更新， 在调度一次</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行flushSyncCallbackQueue处理componentDidMount等生命周期或者useLayoutEffect等同步任务</span></span><br><span class="line">flushSyncCallbackQueue();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></li></ul><p>现在让我们来看看mutation阶段的三个函数分别做了什么事情</p><h2 id="mutation阶段的三个函数"><a href="#mutation阶段的三个函数" class="headerlink" title="mutation阶段的三个函数"></a>mutation阶段的三个函数</h2><h3 id="commitBeforeMutationEffects"><a href="#commitBeforeMutationEffects" class="headerlink" title="commitBeforeMutationEffects"></a><code>commitBeforeMutationEffects</code></h3><p>  该函数主要做了如下两件事</p><ol><li><p>执行<code>getSnapshotBeforeUpdate</code></p><p> 在源码中<code>commitBeforeMutationEffectOnFiber</code>对应的函数是<code>commitBeforeMutationLifeCycles</code>在该函数中会调用<code>getSnapshotBeforeUpdate</code>，现在我们知道了<code>getSnapshotBeforeUpdate</code>是在<code>mutation</code>阶段中的    <code>commitBeforeMutationEffect</code>函数中执行的，而<code>commit</code>阶段是同步的，所以<code>getSnapshotBeforeUpdate</code>也同步执行</p> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitBeforeMutationLifeCycles</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  finishedWork: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (finishedWork.tag) &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">  <span class="keyword">case</span> ClassComponent: &#123;</span><br><span class="line">    <span class="keyword">if</span> (finishedWork.flags &amp; Snapshot) &#123; <span class="comment">// 如果标志是Snapshot</span></span><br><span class="line">        <span class="keyword">const</span> instance = finishedWork.stateNode; <span class="comment">// 拿到节点</span></span><br><span class="line">        <span class="keyword">const</span> snapshot = instance.getSnapshotBeforeUpdate(<span class="comment">//getSnapshotBeforeUpdate 执行生命周期</span></span><br><span class="line">          finishedWork.elementType === finishedWork.type</span><br><span class="line">            ? prevProps</span><br><span class="line">            : resolveDefaultProps(finishedWork.type, prevProps),</span><br><span class="line">          prevState,</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调度useEffect</p><p> 在<code>flushPassiveEffects</code>函数中调用<code>flushPassiveEffectsImpl</code>遍历<code>pendingPassiveHookEffectsUnmount</code>和<code>pendingPassiveHookEffectsMount</code>，执行对应的<code>effect</code>回调和销毁函数，而这两个数组是在<code>commitLayoutEffects</code>函数中赋值的（待会就会讲到），<code>mutation后effectList</code>赋值给<code>rootWithPendingPassiveEffects</code>，然后<code>scheduleCallback</code>调度执行<code>flushPassiveEffects</code></p><p> ​</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitBeforeMutationLifeCycles</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  finishedWork: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (finishedWork.tag) &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">  <span class="keyword">case</span> ClassComponent: &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; Passive)!== NoFlags) &#123; <span class="comment">// 是否存在useEffect的Flag</span></span><br><span class="line">  <span class="keyword">if</span>(!rootDoesHavePassiveEffects) &#123;</span><br><span class="line">            rootDoesHavePassiveEffects = <span class="literal">true</span>;</span><br><span class="line">            scheduleCallback(NormalSchedulerPriority, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                flushPassiveEffects(); <span class="comment">// 或执行useEffect的回调函数， 用sheduleCallback以NormalSchedulerPriority的优先级调度， 在commitjie&#x27;duan&#x27;zhi&#x27;ho</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushPassiveEffectsImpl</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (rootWithPendingPassiveEffects === <span class="literal">null</span>) &#123;<span class="comment">//在mutation后变成了root</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> unmountEffects = pendingPassiveHookEffectsUnmount;</span><br><span class="line">  pendingPassiveHookEffectsUnmount = [];<span class="comment">//useEffect的回调函数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; unmountEffects.length; i += <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> effect = ((unmountEffects[i]: any): HookEffect);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">const</span> destroy = effect.destroy;</span><br><span class="line">    destroy();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> mountEffects = pendingPassiveHookEffectsMount;<span class="comment">//useEffect的销毁函数</span></span><br><span class="line">  pendingPassiveHookEffectsMount = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; mountEffects.length; i += <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> effect = ((unmountEffects[i]: any): HookEffect);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">const</span> create = effect.create;</span><br><span class="line">    effect.destroy = create();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>componentDidUpdate</code>或<code>componentDidMount</code>会在<code>commit</code>阶段同步执行(这个后面会讲到)，而<code>useEffect</code>会在<code>commit</code>阶段异步调度，所以适用于数据请求等副作用的处理</p><p> 注意，和在<code>render</code>阶段的<code>fiber node</code>会打上<code>Placement</code>等标签一样，<code>useEffect</code>或<code>useLayoutEffect</code>也有对应的<code>effect Tag</code>，在源码中对应<code>export const Passive = /* */ 0b0000000001000000000</code>;</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitBeforeMutationEffects</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> current = nextEffect.alternate;</span><br><span class="line">    <span class="keyword">const</span> effectTag = nextEffect.effectTag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在commitBeforeMutationEffectOnFiber函数中会执行getSnapshotBeforeUpdate</span></span><br><span class="line">    <span class="keyword">if</span> ((effectTag &amp; Snapshot) !== NoEffect) &#123;</span><br><span class="line">      commitBeforeMutationEffectOnFiber(current, nextEffect);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// scheduleCallback调度useEffect</span></span><br><span class="line">    <span class="keyword">if</span> ((effectTag &amp; Passive) !== NoEffect) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!rootDoesHavePassiveEffects) &#123;</span><br><span class="line">        rootDoesHavePassiveEffects = <span class="literal">true</span>;</span><br><span class="line">        scheduleCallback(NormalSchedulerPriority, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          flushPassiveEffects();</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nextEffect = nextEffect.nextEffect;<span class="comment">//遍历effectList</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="commitMutationEffects"><a href="#commitMutationEffects" class="headerlink" title="commitMutationEffects"></a><code>commitMutationEffects</code></h3><p><code>commitMutationEffects</code>主要做了如下几件事:</p><ol><li>调用commitDetachRef解绑ref（第11章hook会讲解）</li><li>根据effectTag执行对应的dom操作</li><li>useLayoutEffect销毁函数在UpdateTag时执行</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitMutationEffects</span>(<span class="params">root: FiberRoot, renderPriorityLevel</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//遍历effectList</span></span><br><span class="line">  <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> effectTag = nextEffect.effectTag;</span><br><span class="line">    <span class="comment">// 调用commitDetachRef解绑ref</span></span><br><span class="line">    <span class="keyword">if</span> (effectTag &amp; Ref) &#123;</span><br><span class="line">      <span class="keyword">const</span> current = nextEffect.alternate;</span><br><span class="line">      <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">        commitDetachRef(current);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据effectTag执行对应的dom操作</span></span><br><span class="line">    <span class="keyword">const</span> primaryEffectTag =</span><br><span class="line">      effectTag &amp; (Placement | Update | Deletion | Hydrating);</span><br><span class="line">    <span class="keyword">switch</span> (primaryEffectTag) &#123;</span><br><span class="line">      <span class="comment">// 插入dom</span></span><br><span class="line">      <span class="keyword">case</span> Placement: &#123;</span><br><span class="line">        commitPlacement(nextEffect);</span><br><span class="line">        nextEffect.effectTag &amp;= ~Placement;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 插入更新dom</span></span><br><span class="line">      <span class="keyword">case</span> PlacementAndUpdate: &#123;</span><br><span class="line">        <span class="comment">// 插入</span></span><br><span class="line">        commitPlacement(nextEffect);</span><br><span class="line">        nextEffect.effectTag &amp;= ~Placement;</span><br><span class="line">        <span class="comment">// 更新</span></span><br><span class="line">        <span class="keyword">const</span> current = nextEffect.alternate;</span><br><span class="line">        commitWork(current, nextEffect);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      <span class="comment">// 更新dom</span></span><br><span class="line">      <span class="keyword">case</span> Update: &#123;</span><br><span class="line">        <span class="keyword">const</span> current = nextEffect.alternate;</span><br><span class="line">        commitWork(current, nextEffect);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 删除dom</span></span><br><span class="line">      <span class="keyword">case</span> Deletion: &#123;</span><br><span class="line">        commitDeletion(root, nextEffect, renderPriorityLevel);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nextEffect = nextEffect.nextEffect;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在让我们来看看操作<code>dom</code>的这几个函数</p><h4 id="commitPlacement插入节点"><a href="#commitPlacement插入节点" class="headerlink" title="commitPlacement插入节点"></a><code>commitPlacement</code>插入节点</h4><p>​ 简化后的代码很清晰，找到该节点最近的parent节点和兄弟节点，然后根据isContainer来判断是插入到兄弟节点前还是append到parent节点后</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitPlacement</span>(<span class="params">finishedWork: Fiber</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">const</span> parentFiber = getHostParentFiber(finishedWork);<span class="comment">//找到最近的parent</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> parent;</span><br><span class="line">  <span class="keyword">let</span> isContainer;</span><br><span class="line">  <span class="keyword">const</span> parentStateNode = parentFiber.stateNode;</span><br><span class="line">  <span class="keyword">switch</span> (parentFiber.tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> HostComponent:</span><br><span class="line">      parent = parentStateNode;</span><br><span class="line">      isContainer = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> before = getHostSibling(finishedWork);<span class="comment">//找兄弟节点</span></span><br><span class="line">  <span class="keyword">if</span> (isContainer) &#123;</span><br><span class="line">    insertOrAppendPlacementNodeIntoContainer(finishedWork, before, parent);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    insertOrAppendPlacementNode(finishedWork, before, parent);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="commitWork更新节点"><a href="#commitWork更新节点" class="headerlink" title="commitWork更新节点"></a>commitWork更新节点</h4><p>​ 在简化后的源码中可以看到</p><p>​ 如果fiber的tag是SimpleMemoComponent会调用commitHookEffectListUnmount执行对应的hook的销毁函数，可以看到传入的参数是HookLayout | HookHasEffect，也就是说执行useLayoutEffect的销毁函数。</p><p>​ 如果是HostComponent，那么调用commitUpdate，commitUpdate最后会调用updateDOMProperties处理对应Update的dom操作</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitWork</span>(<span class="params">current: Fiber | <span class="literal">null</span>, finishedWork: Fiber</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!supportsMutation) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (finishedWork.tag) &#123;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">      <span class="keyword">case</span> SimpleMemoComponent: &#123;</span><br><span class="line">        commitHookEffectListUnmount(HookLayout | HookHasEffect, finishedWork);</span><br><span class="line">      &#125;</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (finishedWork.tag) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">case</span> HostComponent: &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      commitUpdate(</span><br><span class="line">            instance,</span><br><span class="line">            updatePayload,</span><br><span class="line">            type,</span><br><span class="line">            oldProps,</span><br><span class="line">            newProps,</span><br><span class="line">            finishedWork,</span><br><span class="line">          );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateDOMProperties</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  domElement: Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  updatePayload: <span class="built_in">Array</span>&lt;any&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  wasCustomComponentTag: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params">  isCustomComponentTag: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO Handle wasCustomComponentTag</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; updatePayload.length; i += <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> propKey = updatePayload[i];</span><br><span class="line">    <span class="keyword">const</span> propValue = updatePayload[i + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (propKey === STYLE) &#123;</span><br><span class="line">      setValueForStyles(domElement, propValue);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propKey === DANGEROUSLY_SET_INNER_HTML) &#123;</span><br><span class="line">      setInnerHTML(domElement, propValue);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propKey === CHILDREN) &#123;</span><br><span class="line">      setTextContent(domElement, propValue);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="commitDeletion删除节点"><a href="#commitDeletion删除节点" class="headerlink" title="commitDeletion删除节点"></a>commitDeletion删除节点</h4><p>​ 如果是ClassComponent会执行componentWillUnmount，删除fiber，如果是FunctionComponent 会删除ref、并执行useEffect的销毁函数，具体可在源码中查看unmountHostComponents、commitNestedUnmounts、detachFiberMutation这几个函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitDeletion</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  finishedRoot: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderPriorityLevel: ReactPriorityLevel,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (supportsMutation) &#123;</span><br><span class="line">    <span class="comment">// Recursively delete all host nodes from the parent.</span></span><br><span class="line">    <span class="comment">// Detach refs and call componentWillUnmount() on the whole subtree.</span></span><br><span class="line">    unmountHostComponents(finishedRoot, current, renderPriorityLevel);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Detach refs and call componentWillUnmount() on the whole subtree.</span></span><br><span class="line">    commitNestedUnmounts(finishedRoot, current, renderPriorityLevel);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> alternate = current.alternate;</span><br><span class="line">  detachFiberMutation(current);</span><br><span class="line">  <span class="keyword">if</span> (alternate !== <span class="literal">null</span>) &#123;</span><br><span class="line">    detachFiberMutation(alternate);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="commitLayoutEffects"><a href="#commitLayoutEffects" class="headerlink" title="commitLayoutEffects"></a>commitLayoutEffects</h4><p>在commitMutationEffects之后所有的dom操作都已经完成，可以访问dom了，commitLayoutEffects主要做了</p><ol><li>调用commitLayoutEffectOnFiber执行相关生命周期函数或者hook相关callback</li><li>执行commitAttachRef为ref赋值</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitLayoutEffects</span>(<span class="params">root: FiberRoot, committedLanes: Lanes</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> effectTag = nextEffect.effectTag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用commitLayoutEffectOnFiber执行生命周期和hook</span></span><br><span class="line">    <span class="keyword">if</span> (effectTag &amp; (Update | Callback)) &#123;</span><br><span class="line">      <span class="keyword">const</span> current = nextEffect.alternate;</span><br><span class="line">      commitLayoutEffectOnFiber(root, current, nextEffect, committedLanes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ref赋值</span></span><br><span class="line">    <span class="keyword">if</span> (effectTag &amp; Ref) &#123;</span><br><span class="line">      commitAttachRef(nextEffect);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nextEffect = nextEffect.nextEffect;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="commitLayoutEffectOnFiber"><a href="#commitLayoutEffectOnFiber" class="headerlink" title="commitLayoutEffectOnFiber"></a>commitLayoutEffectOnFiber</h3><p>​ 在源码中commitLayoutEffectOnFiber函数的别名是commitLifeCycles，在简化后的代码中可以看到，commitLifeCycles会判断fiber的类型，SimpleMemoComponent会执行useLayoutEffect的回调，然后调度useEffect，ClassComponent会执行componentDidMount或者componentDidUpdate，this.setState第二个参数也会执行，HostRoot会执行ReactDOM.render函数的第三个参数，例如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="built_in">document</span>.querySelector(<span class="string">&quot;#root&quot;</span>), <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;root mount&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>现在可以知道useLayoutEffect是在commit阶段同步执行，useEffect会在commit阶段异步调度</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitLifeCycles</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  finishedRoot: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  finishedWork: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  committedLanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (finishedWork.tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> SimpleMemoComponent: &#123;</span><br><span class="line">      <span class="comment">// 此函数会调用useLayoutEffect的回调</span></span><br><span class="line">      commitHookEffectListMount(HookLayout | HookHasEffect, finishedWork);</span><br><span class="line">      <span class="comment">// 向pendingPassiveHookEffectsUnmount和pendingPassiveHookEffectsMount中push effect      // 并且调度它们</span></span><br><span class="line">      schedulePassiveEffects(finishedWork);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> ClassComponent: &#123;</span><br><span class="line">      <span class="comment">//条件判断...</span></span><br><span class="line">      instance.componentDidMount();</span><br><span class="line">      <span class="comment">//条件判断...</span></span><br><span class="line">      instance.componentDidUpdate(<span class="comment">//update 在layout期间同步执行</span></span><br><span class="line">        prevProps,</span><br><span class="line">        prevState,</span><br><span class="line">        instance.__reactInternalSnapshotBeforeUpdate,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> HostRoot: &#123;</span><br><span class="line">      commitUpdateQueue(finishedWork, updateQueue, instance);<span class="comment">//render第三个参数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 在schedulePassiveEffects中会将useEffect的销毁和回调函数push到pendingPassiveHookEffectsUnmount和pendingPassiveHookEffectsMount中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function schedulePassiveEffects(finishedWork: Fiber) &#123;</span><br><span class="line">  const updateQueue: FunctionComponentUpdateQueue | null &#x3D; (finishedWork.updateQueue: any);</span><br><span class="line">  const lastEffect &#x3D; updateQueue !&#x3D;&#x3D; null ? updateQueue.lastEffect : null;</span><br><span class="line">  if (lastEffect !&#x3D;&#x3D; null) &#123;</span><br><span class="line">    const firstEffect &#x3D; lastEffect.next;</span><br><span class="line">    let effect &#x3D; firstEffect;</span><br><span class="line">    do &#123;</span><br><span class="line">      const &#123;next, tag&#125; &#x3D; effect;</span><br><span class="line">      if (</span><br><span class="line">        (tag &amp; HookPassive) !&#x3D;&#x3D; NoHookEffect &amp;&amp;</span><br><span class="line">        (tag &amp; HookHasEffect) !&#x3D;&#x3D; NoHookEffect</span><br><span class="line">      ) &#123;</span><br><span class="line">        &#x2F;&#x2F;push useEffect的销毁函数并且加入调度</span><br><span class="line">        enqueuePendingPassiveHookEffectUnmount(finishedWork, effect);</span><br><span class="line">        &#x2F;&#x2F;push useEffect的回调函数并且加入调度</span><br><span class="line">        enqueuePendingPassiveHookEffectMount(finishedWork, effect);</span><br><span class="line">      &#125;</span><br><span class="line">      effect &#x3D; next;</span><br><span class="line">    &#125; while (effect !&#x3D;&#x3D; firstEffect);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="commitAttachRef"><a href="#commitAttachRef" class="headerlink" title="commitAttachRef"></a>commitAttachRef</h2><p><code>commitAttachRef</code>中会判断<code>ref</code>的类型，执行<code>ref</code>或者给<code>ref.current</code>赋值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitAttachRef</span>(<span class="params">finishedWork: Fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ref = finishedWork.ref;</span><br><span class="line">  <span class="keyword">if</span> (ref !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> instance = finishedWork.stateNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> instanceToUse;</span><br><span class="line">    <span class="keyword">switch</span> (finishedWork.tag) &#123;</span><br><span class="line">      <span class="keyword">case</span> HostComponent:</span><br><span class="line">        instanceToUse = getPublicInstance(instance);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        instanceToUse = instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> ref === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// 执行ref回调</span></span><br><span class="line">      ref(instanceToUse);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果是值的类型则赋值给ref.current</span></span><br><span class="line">      ref.current = instanceToUse;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>各阶段生命周期执行情况</p><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210512232219.png" alt="各阶段生命周期执行情况"></p><p><code>mount</code>和<code>update</code>发生的生命周期的调用如下</p><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210512232257.png" alt="mount和update发生的生命周期的调用如下"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;commit-阶段&quot;&gt;&lt;a href=&quot;#commit-阶段&quot; class=&quot;headerlink&quot; title=&quot;commit 阶段&quot;&gt;&lt;/a&gt;commit 阶段&lt;/h1&gt;&lt;p&gt; 在&lt;code&gt;render&lt;/code&gt;阶段的末尾会调用&lt;code&gt;commitR</summary>
      
    
    
    
    <category term="react 源码" scheme="https://hqwuzhaoyi.github.io/categories/react-%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="react" scheme="https://hqwuzhaoyi.github.io/tags/react/"/>
    
    <category term="源码" scheme="https://hqwuzhaoyi.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>react源码-render阶段</title>
    <link href="https://hqwuzhaoyi.github.io/2021/04/11/react%20%E6%BA%90%E7%A0%81/5.render%E9%98%B6%E6%AE%B5/"/>
    <id>https://hqwuzhaoyi.github.io/2021/04/11/react%20%E6%BA%90%E7%A0%81/5.render%E9%98%B6%E6%AE%B5/</id>
    <published>2021-04-11T00:00:00.000Z</published>
    <updated>2022-08-29T03:13:16.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="render-阶段"><a href="#render-阶段" class="headerlink" title="render 阶段"></a>render 阶段</h1><p><code>render</code>阶段的主要工作是构建<code>Fiber</code>树和生成<code>effectList</code>，在第5章中我们知道了react入口的两种模式会进入<code>performSyncWorkOnRoot</code>或者<code>performConcurrentWorkOnRoot</code>，而这两个方法分别会调用<code>workLoopSync</code>或者<code>workLoopConcurrent</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoopSync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (workInProgress !== <span class="literal">null</span>) &#123;</span><br><span class="line">    performUnitOfWork(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoopConcurrent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (workInProgress !== <span class="literal">null</span> &amp;&amp; !shouldYield()) &#123;</span><br><span class="line">    performUnitOfWork(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两函数的区别是判断条件是否存在<code>shouldYield</code>的执行，如果浏览器没有足够的时间，那么会终止<code>while</code>循环，也不会执行后面的<code>performUnitOfWork</code>函数，自然也不会执行后面的render阶段和commit阶段，这部分属于<code>scheduler</code>的知识点，我们在第12章讲解。</p><ul><li>workInProgress：新创建的<code>workInProgress fiber</code></li><li>performUnitOfWork：<code>workInProgress fiber</code>和会和已经创建的<code>Fiber</code>连接起来形成<code>Fiber</code>树。这个过程类似深度优先遍历，我们暂且称它们为‘捕获阶段’和‘冒泡阶段’。执行的过程大概如下</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (fiber.child) &#123;</span><br><span class="line">    performUnitOfWork(fiber.child);<span class="comment">//beginWork</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fiber.sibling) &#123;</span><br><span class="line">    performUnitOfWork(fiber.sibling);<span class="comment">//completeWork</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="render阶段整体执行流程"><a href="#render阶段整体执行流程" class="headerlink" title="render阶段整体执行流程"></a>render阶段整体执行流程</h2><p>看断点调试视频，函数执行细节更清楚详细：</p><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hexo/20210421223235.png" alt="render阶段整体执行流程"></p><ul><li>捕获阶段</li></ul><p>从根节点<code>rootFiber</code>开始，遍历到叶子节点，每次遍历到的节点都会执行<code>beginWork</code>，并且传入当前<code>Fiber</code>节点，然后创建或复用它的子<code>Fiber</code>节点，并赋值给<code>workInProgress.child</code>。</p><ul><li>冒泡阶段</li></ul><p>在捕获阶段遍历到子节点之后，会执行<code>completeWork</code>方法，执行完成之后会判断此节点的兄弟节点存不存在，如果存在就会为兄弟节点执行<code>completeWork</code>，当全部兄弟节点执行完之后，会向上‘冒泡’到父节点执行<code>completeWork</code>，直到<code>rootFiber</code>。</p><ul><li><p>示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      xiao</span><br><span class="line">      &lt;p&gt;chen&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>));</span><br></pre></td></tr></table></figure></li></ul><p>当执行完深度优先遍历之后形成的<code>Fiber</code>树</p><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hexo/20210421223744.png" alt="深度优先遍历 Fiber树"></p><p>图中的数字是遍历过程中的顺序，可以看到，遍历的过程中会从应用的根节点<code>rootFiber</code>开始，依次执行<code>beginWork</code>和<code>completeWork</code>，最后形成一颗<code>Fiber</code>树，每个节点以<code>child</code>和<code>return</code>相连。</p><p>注意：当遍历到只有一个子节点的<code>Fiber</code>时，该<code>Fiber</code>节点的子节点不会执行<code>beginWork</code>和<code>completeWork</code>，如图中的<code>chen</code>文本节点。这是<code>react</code>的一种优化手段</p><h2 id="beginWork"><a href="#beginWork" class="headerlink" title="beginWork"></a>beginWork</h2><p><code>beginWork</code>主要的工作是创建或复用子<code>fiber</code>节点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">beginWork</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | <span class="literal">null</span>,<span class="comment">//当前存在于dom树中对应的Fiber树 mount阶段为null</span></span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,<span class="comment">//正在构建的Fiber树 workInProgress.tag === 3 为 rootFiber</span></span></span></span><br><span class="line"><span class="function"><span class="params">  renderLanes: Lanes,<span class="comment">//第12章在讲</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 1.update时满足条件即可复用current fiber进入bailoutOnAlreadyFinishedWork函数</span></span><br><span class="line">  <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> oldProps = current.memoizedProps;</span><br><span class="line">    <span class="keyword">const</span> newProps = workInProgress.pendingProps;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      oldProps !== newProps ||</span><br><span class="line">      hasLegacyContextChanged() ||</span><br><span class="line">      (__DEV__ ? workInProgress.type !== current.type : <span class="literal">false</span>)</span><br><span class="line">    ) &#123;</span><br><span class="line">      didReceiveUpdate = <span class="literal">true</span>; <span class="comment">// 标识节点需不需要更新</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!includesSomeLane(renderLanes, updateLanes)) &#123;</span><br><span class="line">      didReceiveUpdate = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">switch</span> (workInProgress.tag) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> bailoutOnAlreadyFinishedWork(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        renderLanes,</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      didReceiveUpdate = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    didReceiveUpdate = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.根据tag来创建不同的fiber 最后进入reconcileChildren函数</span></span><br><span class="line">  <span class="keyword">switch</span> (workInProgress.tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> IndeterminateComponent:</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> LazyComponent:</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> FunctionComponent:</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> ClassComponent:</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> HostRoot:</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> HostComponent:</span><br><span class="line">      <span class="keyword">return</span> updateHostComponent(current, workInProgress, renderLanes)</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> HostText:</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看到参数中有<code>current Fiber</code>，也就是当前真实<code>dom</code>对应的<code>Fiber</code>树，在之前介绍<code>Fiber</code>双缓存机制中，我们知道在首次渲染时除了<code>rootFiber</code>外，<code>current</code> 等于 <code>null</code>，因为首次渲染<code>dom</code>还没构建出来，在<code>update</code>时<code>current</code>不等于 <code>null</code>，因为<code>update</code>时<code>dom</code>树已经存在了，所以<code>beginWork</code>函数中用<code>current === null</code>来判断是<code>mount</code>还是<code>update</code>进入不同的逻辑</p><ul><li><p><code>mount</code>：根据<code>fiber.tag</code>进入不同<code>fiber</code>的创建函数，最后都会调用到<code>reconcileChildren</code>创建子<code>Fiber</code></p></li><li><p><code>update</code>：在构建<code>workInProgress</code>的时候，当满足条件时，会复用<code>current Fiber</code>来进行优化，也就是进入<code>bailoutOnAlreadyFinishedWork</code>的逻辑，能复用<code>didReceiveUpdate</code>变量是<code>false</code>，复用的条件是</p><ul><li><code>oldProps === newProps &amp;&amp; workInProgress.type === current.type</code> 属性和<code>fiber的type</code>不变</li><li><code>!includesSomeLane(renderLanes, updateLanes)</code> 更新的优先级是否足够，第12章讲解</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateHostComponent</span>(<span class="params">current, workInProgress, renderLanes</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> isDirectTextChild = shouldTextContent(type, nextProps) <span class="comment">// 如果是唯一的子节点， 跳过节点的beginWork 和 completeWork</span></span><br><span class="line"></span><br><span class="line">  reconcileChildren(current, workInProgress, nextChildren, renderLanes) <span class="comment">// 构建子节点</span></span><br><span class="line">  <span class="keyword">return</span> workInProgress.child <span class="comment">// 等构造好所有子节点后，返回节点的子节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileChildren</span>(<span class="params">current, workInProgress, nextChildren, renderLanes</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (current === <span class="literal">null</span>) &#123;</span><br><span class="line">    workInProgress.child = mountChildFibers(workInProgress, <span class="literal">null</span>, nextChildren, renderLanes) <span class="comment">//mount时</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    workInProgress.child = reconcileChildren(current, workInProgress, nextChildren, renderLanes) <span class="comment">//update</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建子<code>fiber</code>的过程会进入<code>reconcileChildren</code>，该函数的作用是为<code>workInProgress fiber</code>节点生成它的<code>child fiber</code>即 <code>workInProgress.child</code>。然后继续深度优先遍历它的子节点执行相同的操作。</p><p><code>reconcileChildren</code>会区分<code>mount</code>和<code>update</code>两种情况，进入<code>reconcileChildFibers</code>或<code>mountChildFibers</code>，<code>reconcileChildFibers</code>和<code>mountChildFibers</code>最终其实就是<code>ChildReconciler</code>传递不同的参数返回的函数，这个参数用来表示是否追踪副作用，在<code>ChildReconciler</code>中用<code>shouldTrackSideEffects</code>来判断是否为对应的节点打上<code>effectTag</code>，例如如果一个节点需要进行插入操作，需要满足两个条件：</p><ol><li><p><code>fiber.stateNode!==null</code> 即<code>fiber</code>存在真实<code>dom</code>，真实<code>dom</code>保存在<code>stateNode</code>上</p></li><li><p><code>(fiber.effectTag &amp; Placement) !== 0</code> <code>fiber</code>存在<code>Placement</code>的<code>effectTag</code></p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> reconcileChildFibers = ChildReconciler(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mountChildFibers = ChildReconciler(<span class="literal">false</span>)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shouldTrackSideEffects需不需要追踪副作用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ChildReconciler</span>(<span class="params">shouldTrackSideEffects</span>) </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">placeChild</span>(<span class="params">newFiber, lastPlacedIndex, newIndex</span>) </span>&#123;</span><br><span class="line">    newFiber.index = newIndex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!shouldTrackSideEffects) &#123;<span class="comment">//是否追踪副作用</span></span><br><span class="line">      <span class="comment">// Noop.</span></span><br><span class="line">      <span class="keyword">return</span> lastPlacedIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> current = newFiber.alternate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> oldIndex = current.index;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (oldIndex &lt; lastPlacedIndex) &#123;</span><br><span class="line">        <span class="comment">// This is a move.</span></span><br><span class="line">        newFiber.flags = Placement;</span><br><span class="line">        <span class="keyword">return</span> lastPlacedIndex;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// This item can stay in place.</span></span><br><span class="line">        <span class="keyword">return</span> oldIndex;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// This is an insertion.</span></span><br><span class="line">      newFiber.flags = Placement;</span><br><span class="line">      <span class="keyword">return</span> lastPlacedIndex;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在之前心智模型的介绍中，我们知道为<code>Fiber</code>打上<code>effectTag</code>之后在<code>commit</code>阶段会被执行对应<code>dom</code>的增删改，而且在<code>reconcileChildren</code>的时候，<code>rootFiber</code>是存在<code>alternate</code>的，即<code>rootFiber</code>存在对应的<code>current Fiber</code>，所以<code>rootFiber</code>会走<code>reconcileChildFibers</code>的逻辑，所以<code>shouldTrackSideEffects</code>等于<code>true</code>会追踪副作用，最后为<code>rootFiber</code>打上<code>Placement</code>的<code>effectTag</code>，然后将<code>dom</code>一次性插入，提高性能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> NoFlags = <span class="comment">/*                      */</span> <span class="number">0b0000000000000000000</span>;</span><br><span class="line"><span class="comment">// 插入dom</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Placement = <span class="comment">/*                */</span> <span class="number">0b00000000000010</span>;</span><br></pre></td></tr></table></figure><p>在源码的<code>ReactFiberFlags.js</code>文件中，用二进制位运算来判断是否存在<code>Placement</code>,例如让<code>var a = NoFlags</code>,如果需要在<code>a</code>上增加<code>Placement</code>的<code>effectTag</code>，就只要<code>effectTag | Placement</code>就可以了</p><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/hexo/20210421232727.png" alt="shouldTrackSideEffects等于true会追踪副作用"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileChildFibers</span>(<span class="params">returnFiber, currentFirstChild, newChild, lanes</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> isObject = <span class="keyword">typeof</span> newChild === <span class="string">&#x27;object&#x27;</span> &amp;&amp; newChild !== <span class="literal">null</span> <span class="comment">// jsx 对象</span></span><br><span class="line">  <span class="keyword">switch</span> (newChild.$$typeof) &#123;</span><br><span class="line">    <span class="keyword">case</span> REACT_ELEMENT_TYPE:</span><br><span class="line">      <span class="keyword">return</span> placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes)) <span class="comment">// 优先级</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后进入</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileSingleElement</span>(<span class="params">returnFiber, currentFirstChild, element, lanes</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> key = element.key</span><br><span class="line">  <span class="keyword">var</span> child = currentFirstChild</span><br><span class="line">  <span class="comment">// 因为是mount阶段所以为null</span></span><br><span class="line">  <span class="keyword">while</span> (child !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 然后进入子节点的创建逻辑</span></span><br><span class="line">  <span class="keyword">if</span> (element.type === REACT_ELEMENT_TYPE) &#123;</span><br><span class="line">    <span class="keyword">var</span> created = createFiberFromElement(element.props.children, returnFiber.mode, lanes, element.key);</span><br><span class="line">    created.return = returnFiber;</span><br><span class="line">    <span class="keyword">return</span> created;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> created = createFiberFromElement(element, returnFiber.mode, lanes)</span><br><span class="line">    create</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFiberFromElement</span>(<span class="params">element, mode, lanes</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes)</span><br><span class="line">  <span class="keyword">return</span> fiber</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFiberFromTypeAndProps</span>(<span class="params">type, key, pendingProps, owner, mode, lanes</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断 type 类型</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> type == <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> type === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> fiber = createFiber(fiberTag, pendingProps, key, mode) <span class="comment">// 创建第一个子节点对应的fiber节点</span></span><br><span class="line">  fiber.elementType = type</span><br><span class="line">  fiber.type = resolvedType</span><br><span class="line">  fiber.lanes = lanes</span><br><span class="line">  <span class="keyword">return</span> fiber</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="beginWork-update"><a href="#beginWork-update" class="headerlink" title="beginWork update"></a>beginWork update</h3><p>进入到 <code>beginWork</code> 函数， 现在已存在<code>current</code>， 进入<code>update</code>逻辑, 看节点是否能复用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">beginWork</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | <span class="literal">null</span>,<span class="comment">//当前存在于dom树中对应的Fiber树 mount阶段为null</span></span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,<span class="comment">//正在构建的Fiber树 workInProgress.tag === 3 为 rootFiber</span></span></span></span><br><span class="line"><span class="function"><span class="params">  renderLanes: Lanes,<span class="comment">//第12章在讲</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 1.update时满足条件即可复用current fiber进入bailoutOnAlreadyFinishedWork函数</span></span><br><span class="line">  <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> oldProps = current.memoizedProps;</span><br><span class="line">    <span class="keyword">const</span> newProps = workInProgress.pendingProps;</span><br><span class="line">    <span class="comment">// 看props和context是否有改变</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      oldProps !== newProps ||</span><br><span class="line">      hasLegacyContextChanged() ||</span><br><span class="line">      (__DEV__ ? workInProgress.type !== current.type : <span class="literal">false</span>)</span><br><span class="line">    ) &#123;</span><br><span class="line">      didReceiveUpdate = <span class="literal">true</span>; <span class="comment">// 标识节点需不需要更新</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!includesSomeLane(renderLanes, updateLanes)) &#123; <span class="comment">// 判断render阶段的lane是否和updateLane是包含关系</span></span><br><span class="line">      didReceiveUpdate = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">switch</span> (workInProgress.tag) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> bailoutOnAlreadyFinishedWork( <span class="comment">// 进入复用阶段</span></span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        renderLanes,</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      didReceiveUpdate = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    didReceiveUpdate = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.根据tag来创建不同的fiber 最后进入reconcileChildren函数</span></span><br><span class="line">  <span class="keyword">switch</span> (workInProgress.tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> IndeterminateComponent:</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> LazyComponent:</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> FunctionComponent:</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> ClassComponent:</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> HostRoot:</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> HostComponent:</span><br><span class="line">      <span class="keyword">return</span> updateHostComponent(current, workInProgress, renderLanes)</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> HostText:</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="节点能服用"><a href="#节点能服用" class="headerlink" title="节点能服用"></a>节点能服用</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bailoutOnAlreadyFinishedWork</span>(<span class="params">current, workInProgress, renderLanes</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!includesSomeLane(renderLanes, workInProgress.childLanes)) &#123; <span class="comment">// 判断renderLanes 和 childLanes 是不是包含关系， 为什么可以拿到childLanes呢， 因为在入口函数向上遍历的时候，会一路mergeLanes</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cloneChildFibers(current, workInProgress) <span class="comment">// 如果节点需要更新</span></span><br><span class="line">    <span class="keyword">return</span> workInProgress.child</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneChildFibers</span>(<span class="params">current, workInProgress</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (workInProgress.child === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> currentChild = workInProgress.child</span><br><span class="line">  <span class="keyword">var</span> newChild = createWorkInProgress(currentChild, currentChild.pendingProps)</span><br><span class="line">  <span class="comment">// 互相连接</span></span><br><span class="line">  workInProgress.child = newChild</span><br><span class="line">  newChild.return = workInProgress</span><br><span class="line">  <span class="keyword">while</span> (currentChild.sibling !== <span class="literal">null</span>) &#123;</span><br><span class="line">    currentChild = currentChild.sibling</span><br><span class="line">    newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps)</span><br><span class="line">    newChild.return = workInProgress</span><br><span class="line">  &#125;</span><br><span class="line">  newChild.sibling = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 现在的current是存在的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWorkInProgress</span>(<span class="params">current, pendingProps</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 但是alternate不存在，因为workInProgress树还是空的</span></span><br><span class="line">  <span class="keyword">var</span> workInProgress =current.alternate</span><br><span class="line">  <span class="keyword">if</span> (workInProgress === <span class="literal">null</span>) &#123;</span><br><span class="line">    workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode)</span><br><span class="line">    <span class="comment">// 把current上面的属性给workInProgress</span></span><br><span class="line">    workInProgress.elementType = current.elementType</span><br><span class="line">    workInProgress.type = current.type</span><br><span class="line">    workInProgress.stateNode = current.stateNode</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> workInProgress</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="节点不能复用"><a href="#节点不能复用" class="headerlink" title="节点不能复用"></a>节点不能复用</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">beginWork</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  workInProgress.lanes = NoLanes</span><br><span class="line">  <span class="keyword">switch</span> (workInProgress.tag) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> HostComponent:</span><br><span class="line">      <span class="keyword">return</span> updateHostComponent(current, workInProgress, renderLanes)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateHostComponent</span>(<span class="params">current, workInProgress, renderLanes</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 和之前mount逻辑一样</span></span><br><span class="line">  <span class="function"><span class="title">reconcileChildren</span>(<span class="params">current, workInProgress, nextChildren, renderLanes</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 现在current是存在的</span></span><br><span class="line">    <span class="keyword">if</span> (current === <span class="literal">null</span>) &#123;</span><br><span class="line">      workInProgress.child = mountChildFibers(workInProgress, <span class="literal">null</span>, nextChildren, renderLanes)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileChildFibers</span>(<span class="params">returnFiber, currentFirstChild, newChild, lanes</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (isObject) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (newChild.$$typeof) &#123;</span><br><span class="line">      <span class="keyword">case</span> REACT_ELEMENT_TYPE:</span><br><span class="line">        <span class="comment">// 进入diff算法</span></span><br><span class="line">        <span class="keyword">return</span> placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="completeWork"><a href="#completeWork" class="headerlink" title="completeWork"></a>completeWork</h2><p> <code>completeWork</code>主要工作是处理<code>fiber</code>的<code>props</code>、创建<code>dom</code>、创建<code>effectList</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">completeWork</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderLanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> newProps = workInProgress.pendingProps;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据workInProgress.tag进入不同逻辑，这里我们关注HostComponent，HostComponent，其他类型之后在讲</span></span><br><span class="line">  <span class="keyword">switch</span> (workInProgress.tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> IndeterminateComponent:</span><br><span class="line">    <span class="keyword">case</span> LazyComponent:</span><br><span class="line">    <span class="keyword">case</span> SimpleMemoComponent:</span><br><span class="line">    <span class="keyword">case</span> HostRoot:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> HostComponent: &#123;</span><br><span class="line">      popHostContext(workInProgress);</span><br><span class="line">      <span class="keyword">const</span> rootContainerInstance = getRootHostContainer();</span><br><span class="line">      <span class="keyword">const</span> type = workInProgress.type;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (current !== <span class="literal">null</span> &amp;&amp; workInProgress.stateNode != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// update时</span></span><br><span class="line">       updateHostComponent(</span><br><span class="line">          current,</span><br><span class="line">          workInProgress,</span><br><span class="line">          type,</span><br><span class="line">          newProps,</span><br><span class="line">          rootContainerInstance,</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// mount时</span></span><br><span class="line">        <span class="keyword">const</span> currentHostContext = getHostContext();</span><br><span class="line">        <span class="comment">// 创建fiber对应的dom节点</span></span><br><span class="line">        <span class="keyword">const</span> instance = createInstance(</span><br><span class="line">            type,</span><br><span class="line">            newProps,</span><br><span class="line">            rootContainerInstance,</span><br><span class="line">            currentHostContext,</span><br><span class="line">            workInProgress,</span><br><span class="line">          );</span><br><span class="line">        <span class="comment">// 将后代dom节点插入刚创建的dom里</span></span><br><span class="line">        appendAllChildren(instance, workInProgress, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// dom节点赋值给fiber.stateNode</span></span><br><span class="line">        workInProgress.stateNode = instance;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理props和updateHostComponent类似</span></span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">          finalizeInitialChildren(</span><br><span class="line">            instance,</span><br><span class="line">            type,</span><br><span class="line">            newProps,</span><br><span class="line">            rootContainerInstance,</span><br><span class="line">            currentHostContext,</span><br><span class="line">          ) <span class="comment">// 把所有dom节点上的属性设置上了</span></span><br><span class="line">        ) &#123;</span><br><span class="line">          markUpdate(workInProgress);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createInstance</span>(<span class="params">type, props, rootContainerInstance, hostContext, internalInstanceHandle</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//  ...</span></span><br><span class="line">  <span class="comment">// 创建dom 节点</span></span><br><span class="line">  <span class="keyword">var</span> domElement = createElement(type, props, rootContainerInstance, parentNamespace)</span><br><span class="line">  precacheFiber(internalInstanceHandle, domElement)</span><br><span class="line">  updateFiberNode(domElement, props)</span><br><span class="line">  <span class="keyword">return</span> domElement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="completeWork-update"><a href="#completeWork-update" class="headerlink" title="completeWork update"></a>completeWork update</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">completeWork</span>(<span class="params">current, workInProgress, renderLanes</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (workInProgress.tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> HostComponent:</span><br><span class="line">      <span class="comment">//  ...</span></span><br><span class="line">      <span class="keyword">if</span> (current !== <span class="literal">null</span> &amp;&amp; workInProgress.stateNode !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 将props的变化赋值给workInProgress.updateQueue</span></span><br><span class="line">        updateHostComponent$<span class="number">1</span>(current, workInProgress, type, newProps, rootContainerInstance)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateHostComponent$1</span>(<span class="params">current, workInProgress, type, newProps, rootContainerInstance</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主要调用了prepareUpdate</span></span><br><span class="line">  <span class="keyword">var</span> updatePayload = prepareUpdate(instance, type, oldProps, rootContainerInstance, currentHostContext)</span><br><span class="line">  <span class="comment">// 因为改变了title 和 children 属性, updatePayload 为 [&#x27;title&#x27;, 2, &#x27;children&#x27;, &#x27;2&#x27;]</span></span><br><span class="line">  workInProgress.updateQueue = updatePayload</span><br><span class="line">  <span class="keyword">if</span> (updatePayload) &#123;</span><br><span class="line">    markUpdate(workInProgress)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prepareUpdate</span>(<span class="params">domElement, type, oldProps, newProps</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> diffProperties(domElement, type, oldProps, newProps) <span class="comment">// 去比较props</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 就是在Fiber节点上增加Update标记</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">markUpdate</span>(<span class="params">workInProgress</span>) </span>&#123;</span><br><span class="line">  workInProgress.flags |= Update</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从简化版的<code>completeWork</code>中可以看到，这个函数做了一下几件事</p><ul><li><p>根据<code>workInProgress.tag</code>进入不同函数，我们以<code>HostComponent</code>举例</p></li><li><p><code>update</code>时（除了判断<code>current===null</code>外还需要判断<code>workInProgress.stateNode===null</code>），调用<code>updateHostComponent</code>处理<code>props</code>（包括<code>onClick、style、children</code> …），并将处理好的<code>props</code>赋值给<code>updatePayload</code>,最后会保存在<code>workInProgress.updateQueue</code>上</p></li><li><p><code>mount</code>时 调用<code>createInstance</code>创建<code>dom</code>，将后代<code>dom</code>节点插入刚创建的<code>dom</code>中，调用<code>finalizeInitialChildren</code>处理<code>props</code>（和<code>updateHostComponent</code>处理的逻辑类似）</p></li></ul><p> 之前我们有说到在<code>beginWork</code>的<code>mount</code>时，<code>rootFiber</code>存在对应的<code>current</code>，所以他会执行<code>mountChildFibers</code>打上<code>Placement</code>的<code>effectTag</code>，在冒泡阶段也就是执行<code>completeWork</code>时，我们将子孙节点通过<code>appendAllChildren</code>挂载到新创建的<code>dom</code>节点上，最后就可以一次性将内存中的节点用<code>dom</code>原生方法反应到真实<code>dom</code>中。</p><p> 在<code>beginWork</code>中我们知道有的节点被打上了<code>effectTag</code>的标记，有的没有，而在<code>commit</code>阶段时要遍历所有包含<code>effectTag</code>的<code>Fiber</code>来执行对应的增删改，那我们还需要从<code>Fiber</code>树中找到这些带<code>effectTag</code>的节点嘛，答案是不需要的，这里是以空间换时间，在执行<code>completeWork</code>的时候遇到了带<code>effectTag</code>的节点，会将这个节点加入一个叫<code>effectList</code>中,所以在<code>commit</code>阶段只要遍历<code>effectList</code>就可以了（<code>rootFiber.firstEffect.nextEffect</code>就可以访问带<code>effectTag</code>的<code>Fiber</code>了）</p><p><code>effectList</code>的指针操作发生在<code>completeUnitOfWork</code>函数中，例如我们的应用是这样的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;App&quot;</span>&gt;</span><br><span class="line">      &lt;p onClick=&#123;<span class="function">() =&gt;</span> setCount(<span class="function">() =&gt;</span> count + <span class="number">1</span>)&#125;&gt;</span><br><span class="line">        &lt;h1 title=&#123;count&#125;&gt;&#123;count&#125;&lt;/h1&gt; and save to reload.</span><br><span class="line">      &lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们的操作<code>effectList</code>指针如下（这张图是操作指针过程中的图，此时遍历到了<code>app Fiber</code>节点，当遍历到<code>rootFiber</code>时，<code>h1</code>，<code>p</code>节点会和<code>rootFiber</code>形成环状链表）</p><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210422225657.png" alt="effectList指针"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rootFiber.firstEffect===h1</span><br><span class="line">rootFiber.firstEffect.next===p</span><br></pre></td></tr></table></figure><p>最后生成的<code>fiber</code>树如下</p><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210422225821.png" alt="effectList fiber树"></p><h3 id="effectList"><a href="#effectList" class="headerlink" title="effectList"></a>effectList</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">completeUnitOfWork</span>(<span class="params">unitOfWork</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (returnFiber !== <span class="literal">null</span> &amp;&amp; (returnFiber.flags &amp; Incomplete) === NoFlags) &#123;</span><br><span class="line">    <span class="keyword">if</span> (returnFiber.firstEffect === <span class="literal">null</span>) &#123;</span><br><span class="line">      returnFiber.firstEffect = completedWork.firstEffect</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (completedWork.lastEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (returnFiber.lastEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">        returnFiber.lastEffect = completedWork.firstEffect;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      returnFiber.lastEffect = completedWork.lastEffect</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> flags = completedWork.flags</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags &gt; PerformedWork) &#123;</span><br><span class="line">      <span class="keyword">if</span> (returnFiber.lastEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">        returnFiber.lastEffect.nextEffect = completedWork</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        returnFiber.firstEffect = completedWork</span><br><span class="line">      &#125;</span><br><span class="line">      returnFiber.lastEffect = completedWork</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> finishedWork = root.current.alternate</span><br><span class="line">root.finishedWork = finishedWork</span><br><span class="line">root.finishedLanes = lanes</span><br><span class="line">commitRoot(root)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;render-阶段&quot;&gt;&lt;a href=&quot;#render-阶段&quot; class=&quot;headerlink&quot; title=&quot;render 阶段&quot;&gt;&lt;/a&gt;render 阶段&lt;/h1&gt;&lt;p&gt;&lt;code&gt;render&lt;/code&gt;阶段的主要工作是构建&lt;code&gt;Fiber&lt;/</summary>
      
    
    
    
    <category term="react 源码" scheme="https://hqwuzhaoyi.github.io/categories/react-%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="react" scheme="https://hqwuzhaoyi.github.io/tags/react/"/>
    
    <category term="源码" scheme="https://hqwuzhaoyi.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>react源码-state触发状态更新</title>
    <link href="https://hqwuzhaoyi.github.io/2021/04/04/react%20%E6%BA%90%E7%A0%81/4.stat%E8%A7%A6%E5%8F%91%E7%8A%B6%E6%80%81%E6%9B%B4%E6%96%B0/"/>
    <id>https://hqwuzhaoyi.github.io/2021/04/04/react%20%E6%BA%90%E7%A0%81/4.stat%E8%A7%A6%E5%8F%91%E7%8A%B6%E6%80%81%E6%9B%B4%E6%96%B0/</id>
    <published>2021-04-04T00:00:00.000Z</published>
    <updated>2022-08-29T03:13:16.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="state-触发状态更新"><a href="#state-触发状态更新" class="headerlink" title="state 触发状态更新"></a>state 触发状态更新</h1><p>重点看下 <code>setState</code> <code>forceUpdate</code></p><ol><li><p><code>this.setState</code>内调用<code>this.updater.enqueueSetState</code></p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Component.prototype.setState = <span class="function"><span class="keyword">function</span> (<span class="params">partialState, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="keyword">typeof</span> partialState === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> partialState === <span class="string">&#x27;function&#x27;</span> || partialState == <span class="literal">null</span>)) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">Error</span>( <span class="string">&quot;setState(...): takes an object of state variables to update or a function which returns an object of state variables.   &quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 主要调用了这个方法</span></span><br><span class="line">  <span class="built_in">this</span>.updater.enqueueSetState(<span class="built_in">this</span>, partialState, callback, <span class="string">&#x27;setState&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReactFiberClassComponent.old.js</span></span><br><span class="line"><span class="function"><span class="title">enqueueSetState</span>(<span class="params">inst, payload, callback</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fiber = getInstance(inst);</span><br><span class="line">    <span class="keyword">const</span> eventTime = requestEventTime();</span><br><span class="line">    <span class="keyword">const</span> lane = requestUpdateLane(fiber);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> update = createUpdate(eventTime, lane);</span><br><span class="line">    <span class="comment">// payload 为上面传来的 partialState， 可以是一个状态或者函数, 如 this.setState(&#123;count: 1&#125;)中的对象</span></span><br><span class="line">    update.payload = payload;</span><br><span class="line">    <span class="keyword">if</span> (callback !== <span class="literal">undefined</span> &amp;&amp; callback !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        warnOnInvalidCallback(callback, <span class="string">&#x27;setState&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      update.callback = callback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    enqueueUpdate(fiber, update, lane); <span class="comment">// update 加入到 updateQueue 中</span></span><br><span class="line">    <span class="keyword">const</span> root = scheduleUpdateOnFiber(fiber, lane, eventTime); <span class="comment">// 然后调度这个节点</span></span><br><span class="line">    <span class="keyword">if</span> (root !== <span class="literal">null</span>) &#123;</span><br><span class="line">      entangleTransitions(root, fiber, lane);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      <span class="keyword">if</span> (enableDebugTracing) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fiber.mode &amp; DebugTracingMode) &#123;</span><br><span class="line">          <span class="keyword">const</span> name = getComponentNameFromFiber(fiber) || <span class="string">&#x27;Unknown&#x27;</span>;</span><br><span class="line">          logStateUpdateScheduled(name, lane, payload);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (enableSchedulingProfiler) &#123;</span><br><span class="line">      markStateUpdateScheduled(fiber, lane);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></li><li><p><code>this.forceUpdate</code>和<code>this.setState</code>一样，只是会让<code>tag</code>赋值<code>ForceUpdate</code></p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">enqueueForceUpdate</span>(<span class="params">inst, callback</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> fiber = getInstance(inst);</span><br><span class="line">  <span class="keyword">const</span> eventTime = requestEventTime();</span><br><span class="line">  <span class="keyword">const</span> suspenseConfig = requestCurrentSuspenseConfig();</span><br><span class="line">  <span class="keyword">const</span> lane = requestUpdateLane(fiber, suspenseConfig);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> update = createUpdate(eventTime, lane, suspenseConfig);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//tag赋值ForceUpdate</span></span><br><span class="line">  update.tag = ForceUpdate;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (callback !== <span class="literal">undefined</span> &amp;&amp; callback !== <span class="literal">null</span>) &#123;</span><br><span class="line">    update.callback = callback;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  enqueueUpdate(fiber, update);</span><br><span class="line">  scheduleUpdateOnFiber(fiber, lane, eventTime);</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 如果标记<code>ForceUpdate</code>，<code>render</code>阶段组件更新会根据<code>checkHasForceUpdateAfterProcessing</code>，和<code>checkShouldComponentUpdate</code>来判断，如果<code>Update</code>的<code>tag</code>是<code>ForceUpdate</code>，则<code>checkHasForceUpdateAfterProcessing</code>为<code>true</code>，当组件是<code>PureComponent</code>时，<code>checkShouldComponentUpdate</code>会浅比较<code>state</code>和<code>props</code>，所以当使用<code>this.forceUpdate</code>一定会更新</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shouldUpdate =</span><br><span class="line">  <span class="comment">// 如果tag 为 ForceUpdate 就 为 true 一定会更新</span></span><br><span class="line">  checkHasForceUpdateAfterProcessing() ||</span><br><span class="line">  checkShouldComponentUpdate(</span><br><span class="line">    workInProgress,</span><br><span class="line">    ctor,</span><br><span class="line">    oldProps,</span><br><span class="line">    newProps,</span><br><span class="line">    oldState,</span><br><span class="line">    newState,</span><br><span class="line">    nextContext,</span><br><span class="line">  );</span><br></pre></td></tr></table></figure></li><li><p>enqueueForceUpdate之后会经历创建update，调度update等过程，接下来就来讲这些过程</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">enqueueSetState</span>(<span class="params">inst, payload, callback</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> fiber = getInstance(inst);<span class="comment">//fiber实例</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> eventTime = requestEventTime();</span><br><span class="line">  <span class="keyword">const</span> suspenseConfig = requestCurrentSuspenseConfig();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> lane = requestUpdateLane(fiber, suspenseConfig);<span class="comment">//优先级</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> update = createUpdate(eventTime, lane, suspenseConfig);<span class="comment">//创建update</span></span><br><span class="line"></span><br><span class="line">  update.payload = payload;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (callback !== <span class="literal">undefined</span> &amp;&amp; callback !== <span class="literal">null</span>) &#123;  <span class="comment">//赋值回调</span></span><br><span class="line">    update.callback = callback;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  enqueueUpdate(fiber, update); <span class="comment">//update加入updateQueue</span></span><br><span class="line">  scheduleUpdateOnFiber(fiber, lane, eventTime);<span class="comment">//调度update</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210414222718.png" alt="状态更新整体流程"></p><h2 id="实际场景"><a href="#实际场景" class="headerlink" title="实际场景"></a>实际场景</h2><h3 id="触发更新首先进入到"><a href="#触发更新首先进入到" class="headerlink" title="触发更新首先进入到"></a>触发更新首先进入到</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueueForceUpdate</span>(<span class="params">inst, payload, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fiber = get(inst);</span><br><span class="line">  <span class="keyword">var</span> eventTime = requestEventTime();</span><br><span class="line">  <span class="keyword">var</span> lane = requestUpdateLane(fiber);</span><br><span class="line">  <span class="keyword">var</span> update = createUpdate(eventTime, lane);</span><br><span class="line">  update.payload = payload;</span><br><span class="line"></span><br><span class="line">  enqueueUpdate(fiber, update); <span class="comment">//update加入updateQueue</span></span><br><span class="line">  scheduleUpdateOnFiber(fiber, lane, eventTime); <span class="comment">//调度update</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建Update"><a href="#创建Update" class="headerlink" title="创建Update"></a>创建Update</h3><p> <code>HostRoot</code>或者<code>ClassComponent</code>触发更新后，会在函数<code>createUpdate</code>中创建<code>update</code>，并在后面的<code>render</code>阶段的<code>beginWork</code>中计算<code>Update</code>。<code>FunctionComponent</code>对应的<code>Update</code>在第11章讲，它和<code>HostRoot</code>或者<code>ClassComponent</code>的<code>Update</code>结构有些不一样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createUpdate</span>(<span class="params">eventTime: number, lane: Lane</span>): <span class="title">Update</span>&lt;*&gt; </span>&#123;<span class="comment">//创建update</span></span><br><span class="line">  <span class="keyword">const</span> update: Update&lt;*&gt; = &#123;</span><br><span class="line">    eventTime,</span><br><span class="line">    lane,</span><br><span class="line"></span><br><span class="line">    tag: UpdateState,</span><br><span class="line">    payload: <span class="literal">null</span>,</span><br><span class="line">    callback: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">    next: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> update;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们主要关注这结果参数：</p><ul><li>lane：优先级（第12章讲）</li><li>tag：更新的类型，例如UpdateState、ReplaceState</li><li>payload：ClassComponent的payload是setState第一个参数，HostRoot的payload是ReactDOM.render的第一个参数</li><li>callback：setState的第二个参数</li><li>next：连接下一个Update形成一个链表，例如同时触发多个setState时会形成多个Update，然后用next 连接</li></ul><h3 id="updateQueue"><a href="#updateQueue" class="headerlink" title="updateQueue"></a>updateQueue</h3><p>对于HostRoot或者ClassComponent会在mount的时候使用initializeUpdateQueue创建updateQueue，然后将updateQueue挂载到fiber节点上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initializeUpdateQueue</span>&lt;<span class="title">State</span>&gt;(<span class="params">fiber: Fiber</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> queue: UpdateQueue&lt;State&gt; = &#123;</span><br><span class="line">    baseState: fiber.memoizedState,</span><br><span class="line">    firstBaseUpdate: <span class="literal">null</span>,</span><br><span class="line">    lastBaseUpdate: <span class="literal">null</span>,</span><br><span class="line">  shared: &#123;</span><br><span class="line">      pending: <span class="literal">null</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    effects: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">fiber.updateQueue = queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>baseState：初始state，后面会基于这个state，根据Update计算新的state</li><li>firstBaseUpdate、lastBaseUpdate：Update形成的链表的头和尾</li><li>shared.pending：新产生的update会以单向环状链表保存在shared.pending上，计算state的时候会剪开这个环状链表，并且链接在lastBaseUpdate后</li><li>effects：calback不为null的update</li></ul><h3 id="进入到更新阶段，fiber节点向上遍历到rootFiber"><a href="#进入到更新阶段，fiber节点向上遍历到rootFiber" class="headerlink" title="进入到更新阶段，fiber节点向上遍历到rootFiber"></a>进入到更新阶段，fiber节点向上遍历到rootFiber</h3><p>进入到 <code>scheduleUpdateOnFiber</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scheduleUpdateOnFiber</span>(<span class="params">fiber, lane, eventTime</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> root = markUpdateLaneFromFiberToRoot(fiber, lane);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (root === workInProgressRoot ) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (lane === SyncLane) &#123;</span><br><span class="line">    <span class="keyword">if</span>(...) &#123;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ensureRootIsScheduled(root, eventTime)；</span><br><span class="line">      schedulePendingInteractions(root, lane)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 在markUpdateLaneFromFiberToRoot函数中会从触发更新的节点开始向上遍历到rootFiber，遍历的过程会处理节点的优先级（第12章讲）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">markUpdateLaneFromFiberToRoot</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  sourceFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  lane: Lane,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">FiberRoot</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="comment">//  进行Lane的合并</span></span><br><span class="line">  sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);</span><br><span class="line">  <span class="keyword">let</span> alternate = sourceFiber.alternate;</span><br><span class="line">  <span class="keyword">if</span> (alternate !== <span class="literal">null</span>) &#123;</span><br><span class="line">    alternate.lanes = mergeLanes(alternate.lanes, lane);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> node = sourceFiber;</span><br><span class="line">  <span class="keyword">let</span> parent = sourceFiber.return;</span><br><span class="line">  <span class="keyword">while</span> (parent !== <span class="literal">null</span>) &#123;<span class="comment">//从触发更新的节点开始向上遍历到rootFiber</span></span><br><span class="line">    parent.childLanes = mergeLanes(parent.childLanes, lane);<span class="comment">//合并childLanes优先级</span></span><br><span class="line">    alternate = parent.alternate;</span><br><span class="line">    <span class="keyword">if</span> (alternate !== <span class="literal">null</span>) &#123;</span><br><span class="line">      alternate.childLanes = mergeLanes(alternate.childLanes, lane);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    node = parent;</span><br><span class="line">    parent = parent.return;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这样就可以拿到子孙节点所有优先级</span></span><br><span class="line">  <span class="keyword">if</span> (node.tag === HostRoot) &#123;</span><br><span class="line">    <span class="keyword">const</span> root: FiberRoot = node.stateNode;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="进入调度"><a href="#进入调度" class="headerlink" title="进入调度"></a>进入调度</h3><p> 在ensureRootIsScheduled中，scheduleCallback会以一个优先级调度render阶段的开始函数performSyncWorkOnRoot或者performConcurrentWorkOnRoot</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ensureRootIsScheduled</span>(<span class="params">root, currentTime</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 当前优先级是否等于SyncLanePriority</span></span><br><span class="line">  <span class="keyword">if</span> (newCallbackPriority === SyncLanePriority) &#123;</span><br><span class="line">    <span class="comment">// 任务已经过期，需要同步执行render阶段</span></span><br><span class="line">    newCallbackNode = scheduleSyncCallback(</span><br><span class="line">      performSyncWorkOnRoot.bind(<span class="literal">null</span>, root)</span><br><span class="line">     );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 根据任务优先级异步执行render阶段</span></span><br><span class="line">    <span class="keyword">var</span> schedulerPriorityLevel = lanePriorityToSchedulerPriority(</span><br><span class="line">      newCallbackPriority</span><br><span class="line">    );</span><br><span class="line">    newCallbackNode = scheduleCallback(</span><br><span class="line">      schedulerPriorityLevel,</span><br><span class="line">      performConcurrentWorkOnRoot.bind(<span class="literal">null</span>, root)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="状态更新"><a href="#状态更新" class="headerlink" title="状态更新"></a>状态更新</h2><p>当创建rootFiber或者FiberRoot的时候，会初始化一个updateQueue队列</p><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210414231922.png" alt="状态更新"></p><p> classComponent状态计算发生在processUpdateQueue函数中，涉及很多链表操作，看图更加直白</p><ul><li>初始时fiber.updateQueue单链表上有firstBaseUpdate（update1）和lastBaseUpdate（update2），以next连接</li><li>fiber.updateQueue.shared环状链表上有update3和update4，以next连接互相连接</li><li>计算state时，先将fiber.updateQueue.shared环状链表‘剪开’，形成单链表，连接在fiber.updateQueue后面形成baseUpdate</li><li>然后遍历按这条链表，根据baseState计算出memoizedState</li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>点击状态更新，进入到</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueueSetState</span>(<span class="params">inst, payload, callback</span>) </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="title">enqueueUpdate</span>(<span class="params">fiber, update</span>)</span> &#123;</span><br><span class="line">    updateQueue = fiber.updateQueue;</span><br><span class="line">    <span class="comment">// 现在的updateQueue状态</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//   baseState: &#123;count: 0&#125;,</span></span><br><span class="line">    <span class="comment">//   effects: null,</span></span><br><span class="line">    <span class="comment">//   firstBaseUpdate: null,</span></span><br><span class="line">    <span class="comment">//   lastBaseUpdate: null,</span></span><br><span class="line">    <span class="comment">//   shared: &#123;pending: null&#125; 存放更新的update</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">var</span> sharedQueue = updateQueue.share;</span><br><span class="line">    <span class="keyword">var</span> pending = sharedQueue.pending;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pending === <span class="literal">null</span>) &#123;</span><br><span class="line">      update.next === update; <span class="comment">// 如果这是第一个update, 创建一个环状列表</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      update.next = pending.next;</span><br><span class="line">      pending.next = update;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sharedQueue.pending = update; <span class="comment">// 存放的是我们即将要去计算的update</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算过程</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processUpdateQueue</span>(<span class="params">workInProgress, props, instance, renderLanes</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> queue = workInProgress.updateQueue</span><br><span class="line">  <span class="keyword">var</span> firstBaseUpdate = queue.firstBaseUpdate</span><br><span class="line">  <span class="keyword">var</span> lastBaseUpdate = queue.lastBaseUpdate</span><br><span class="line">  <span class="keyword">var</span> pendingQueue = queue.shared.pending</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pendingQueue !== <span class="literal">null</span>) &#123;</span><br><span class="line">    queue.shared.pending = <span class="literal">null</span></span><br><span class="line">    <span class="comment">//  以下就是环状链表剪开的过程</span></span><br><span class="line">    <span class="keyword">var</span> lastPendingUpdate = pendingQueue</span><br><span class="line">    <span class="keyword">var</span> firstPendingUpdate = lastPendingUpdate.next</span><br><span class="line">    lastPendingUpdate.next = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lastBaseUpdate === <span class="literal">null</span>) &#123;</span><br><span class="line">      firstBaseUpdate = firstPendingUpdate</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      lastBaseUpdate.next = firstPendingUpdate</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把pendingUpdateQueue链表链接到了updateQueue中的最后一位， 形成了完整的链表</span></span><br><span class="line">    lastBaseUpdate = lastPendingUpdate</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对 current Fiber 也执行上面的操作</span></span><br><span class="line">  <span class="keyword">var</span> current = workInProgress.alternate</span><br><span class="line">  <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> currentQueue = current.updateQueue</span><br><span class="line">    <span class="keyword">var</span> currentLastBaseUpdate = currentQueue.lastBaseUpdate</span><br><span class="line">    <span class="keyword">if</span> (currentLastBaseUpdate !== lastBaseUpdate) &#123;</span><br><span class="line">      <span class="keyword">if</span> (currentLastBaseUpdate === <span class="literal">null</span>) &#123;</span><br><span class="line">        currentQueue.firstBaseUpdate = firstPendingUpdate</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        currentLastBaseUpdate.next = firstPendingUpdate</span><br><span class="line">      &#125;</span><br><span class="line">      currentQueue.lastBaseUpdate = lastPendingUpdate</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 接下来是一个循环，遍历我们已经创建好的新的链表</span></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 遍历过程中使用这个方法计算出新的状态</span></span><br><span class="line">    newState = getStateFromUpdate(workInProgress, queue, update, newState, props, instance)</span><br><span class="line">    <span class="comment">//  ...</span></span><br><span class="line">    update = update.next</span><br><span class="line">  &#125; <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="带优先级的状态更新"><a href="#带优先级的状态更新" class="headerlink" title="带优先级的状态更新"></a>带优先级的状态更新</h2><p>类似git提交，这里的c3意味着高优先级的任务，比如用户出发的事件，数据请求，同步执行的代码等。</p><ul><li><p>通过ReactDOM.render创建的应用没有优先级的概念，类比git提交，相当于先commit，然后提交c3<br>  <img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210414235530.png" alt="legacy状态更新"></p></li><li><p>在concurrent模式下，类似git rebase，先暂存之前的代码，在master上开发，然后rebase到之前的分支上</p><p>   优先级是由Scheduler来调度的，这里我们只关心状态计算时的优先级排序，也就是在函数processUpdateQueue中发生的计算，例如初始时有c1-c4四个update，其中c1和c3为高优先级</p><ul><li><p>在第一次render的时候，低优先级的update会跳过，所以只有c1和c3加入状态的计算</p></li><li><p>在第二次render的时候，会以第一次中跳过的update（c2）之前的update（c1）作为baseState，跳过的update和之后的update（c2，c3，c4）作为baseUpdate重新计算</p><p>在concurrent模式下，componentWillMount可能会执行多次，变现和之前的版本不一致</p><p>注意，fiber.updateQueue.shared会同时存在于workInProgress Fiber和current Fiber，目的是为了防止高优先级打断正在进行的计算而导致状态丢失，这段代码也是发生在processUpdateQueue中</p><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210414235734.png" alt="concurrent状态更新"></p></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;state-触发状态更新&quot;&gt;&lt;a href=&quot;#state-触发状态更新&quot; class=&quot;headerlink&quot; title=&quot;state 触发状态更新&quot;&gt;&lt;/a&gt;state 触发状态更新&lt;/h1&gt;&lt;p&gt;重点看下 &lt;code&gt;setState&lt;/code&gt; &lt;co</summary>
      
    
    
    
    <category term="react 源码" scheme="https://hqwuzhaoyi.github.io/categories/react-%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="react" scheme="https://hqwuzhaoyi.github.io/tags/react/"/>
    
    <category term="源码" scheme="https://hqwuzhaoyi.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>ngrok</title>
    <link href="https://hqwuzhaoyi.github.io/2021/04/03/84.ngrok/"/>
    <id>https://hqwuzhaoyi.github.io/2021/04/03/84.ngrok/</id>
    <published>2021-04-03T00:00:00.000Z</published>
    <updated>2022-08-29T03:13:16.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装-go"><a href="#安装-go" class="headerlink" title="安装 go"></a>安装 go</h1><p><a href="https://golang.org/doc/install">安装地址</a></p><h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> GO111MODULE=off</span><br><span class="line"><span class="built_in">export</span> GOPROXY=https://goproxy.cn</span><br><span class="line"><span class="built_in">export</span> GOROOT=/usr/<span class="built_in">local</span>/go <span class="comment">#当前自己的golang所在位置</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/go/bin::<span class="variable">$GOROOT</span>/bin:/usr/<span class="built_in">local</span>/ngrok/bin</span><br><span class="line"><span class="built_in">export</span> GOPATH=/usr/<span class="built_in">local</span>/ngrok/</span><br><span class="line"><span class="built_in">export</span> NGROK_DOMAIN=<span class="string">&quot;ngrok.wuzhaoyi.xyz&quot;</span></span><br></pre></td></tr></table></figure><h1 id="安装-ngrok"><a href="#安装-ngrok" class="headerlink" title="安装 ngrok"></a>安装 ngrok</h1><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/inconshreveable/ngrok.git</span><br></pre></td></tr></table></figure><h2 id="创建证书"><a href="#创建证书" class="headerlink" title="创建证书"></a>创建证书</h2><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ngrok</span><br><span class="line"></span><br><span class="line">openssl genrsa -out rootCA.key 2048</span><br><span class="line">openssl req -x509 -new -nodes -key rootCA.key -subj <span class="string">&quot;/CN=ngrok.wuzhaoyi.xyz&quot;</span> -days 5000 -out rootCA.pem</span><br><span class="line">openssl genrsa -out device.key 2048</span><br><span class="line">openssl req -new -key device.key -subj <span class="string">&quot;/CN=ngrok.wuzhaoyi.xyz&quot;</span> -out device.csr</span><br><span class="line">openssl x509 -req -<span class="keyword">in</span> device.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out device.crt -days 5000</span><br><span class="line"></span><br><span class="line">cp rootCA.pem ./assets/client/tls/ngrokroot.crt</span><br><span class="line">cp device.crt ./assets/server/tls/snakeoil.crt</span><br><span class="line">cp device.key ./assets/server/tls/snakeoil.key</span><br></pre></td></tr></table></figure><h2 id="编辑ngrok"><a href="#编辑ngrok" class="headerlink" title="编辑ngrok"></a>编辑ngrok</h2><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make release-server</span><br><span class="line">make release-client</span><br></pre></td></tr></table></figure><h2 id="开启服务端"><a href="#开启服务端" class="headerlink" title="开启服务端"></a>开启服务端</h2><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngrokd -domain=<span class="string">&quot;ngrok.wuzhaoyi.xyz&quot;</span> -httpAddr=<span class="string">&quot;:8800&quot;</span> -httpsAddr=<span class="string">&quot;:8443&quot;</span> -tunnelAddr=<span class="string">&quot;:4443&quot;</span>  &gt; log.out &amp;</span><br></pre></td></tr></table></figure><h2 id="开启客户端"><a href="#开启客户端" class="headerlink" title="开启客户端"></a>开启客户端</h2><p>移动服务器 <code>/usr/local/ngrok/bin/ngrok</code> 到 客户机</p><h3 id="给予权限"><a href="#给予权限" class="headerlink" title="给予权限"></a>给予权限</h3><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 ngrok</span><br></pre></td></tr></table></figure><h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/ngrok_client</span><br><span class="line"><span class="built_in">cd</span> ~/ngrok_client</span><br></pre></td></tr></table></figure><h3 id="简单配置"><a href="#简单配置" class="headerlink" title="简单配置"></a>简单配置</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#ngrok.cfg</span><br><span class="line">server_addr: &quot;ngrok.wuzhaoyi.xyz:4443&quot;</span><br><span class="line">trust_host_root_cert: false</span><br></pre></td></tr></table></figure><h4 id="开启"><a href="#开启" class="headerlink" title="开启"></a>开启</h4><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ngrok -config=ngrok.cfg -<span class="built_in">log</span>=ngrok.txt 80</span><br></pre></td></tr></table></figure><h3 id="同时开启-http-https-ssh"><a href="#同时开启-http-https-ssh" class="headerlink" title="同时开启 http https ssh"></a>同时开启 http https ssh</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">server_addr: &quot;ngrok.wuzhaoyi.xyz:4443&quot;</span><br><span class="line">trust_host_root_cert: false</span><br><span class="line">tunnels:</span><br><span class="line">  http:</span><br><span class="line">    subdomain: &quot;www&quot;</span><br><span class="line">    proto:</span><br><span class="line">      http: &quot;8080&quot;</span><br><span class="line"></span><br><span class="line">  https:</span><br><span class="line">    subdomain: &quot;www&quot;</span><br><span class="line">    proto:</span><br><span class="line">      https: &quot;3000&quot;</span><br><span class="line"></span><br><span class="line">  ssh:</span><br><span class="line">    remote_port: 2222</span><br><span class="line">    proto:</span><br><span class="line">      tcp: &quot;22&quot;</span><br></pre></td></tr></table></figure><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ngrok -config ngrok.cfg start http https ssh</span><br></pre></td></tr></table></figure><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210401162324.png" alt="连接"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh prajna@ngrok.wuzhaoyi.xyz -p 2222</span><br></pre></td></tr></table></figure><h1 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h1><h2 id="问题一-reconnecting"><a href="#问题一-reconnecting" class="headerlink" title="问题一 reconnecting"></a>问题一 reconnecting</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x509: certificate relies on legacy Common Name field, use SANs or temporarily enable Common Name matching with GODEBUG=x509ignoreCN=0</span><br></pre></td></tr></table></figure><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>添加到<code>.zshrc</code></p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> GODEBUG=x509ignoreCN=0</span><br></pre></td></tr></table></figure><h1 id="关闭进程"><a href="#关闭进程" class="headerlink" title="关闭进程"></a>关闭进程</h1><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lsof -i -P -n | grep  443</span><br><span class="line"></span><br><span class="line"><span class="built_in">kill</span> -9 693</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;安装-go&quot;&gt;&lt;a href=&quot;#安装-go&quot; class=&quot;headerlink&quot; title=&quot;安装 go&quot;&gt;&lt;/a&gt;安装 go&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://golang.org/doc/install&quot;&gt;安装地址&lt;/a&gt;&lt;/p&gt;
&lt;h1 </summary>
      
    
    
    
    
    <category term="ngrok" scheme="https://hqwuzhaoyi.github.io/tags/ngrok/"/>
    
  </entry>
  
  <entry>
    <title>react源码-Fiber</title>
    <link href="https://hqwuzhaoyi.github.io/2021/03/30/react%20%E6%BA%90%E7%A0%81/2.Fiber/"/>
    <id>https://hqwuzhaoyi.github.io/2021/03/30/react%20%E6%BA%90%E7%A0%81/2.Fiber/</id>
    <published>2021-03-30T00:00:00.000Z</published>
    <updated>2022-08-29T03:13:16.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Fiber"><a href="#Fiber" class="headerlink" title="Fiber"></a>Fiber</h1><p> react15在render阶段的reconcile是不可打断的，这会在进行大量dom的reconcile时产生卡顿，因为浏览器所有的时间都交给了js执行，并且js的执行时单线程。为此react16之后就有了scheduler进行时间片的调度，给每个task一定的时间，如果在这个时间内没执行完，也要交出执行权给浏览器进行绘制和重排，所以异步可中断的更新需要一定的数据结构在内存中来保存dom的信息，这个数据结构就是Fiber（虚拟dom）。</p><h2 id="Fiber的数据结构"><a href="#Fiber的数据结构" class="headerlink" title="Fiber的数据结构"></a>Fiber的数据结构</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FiberNode</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  tag: WorkTag,</span></span></span><br><span class="line"><span class="function"><span class="params">  pendingProps: mixed,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: <span class="literal">null</span> | string,</span></span></span><br><span class="line"><span class="function"><span class="params">  mode: TypeOfMode,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//保存节点的信息</span></span><br><span class="line">  <span class="built_in">this</span>.tag = tag;<span class="comment">//对应组件的类型</span></span><br><span class="line">  <span class="built_in">this</span>.key = key;<span class="comment">//key属性</span></span><br><span class="line">  <span class="built_in">this</span>.elementType = <span class="literal">null</span>;<span class="comment">//元素类型</span></span><br><span class="line">  <span class="built_in">this</span>.type = <span class="literal">null</span>;<span class="comment">//func或者class</span></span><br><span class="line">  <span class="built_in">this</span>.stateNode = <span class="literal">null</span>;<span class="comment">//真实dom节点</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//连接成fiber树</span></span><br><span class="line">  <span class="built_in">this</span>.return = <span class="literal">null</span>;<span class="comment">//指向父节点</span></span><br><span class="line">  <span class="built_in">this</span>.child = <span class="literal">null</span>;<span class="comment">//指向child</span></span><br><span class="line">  <span class="built_in">this</span>.sibling = <span class="literal">null</span>;<span class="comment">//指向兄弟节点</span></span><br><span class="line">  <span class="built_in">this</span>.index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.ref = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//用来计算state</span></span><br><span class="line">  <span class="built_in">this</span>.pendingProps = pendingProps;</span><br><span class="line">  <span class="built_in">this</span>.memoizedProps = <span class="literal">null</span>;</span><br><span class="line">  <span class="built_in">this</span>.updateQueue = <span class="literal">null</span>;</span><br><span class="line">  <span class="built_in">this</span>.memoizedState = <span class="literal">null</span>;</span><br><span class="line">  <span class="built_in">this</span>.dependencies = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.mode = mode;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//effect相关</span></span><br><span class="line">  <span class="built_in">this</span>.effectTag = NoEffect;</span><br><span class="line">  <span class="built_in">this</span>.nextEffect = <span class="literal">null</span>;</span><br><span class="line">  <span class="built_in">this</span>.firstEffect = <span class="literal">null</span>;</span><br><span class="line">  <span class="built_in">this</span>.lastEffect = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//优先级相关的属性</span></span><br><span class="line">  <span class="built_in">this</span>.lanes = NoLanes;</span><br><span class="line">  <span class="built_in">this</span>.childLanes = NoLanes;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//current和workInProgress的指针</span></span><br><span class="line">  <span class="built_in">this</span>.alternate = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">createFiberRoot FiberRootNode: 指整个应用的根节点，只存在一个</span><br><span class="line">createHostRootFiber rootFiber: ReactDOM.render或者ReactDOM.unstable_createRoot创建出来的应用的节点，可以存在多个。</span><br><span class="line"></span><br><span class="line">current Fiber</span><br><span class="line">workInProgress Fiber</span><br><span class="line">通过 alternate 指针连接</span><br></pre></td></tr></table></figure><h2 id="Fiber-双缓存"><a href="#Fiber-双缓存" class="headerlink" title="Fiber 双缓存"></a>Fiber 双缓存</h2><p> 现在我们知道了Fiber可以保存真实的dom，真实dom对应在内存中的Fiber节点会形成Fiber树，这颗Fiber树在react中叫current Fiber，也就是当前dom树对应的Fiber树，而正在构建Fiber树叫workInProgress Fiber，这两颗树的节点通过alternate相连.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      xiao</span><br><span class="line">      &lt;p&gt;chen&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>));</span><br></pre></td></tr></table></figure><h2 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h2><h3 id="createFiberRoot"><a href="#createFiberRoot" class="headerlink" title="createFiberRoot"></a>createFiberRoot</h3><p>刚开始只创建了fiberRoot和rootFiber两个节点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> root = <span class="keyword">new</span> FiberRootNode()  <span class="comment">//  和上面的FiberNode比较类似，增加了hydrate,expirationTimes(构建时间)之类的属性</span></span><br><span class="line"><span class="keyword">var</span> uninitializedFiber = <span class="function"><span class="params">createHostRootFiber</span> =&gt;</span> <span class="function"><span class="params">createFiber</span> =&gt;</span> <span class="keyword">new</span> FiberNode()</span><br><span class="line">root.current = uninitializedFiber;</span><br><span class="line">uninitializedFiber.stateNode = root;</span><br><span class="line"><span class="keyword">return</span> root;</span><br></pre></td></tr></table></figure><p>接下来构建字节点, 分别是以下两个方法</p><p><code>reconcileChildFibers</code> 和 <code>createWorkInProgress</code></p><h3 id="createWorkInProgress-current-pendingProps"><a href="#createWorkInProgress-current-pendingProps" class="headerlink" title="createWorkInProgress (current, pendingProps)"></a>createWorkInProgress (current, pendingProps)</h3><p>然后根据jsx创建workInProgress Fiber</p><p><code>current</code> 当前 Fiber</p><p><code>current.type</code>等于 3 表示当前节点为rootFiber节点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">workInProgress = current.alternate</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(workInProgress === <span class="literal">null</span>) &#123;</span><br><span class="line">workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode)</span><br><span class="line">workInProgress.elementType = current.elementType</span><br><span class="line">workInProgress.type = current.type</span><br><span class="line">workInProgress.stateNode = current.stateNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">workInProgress.alternate = current</span><br><span class="line">current.alternate = workInProgress</span><br></pre></td></tr></table></figure><p>接下来进入到<code>reconcileChildrenFibers</code>, 构建<code>rootFiber</code>的子节点</p><h3 id="reconcileChildrenFibers"><a href="#reconcileChildrenFibers" class="headerlink" title="reconcileChildrenFibers"></a>reconcileChildrenFibers</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">reconcileChildren</span>(<span class="params">current, workInProgress, nextChildren, renderLanes</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (current === <span class="literal">null</span>) &#123;</span><br><span class="line">        workInProgress.child = mountChildFibers(workInProgress, <span class="literal">null</span>, nextChildren, renderLanes)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>深度优先遍历</p><p>根据jsx（newChild）构建相应节点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">reconcileChildFibers</span>(<span class="params">returnFiber, currentFirstChild, newChild, lanes</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// returnFiber 返回的Fiber</span></span><br><span class="line">  <span class="comment">// returnFiber currentFirstChild 第一次构建为null</span></span><br><span class="line">  <span class="comment">// newChild jsx</span></span><br><span class="line">    <span class="comment">// 接下来进入到</span></span><br><span class="line">    <span class="function"><span class="title">reconcileSingleElement</span>(<span class="params">returnFiber, currentFirstChild, element, lanes</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 接着调用createFiberFromElement</span></span><br><span class="line">        <span class="comment">// 从jsx对象创建Fiber</span></span><br><span class="line">        <span class="keyword">var</span> created = <span class="function"><span class="title">createFiberFromElement</span>(<span class="params">element, mode, lanes</span>)</span> &#123;</span><br><span class="line">         <span class="keyword">var</span> fiber = <span class="function"><span class="title">createFiberFromTypeAndProps</span>(<span class="params">type, key, pendingProps, owner, mode, lanes</span>)</span> &#123;</span><br><span class="line">                <span class="comment">// IndeterminateComponent = 2;  Before we know whether it is function or class</span></span><br><span class="line">                <span class="keyword">var</span> fiberTag = IndeterminateComponent;</span><br><span class="line">                <span class="keyword">var</span> fiber = createFiber(fiberTag, pendingProps, key, mode);</span><br><span class="line">                fiber.elementType = type;</span><br><span class="line">                fiber.type = resolvedType;</span><br><span class="line">                fiber.lanes = lanes;</span><br><span class="line">                <span class="keyword">return</span> fiber;</span><br><span class="line">            &#125;</span><br><span class="line">         <span class="keyword">return</span> fiber;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// * 构造好的 fiber 的 return 指向父节点</span></span><br><span class="line">        created.return = returnFiber;</span><br><span class="line">        <span class="keyword">return</span> created;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="把workInProgress-Fiber切换成current-Fiber"><a href="#把workInProgress-Fiber切换成current-Fiber" class="headerlink" title="把workInProgress Fiber切换成current Fiber"></a>把workInProgress Fiber切换成current Fiber</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// performSyncWorkOnRoot</span></span><br><span class="line"><span class="keyword">var</span> finisedhWork = root.current.alternate;</span><br><span class="line">root.finishedWork = finishedWork;</span><br><span class="line">root.finishedLanes = lanes;</span><br><span class="line">commitRoot(root);</span><br></pre></td></tr></table></figure><p>commit 阶段</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// commitRootImpl</span></span><br><span class="line">root.current = finishedWork</span><br></pre></td></tr></table></figure><h2 id="update"><a href="#update" class="headerlink" title="update"></a>update</h2><h3 id="createWorkInProgress-current-pendingProps-1"><a href="#createWorkInProgress-current-pendingProps-1" class="headerlink" title="createWorkInProgress(current, pendingProps)"></a>createWorkInProgress(current, pendingProps)</h3><p><code>current.type</code> 为 3, 表明当前节点时<code>rootFiber</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> workInProgress = current.alternate;</span><br><span class="line"><span class="comment">// workInProgress.tag = 3 克隆或者服用而来</span></span><br><span class="line"><span class="comment">// 如果不存在 节点， createFiber</span></span><br><span class="line"><span class="keyword">if</span>(workInProgress === <span class="literal">null</span>) &#123;</span><br><span class="line">    workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode);</span><br><span class="line">    ...</span><br><span class="line">    workInProgress.alternate = current;</span><br><span class="line">    current.alternate = workInProgress;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把 current 属性 复制到 WorkInProgress</span></span><br><span class="line">workInProgress.childLanes = current.childLanes;</span><br><span class="line">workInProgress.lanes = current.lanes;</span><br><span class="line">workInProgress.child = current.child;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 并且 alternate 指针互相连接</span></span><br></pre></td></tr></table></figure><p>然后进入 reconcileChildFibers 深度遍历子节点</p><h3 id="reconcileChildFibers"><a href="#reconcileChildFibers" class="headerlink" title="reconcileChildFibers"></a>reconcileChildFibers</h3><p>深度遍历</p><p>再次执行切换过程</p><h3 id="commitRootImpl"><a href="#commitRootImpl" class="headerlink" title="commitRootImpl"></a>commitRootImpl</h3><p>切换 current</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Fiber&quot;&gt;&lt;a href=&quot;#Fiber&quot; class=&quot;headerlink&quot; title=&quot;Fiber&quot;&gt;&lt;/a&gt;Fiber&lt;/h1&gt;&lt;p&gt; react15在render阶段的reconcile是不可打断的，这会在进行大量dom的reconcile时产生卡</summary>
      
    
    
    
    <category term="react 源码" scheme="https://hqwuzhaoyi.github.io/categories/react-%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="react" scheme="https://hqwuzhaoyi.github.io/tags/react/"/>
    
    <category term="源码" scheme="https://hqwuzhaoyi.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>react源码-入口函数</title>
    <link href="https://hqwuzhaoyi.github.io/2021/03/27/react%20%E6%BA%90%E7%A0%81/3.%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0/"/>
    <id>https://hqwuzhaoyi.github.io/2021/03/27/react%20%E6%BA%90%E7%A0%81/3.%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0/</id>
    <published>2021-03-27T00:00:00.000Z</published>
    <updated>2022-08-29T03:13:16.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="react中的入口函数的模式"><a href="#react中的入口函数的模式" class="headerlink" title="react中的入口函数的模式"></a>react中的入口函数的模式</h1><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210322225640.png" alt="主要流程"></p><p><img src="https://wuzhaoyi-xyz.oss-cn-beijing.aliyuncs.com/git20210322225712.png" alt="主要函数执行过程"></p><h2 id="legacy"><a href="#legacy" class="headerlink" title="legacy"></a>legacy</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">render() =&gt;</span><br><span class="line">  <span class="comment">//  判断root 节点存不存在， 不存在</span></span><br><span class="line">  legacyRenderSubtreeIntoContainer() =&gt; &#123;</span><br><span class="line">    legacyCreateRootFromDOMContainer()  =&gt; &#123;</span><br><span class="line">      <span class="comment">// 首先ssr渲染相关逻辑</span></span><br><span class="line">      <span class="keyword">var</span> shouldHydrate = forceHydrate || shouldXXXHeuristic(container);</span><br><span class="line">      <span class="comment">//  中间代码... 然后</span></span><br><span class="line">      <span class="keyword">return</span> createLegacyRoot(container, shouldHydrate? &#123; <span class="attr">hydrate</span>: <span class="literal">true</span> &#125; : <span class="literal">undefined</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReactDOMBlockingRoot(container, LegacyRoot, options) =&gt; &#123;</span><br><span class="line">          <span class="comment">// 创建根节点</span></span><br><span class="line">          <span class="built_in">this</span>._internalRoot = createRootImpl(container, tag, options)  =&gt; &#123;</span><br><span class="line">            <span class="keyword">var</span> root = createContainer(container, tag, hydrate) =&gt; &#123;</span><br><span class="line">              <span class="keyword">return</span> createFiberRoot(containerInfo, tag, hydrate) =&gt; &#123;</span><br><span class="line">                <span class="keyword">var</span> root = <span class="keyword">new</span> FiberRootNode(containerInfo, tag, hydrate)</span><br><span class="line">                <span class="keyword">var</span> uninitializedFiber = createHostRootFiber(tag)</span><br><span class="line">                root.current = uninitializedFiber</span><br><span class="line">                uninitializedFiber.stateNode = root</span><br><span class="line">                initializeUpdateQueue(uninitializedFiber)</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建Update对象</p><p>对于HostRoot或者ClassComponent会使用initializeUpdateQueue创建updateQueue，然后将updateQueue挂载到fiber节点上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initializeUpdateQueue</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> queue = &#123;</span><br><span class="line">    baseState: fiber.memoizedState, <span class="comment">//初始state，后面会基于这个state，根据Update计算新的state</span></span><br><span class="line">    firstBaseUpdate: <span class="literal">null</span>, <span class="comment">//Update形成的链表的头</span></span><br><span class="line">    lastBaseUpdate: <span class="literal">null</span>, <span class="comment">//Update形成的链表的尾</span></span><br><span class="line">    <span class="comment">//新产生的update会以单向环状链表保存在shared.pending上，计算state的时候会剪开这个环状链表，</span></span><br><span class="line">    <span class="comment">//并且连接在lastBaseUpdate后</span></span><br><span class="line">    shared: &#123;<span class="attr">pending</span>: <span class="literal">null</span>&#125;,</span><br><span class="line">    effects: <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  fiber.updateQueue = queue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>然后我们进入<code>updateContainer</code>函数</p><h3 id="updateContainer"><a href="#updateContainer" class="headerlink" title="updateContainer"></a>updateContainer</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateContainer</span>(<span class="params">element, container, parentComponent, callback</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取update优先级</span></span><br><span class="line">  <span class="keyword">var</span> lane = requestUpdateLane</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  创建update</span></span><br><span class="line">  <span class="keyword">var</span> update = createUpdate(eventTime, lane)</span><br><span class="line">  <span class="comment">// 就是jsx对象</span></span><br><span class="line">  update.payload = &#123; <span class="attr">element</span>: element &#125;</span><br><span class="line">  enqueueUpdate(current, update) <span class="comment">// 生成换装链表</span></span><br><span class="line">  scheduleUpdateOnFiber(current, lane, eventTime)</span><br><span class="line">  <span class="keyword">return</span> lane;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createUpdate</span>(<span class="params">eventTime, lane</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// * 和 UpdateQueue 中的对象有些区别</span></span><br><span class="line">  <span class="keyword">var</span> update = &#123;</span><br><span class="line">    eventTime： eventTime,</span><br><span class="line">    lane: lane,</span><br><span class="line">    tag: UpdateState,</span><br><span class="line">    payload: <span class="literal">null</span>,</span><br><span class="line">    callback: <span class="literal">null</span>,</span><br><span class="line">    next: <span class="literal">null</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> update;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enqueueUpdate</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueueUpdate</span>(<span class="params">fiber, update</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  updateQueue = fiber.updateQueue;</span><br><span class="line"></span><br><span class="line">  sharedQueue = updateQueue.shared <span class="comment">// 将要处理的update都会挂载在这个上面</span></span><br><span class="line">  pending = sharedQueue.pending</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(pending === <span class="literal">null</span>) &#123;</span><br><span class="line">    update.next = update <span class="comment">// 形成环状列表</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    update.next = pending.next</span><br><span class="line">    pending.next = update</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sharedQueue.pending = update <span class="comment">// 然后环状列表挂载在这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="scheduleUpdateOnFiber"><a href="#scheduleUpdateOnFiber" class="headerlink" title="scheduleUpdateOnFiber"></a>scheduleUpdateOnFiber</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scheduleUpdateOnFiber</span>(<span class="params">fiber, lane, eventTime</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断 lane 优先级</span></span><br><span class="line">  <span class="keyword">if</span> (lane === SyncLane) &#123; <span class="comment">// 如果是同步Lane</span></span><br><span class="line">    performSyncWorkOnRoot(root)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="concurrent"><a href="#concurrent" class="headerlink" title="concurrent"></a>concurrent</h2><h3 id="起点-createRoot"><a href="#起点-createRoot" class="headerlink" title="起点 createRoot"></a>起点 createRoot</h3><p>创建根节点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createRoot</span>(<span class="params">container, options</span>) =&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ReactDOMRoot(container, options) =&gt;  &#123;</span><br><span class="line">    <span class="comment">// 接下来的逻辑和legacy一样</span></span><br><span class="line">    <span class="built_in">this</span>.internalRoot = createRootImpl(container, ConcurrentRoot, options)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ReactDOMRoot-prototype-render"><a href="#ReactDOMRoot-prototype-render" class="headerlink" title="ReactDOMRoot.prototype.render"></a>ReactDOMRoot.prototype.render</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ReactDOMRoot.prototype.render = ReactDOMBlockingRoot.prototype.render = <span class="function"><span class="keyword">function</span> (<span class="params">children</span>) =&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> root = <span class="built_in">this</span>.internalRoot</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 主要调用</span></span><br><span class="line">  updateContainer(children, root, <span class="literal">null</span>, <span class="literal">null</span>) <span class="comment">// updateContainer做的功能就和legacy模式一样</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scheduleUpdateOnFiber</span>(<span class="params">fiber, lane, eventTime</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//  ... 和上面一样 判断优先级 但此处 lane 不为 SyncLane</span></span><br><span class="line">   <span class="keyword">if</span> (lane === SyncLane) &#123;<span class="comment">//同步lane 对应legacy模式</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    performSyncWorkOnRoot(root);<span class="comment">//render阶段的起点 render在地6章讲解</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;<span class="comment">//concurrent模式</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    ensureRootIsScheduled(root, eventTime);<span class="comment">//确保root被调度</span></span><br><span class="line">  &#125;</span><br><span class="line">  ensureRootIsScheduled(root, currentTme) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">var</span> nextLanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes); <span class="comment">//计算nextLanes</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nextLanes === NoLanes) &#123;</span><br><span class="line">      <span class="comment">// 判断 nextLanes 优先级</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  判断调度函数优先级是不是等于</span></span><br><span class="line">    <span class="keyword">if</span> (newCallbackPrPriority === SyncLanePriority) &#123;</span><br><span class="line">      <span class="comment">// 直接调用回调</span></span><br><span class="line">      scheduleCallback(performSyncWorkOnRoot.bind(<span class="literal">null</span>, root))</span><br><span class="line">    &#125; <span class="keyword">else</span>  <span class="keyword">if</span> (newCallbackPrPriority === S yncBatchedLanePriority) &#123;</span><br><span class="line">      <span class="comment">// 用 ImmediatePriority 的优先级来调度我们的回调</span></span><br><span class="line">      scheduleCallback(ImmediatePriority$<span class="number">1</span>, performSyncWorkOnRoot.bind(<span class="literal">null</span>, root))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> schedulerPriorityLevel = lanePriorityToSchedulerPriority(newCallbackPrPriority) <span class="comment">// 把lane优先级转换成schedule优先级</span></span><br><span class="line">        <span class="comment">//以schedulerPriorityLevel的优先级执行performConcurrentWorkOnRoot 也就是concurrent模式的起点</span></span><br><span class="line">      scheduleCallback(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(<span class="literal">null</span>, root))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两种模式的不同点"><a href="#两种模式的不同点" class="headerlink" title="两种模式的不同点"></a>两种模式的不同点</h2><ul><li>createRootImpl中传入的第二个参数不一样 一个是LegacyRoot一个是ConcurrentRoot</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create(container, tag, options)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReactRootTags.js</span></span><br><span class="line"><span class="keyword">export</span> type RootTag = <span class="number">0</span> | <span class="number">1</span> | <span class="number">2</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> LegactRoot = <span class="number">0</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> BlockingRoot = <span class="number">1</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ConcurrentRoot = <span class="number">2</span></span><br></pre></td></tr></table></figure><ul><li>requestUpdateLane中获取的lane的优先级不同</li><li>在函数scheduleUpdateOnFiber中根据不同优先级进入不同分支，legacy模式进入performSyncWorkOnRoot，concurrent模式会异步调度performConcurrentWorkOnRoot</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;react中的入口函数的模式&quot;&gt;&lt;a href=&quot;#react中的入口函数的模式&quot; class=&quot;headerlink&quot; title=&quot;react中的入口函数的模式&quot;&gt;&lt;/a&gt;react中的入口函数的模式&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://wuzh</summary>
      
    
    
    
    <category term="react 源码" scheme="https://hqwuzhaoyi.github.io/categories/react-%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="react" scheme="https://hqwuzhaoyi.github.io/tags/react/"/>
    
    <category term="源码" scheme="https://hqwuzhaoyi.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
</feed>
